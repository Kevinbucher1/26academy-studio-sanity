import {
  EMPTY,
  Observable,
  Preview$1,
  Subject,
  WithReferringDocuments,
  __awaiter,
  __generator,
  __spread,
  _arrayLikeToArray,
  _classCallCheck,
  _createClass,
  _createSuper,
  _defineProperty,
  _extends,
  _inherits,
  _objectWithoutPropertiesLoose,
  _typeof,
  _unsupportedIterableToArray,
  bufferTime,
  catchError,
  current,
  debounceTime,
  definePlugin,
  delay,
  empty,
  filter,
  first,
  from,
  iif,
  index,
  isDraft,
  isDraftable,
  map,
  merge,
  mergeMap,
  nanoid,
  observeOn,
  of,
  produce,
  queueScheduler,
  require_hoist_non_react_statics_cjs,
  require_prop_types,
  require_with_selector,
  subscribeOn,
  switchMap,
  takeUntil,
  throwError,
  useClient,
  useColorSchemeValue,
  useDocumentStore,
  useFormValue,
  useIntentLink,
  useSchema,
  v4_default,
  withLatestFrom
} from "./chunk-4Z3U2EFS.js";
import {
  AddIcon,
  AnimatePresence,
  ArrowDownIcon,
  ArrowUpIcon,
  COLOR_HUES,
  COLOR_TINTS,
  CheckmarkCircleIcon,
  CheckmarkIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  ChevronUpIcon,
  ClipboardIcon,
  CloseIcon,
  ComposeIcon,
  DownloadIcon,
  EditIcon,
  ErrorOutlineIcon,
  Icon,
  ImageIcon,
  PlugIcon,
  RemoveIcon,
  ResizeObserver as ResizeObserver2,
  SearchIcon,
  SelectIcon,
  SortIcon,
  SpinnerIcon,
  ThLargeIcon,
  ThListIcon,
  ToggleArrowRightIcon,
  TrashIcon,
  UploadIcon,
  WarningFilledIcon,
  WarningOutlineIcon,
  arrow,
  autoPlacement,
  autoUpdate,
  color,
  detectOverflow,
  dt,
  flip,
  ft,
  hide,
  hues,
  lt,
  motion,
  mt,
  nt,
  offset,
  ot,
  require_react_is,
  shift,
  useEffectEvent,
  useFloating,
  white
} from "./chunk-OEIDAOBU.js";
import "./chunk-LHCL2R4R.js";
import "./chunk-QCUVG3AT.js";
import "./chunk-4LRVKWBX.js";
import {
  require_dist
} from "./chunk-TVGXUZQ5.js";
import {
  require_react_dom
} from "./chunk-KBNY4C7Z.js";
import {
  require_jsx_runtime
} from "./chunk-UPJDJ6WQ.js";
import {
  require_react
} from "./chunk-BIX6U3XI.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-PLDDJCW6.js";

// node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS({
  "node_modules/pluralize/pluralize.js"(exports, module) {
    (function(root, pluralize2) {
      if (typeof __require === "function" && typeof exports === "object" && typeof module === "object") {
        module.exports = pluralize2();
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return pluralize2();
        });
      } else {
        root.pluralize = pluralize2();
      }
    })(exports, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word, token2) {
        if (word === token2) return token2;
        if (word === word.toLowerCase()) return token2.toLowerCase();
        if (word === word.toUpperCase()) return token2.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token2.charAt(0).toUpperCase() + token2.substr(1).toLowerCase();
        }
        return token2.toLowerCase();
      }
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match3, index2) {
          return args[index2] || "";
        });
      }
      function replace2(word, rule) {
        return word.replace(rule[0], function(match3, index2) {
          var result = interpolate(rule[1], arguments);
          if (match3 === "") {
            return restoreCase(word[index2 - 1], result);
          }
          return restoreCase(match3, result);
        });
      }
      function sanitizeWord(token2, word, rules) {
        if (!token2.length || uncountables.hasOwnProperty(token2)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word)) return replace2(word, rule);
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) {
            return restoreCase(word, token2);
          }
          if (replaceMap.hasOwnProperty(token2)) {
            return restoreCase(word, replaceMap[token2]);
          }
          return sanitizeWord(token2, word, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) return true;
          if (replaceMap.hasOwnProperty(token2)) return false;
          return sanitizeWord(token2, token2, rules) === token2;
        };
      }
      function pluralize2(word, count, inclusive) {
        var pluralized = count === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
        return (inclusive ? count + " " : "") + pluralized;
      }
      pluralize2.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize2.addPluralRule(word, "$0");
        pluralize2.addSingularRule(word, "$0");
      };
      pluralize2.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize2.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize2.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize2.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eé]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize2.addUncountableRule);
      return pluralize2;
    });
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i3 = 0; i3 < selection.rangeCount; i3++) {
        ranges.push(selection.getRangeAt(i3));
      }
      switch (active.tagName.toUpperCase()) {
        // .toUpperCase handles XHTML
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range2) {
            selection.addRange(range2);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format2(message2) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message2.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy3(text, options2) {
      var debug, message2, reselectPrevious, range2, selection, mark, success = false;
      if (!options2) {
        options2 = {};
      }
      debug = options2.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range2 = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options2.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format3 = clipboardToIE11Formatting[options2.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format3, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options2.format, text);
            }
          }
          if (options2.onCopy) {
            e2.preventDefault();
            options2.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range2.selectNodeContents(mark);
        selection.addRange(range2);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options2.format || "text", text);
          options2.onCopy && options2.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message2 = format2("message" in options2 ? options2.message : defaultMessage);
          window.prompt(message2, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range2);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy3;
  }
});

// node_modules/attr-accept/dist/es/index.js
var require_es = __commonJS({
  "node_modules/attr-accept/dist/es/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = function(file, acceptedFiles) {
      if (file && acceptedFiles) {
        var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
        if (acceptedFilesArray.length === 0) {
          return true;
        }
        var fileName = file.name || "";
        var mimeType = (file.type || "").toLowerCase();
        var baseMimeType = mimeType.replace(/\/.*$/, "");
        return acceptedFilesArray.some(function(type) {
          var validType = type.trim().toLowerCase();
          if (validType.charAt(0) === ".") {
            return fileName.toLowerCase().endsWith(validType);
          } else if (validType.endsWith("/*")) {
            return baseMimeType === validType.replace(/\/.*$/, "");
          }
          return mimeType === validType;
        });
      }
      return true;
    };
  }
});

// node_modules/sanity-plugin-media/dist/index.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);

// node_modules/sanity-plugin-media/node_modules/@sanity/ui/dist/theme.mjs
var colors = {
  default: {
    lightest: "hsl(0, 0%, 95%)",
    lighter: "hsl(0, 0%, 70%)",
    light: "hsl(0, 0%, 65%)",
    base: "hsl(0, 0%, 50%)",
    dark: "hsl(0, 0%, 35%)",
    darker: "hsl(0, 0%, 20%)",
    darkest: "hsl(0, 0%, 5%)"
  },
  transparent: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  primary: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  positive: {
    lightest: "hsl(120, 100%, 95%)",
    lighter: "hsl(120, 100%, 70%)",
    light: "hsl(120, 100%, 65%)",
    base: "hsl(120, 100%, 50%)",
    dark: "hsl(120, 100%, 35%)",
    darker: "hsl(120, 100%, 20%)",
    darkest: "hsl(120, 100%, 5%)"
  },
  caution: {
    lightest: "hsl(60, 100%, 95%)",
    lighter: "hsl(60, 100%, 70%)",
    light: "hsl(60, 100%, 65%)",
    base: "hsl(60, 100%, 50%)",
    dark: "hsl(60, 100%, 35%)",
    darker: "hsl(60, 100%, 20%)",
    darkest: "hsl(60, 100%, 5%)"
  },
  critical: {
    lightest: "hsl(0, 100%, 95%)",
    lighter: "hsl(0, 100%, 70%)",
    light: "hsl(0, 100%, 65%)",
    base: "hsl(0, 100%, 50%)",
    dark: "hsl(0, 100%, 35%)",
    darker: "hsl(0, 100%, 20%)",
    darkest: "hsl(0, 100%, 5%)"
  }
};
var tones = {
  transparent: {
    bg: [colors.transparent.darkest, colors.transparent.lightest],
    fg: [colors.transparent.lightest, colors.transparent.darkest],
    border: [colors.transparent.darker, colors.transparent.lighter],
    focusRing: [colors.transparent.base, colors.transparent.base]
  },
  primary: {
    bg: [colors.primary.darkest, colors.primary.lightest],
    fg: [colors.primary.lightest, colors.primary.darkest],
    border: [colors.primary.darker, colors.primary.lighter],
    focusRing: [colors.primary.base, colors.primary.base]
  },
  positive: {
    bg: [colors.positive.darkest, colors.positive.lightest],
    fg: [colors.positive.lightest, colors.positive.darkest],
    border: [colors.positive.darker, colors.positive.lighter],
    focusRing: [colors.positive.base, colors.positive.base]
  },
  caution: {
    bg: [colors.caution.darkest, colors.caution.lightest],
    fg: [colors.caution.lightest, colors.caution.darkest],
    border: [colors.caution.darker, colors.caution.lighter],
    focusRing: [colors.caution.base, colors.caution.base]
  },
  critical: {
    bg: [colors.critical.darkest, colors.critical.lightest],
    fg: [colors.critical.lightest, colors.critical.darkest],
    border: [colors.critical.darker, colors.critical.lighter],
    focusRing: [colors.critical.base, colors.critical.base]
  }
};
var defaultThemeConfig = {
  avatar: {
    sizes: [{
      distance: -4,
      size: 19
    }, {
      distance: -4,
      size: 25
    }, {
      distance: -8,
      size: 33
    }, {
      distance: -12,
      size: 49
    }],
    focusRing: {
      offset: 1,
      width: 1
    }
  },
  button: {
    textWeight: "medium",
    border: {
      width: 1
    },
    focusRing: {
      offset: -1,
      width: 1
    }
  },
  card: {
    border: {
      width: 1
    },
    focusRing: {
      offset: -1,
      width: 1
    },
    shadow: {
      outline: 0.5
    }
  },
  container: [320, 640, 960, 1280, 1600, 1920],
  media: [360, 600, 900, 1200, 1800, 2400],
  layer: {
    dialog: {
      zOffset: 600
    },
    popover: {
      zOffset: 400
    },
    tooltip: {
      zOffset: 200
    }
  },
  radius: [0, 1, 3, 6, 9, 12, 21],
  shadow: [null, {
    umbra: [0, 0, 0, 0],
    penumbra: [0, 0, 0, 0],
    ambient: [0, 0, 0, 0]
  }, {
    umbra: [0, 3, 5, -2],
    penumbra: [0, 6, 10, 0],
    ambient: [0, 1, 18, 1]
  }, {
    umbra: [0, 7, 8, -4],
    penumbra: [0, 12, 17, 2],
    ambient: [0, 5, 22, 4]
  }, {
    umbra: [0, 9, 11, -5],
    penumbra: [0, 18, 28, 2],
    ambient: [0, 7, 34, 6]
  }, {
    umbra: [0, 11, 15, -7],
    penumbra: [0, 24, 38, 3],
    ambient: [0, 9, 46, 8]
  }],
  space: [0, 4, 8, 12, 20, 32, 52, 84, 136, 220],
  input: {
    border: {
      width: 1
    },
    checkbox: {
      size: 17,
      focusRing: {
        offset: -1,
        width: 1
      }
    },
    radio: {
      size: 17,
      markSize: 9,
      focusRing: {
        offset: -1,
        width: 1
      }
    },
    switch: {
      width: 25,
      height: 17,
      padding: 5,
      transitionDurationMs: 150,
      transitionTimingFunction: "ease-out",
      focusRing: {
        offset: 1,
        width: 1
      }
    },
    select: {
      focusRing: {
        offset: -1,
        width: 1
      }
    },
    text: {
      focusRing: {
        offset: -1,
        width: 1
      }
    }
  },
  style: {
    button: {
      root: {
        transition: "background-color 100ms,border-color 100ms,color 100ms"
      }
    }
    // card: {
    //   root: {
    //     transition: 'background-color 100ms,border-color 100ms,color 100ms',
    //   },
    // },
  }
};
var defaultThemeFonts = {
  code: {
    family: "ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace",
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [{
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 10,
      iconSize: 17,
      lineHeight: 15,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 13,
      iconSize: 21,
      lineHeight: 19,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 23,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 19,
      iconSize: 29,
      lineHeight: 27,
      letterSpacing: 0
    }, {
      ascenderHeight: 8,
      descenderHeight: 8,
      fontSize: 22,
      iconSize: 33,
      lineHeight: 31,
      letterSpacing: 0
    }]
  },
  heading: {
    family: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 700,
      medium: 800,
      semibold: 900,
      bold: 900
    },
    sizes: [{
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 13,
      iconSize: 17,
      lineHeight: 19,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 23,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 21,
      iconSize: 33,
      lineHeight: 29,
      letterSpacing: 0
    }, {
      ascenderHeight: 8,
      descenderHeight: 8,
      fontSize: 27,
      iconSize: 41,
      lineHeight: 35,
      letterSpacing: 0
    }, {
      ascenderHeight: 9.5,
      descenderHeight: 8.5,
      fontSize: 33,
      iconSize: 49,
      lineHeight: 41,
      letterSpacing: 0
    }, {
      ascenderHeight: 10.5,
      descenderHeight: 9.5,
      fontSize: 38,
      iconSize: 53,
      lineHeight: 47,
      letterSpacing: 0
    }]
  },
  label: {
    family: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", system-ui, sans-serif',
    weights: {
      regular: 600,
      medium: 700,
      semibold: 800,
      bold: 900
    },
    sizes: [{
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 8.1,
      iconSize: 13,
      lineHeight: 10,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 9.5,
      iconSize: 15,
      lineHeight: 11,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 10.8,
      iconSize: 17,
      lineHeight: 12,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 12.25,
      iconSize: 19,
      lineHeight: 13,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 13.6,
      iconSize: 21,
      lineHeight: 14,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 15,
      iconSize: 23,
      lineHeight: 15,
      letterSpacing: 0.5
    }]
  },
  text: {
    family: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [{
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 10,
      iconSize: 17,
      lineHeight: 15,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 13,
      iconSize: 21,
      lineHeight: 19,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 15,
      iconSize: 25,
      lineHeight: 23,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 18,
      iconSize: 29,
      lineHeight: 27,
      letterSpacing: 0
    }, {
      ascenderHeight: 8,
      descenderHeight: 8,
      fontSize: 21,
      iconSize: 33,
      lineHeight: 31,
      letterSpacing: 0
    }]
  }
};
var cache$4 = /* @__PURE__ */ new WeakMap();
function themeColor_v0_v2(color_v0) {
  const cached_v2 = cache$4.get(color_v0);
  if (cached_v2) return cached_v2;
  const base = stateThemeColor_v0_v2(color_v0, color_v0.card.enabled), color_v2 = {
    _blend: color_v0._blend || (color_v0.dark ? "screen" : "multiply"),
    _dark: color_v0.dark,
    accent: base.accent,
    avatar: base.avatar,
    backdrop: color_v0.base.shadow.ambient,
    badge: base.badge,
    bg: color_v0.base.bg,
    border: color_v0.base.border,
    button: {
      default: stateTonesThemeColor_v0_v2(color_v0, color_v0.button.default),
      ghost: stateTonesThemeColor_v0_v2(color_v0, color_v0.button.ghost),
      bleed: stateTonesThemeColor_v0_v2(color_v0, color_v0.button.bleed)
    },
    code: base.code,
    fg: color_v0.base.fg,
    focusRing: color_v0.base.focusRing,
    icon: base.muted.fg,
    input: {
      default: inputStatesThemeColor_v0_v2(color_v0.input.default),
      invalid: inputStatesThemeColor_v0_v2(color_v0.input.invalid)
    },
    kbd: base.kbd,
    link: base.link,
    muted: {
      ...base.muted,
      bg: color_v0.selectable?.default.enabled.bg2 || color_v0.base.bg
    },
    selectable: stateTonesThemeColor_v0_v2(color_v0, color_v0.selectable || color_v0.muted),
    shadow: color_v0.base.shadow,
    skeleton: {
      from: color_v0.skeleton?.from || color_v0.base.border,
      to: color_v0.skeleton?.to || color_v0.base.border
    },
    syntax: color_v0.syntax
  };
  return cache$4.set(color_v0, color_v2), color_v2;
}
function stateTonesThemeColor_v0_v2(v0, t3) {
  return {
    default: {
      enabled: stateThemeColor_v0_v2(v0, t3.default.enabled),
      hovered: stateThemeColor_v0_v2(v0, t3.default.hovered),
      pressed: stateThemeColor_v0_v2(v0, t3.default.pressed),
      selected: stateThemeColor_v0_v2(v0, t3.default.selected),
      disabled: stateThemeColor_v0_v2(v0, t3.default.disabled)
    },
    neutral: {
      enabled: stateThemeColor_v0_v2(v0, t3.default.enabled),
      hovered: stateThemeColor_v0_v2(v0, t3.default.hovered),
      pressed: stateThemeColor_v0_v2(v0, t3.default.pressed),
      selected: stateThemeColor_v0_v2(v0, t3.default.selected),
      disabled: stateThemeColor_v0_v2(v0, t3.default.disabled)
    },
    primary: {
      enabled: stateThemeColor_v0_v2(v0, t3.primary.enabled),
      hovered: stateThemeColor_v0_v2(v0, t3.primary.hovered),
      pressed: stateThemeColor_v0_v2(v0, t3.primary.pressed),
      selected: stateThemeColor_v0_v2(v0, t3.primary.selected),
      disabled: stateThemeColor_v0_v2(v0, t3.primary.disabled)
    },
    suggest: {
      enabled: stateThemeColor_v0_v2(v0, t3.primary.enabled),
      hovered: stateThemeColor_v0_v2(v0, t3.primary.hovered),
      pressed: stateThemeColor_v0_v2(v0, t3.primary.pressed),
      selected: stateThemeColor_v0_v2(v0, t3.primary.selected),
      disabled: stateThemeColor_v0_v2(v0, t3.primary.disabled)
    },
    positive: {
      enabled: stateThemeColor_v0_v2(v0, t3.positive.enabled),
      hovered: stateThemeColor_v0_v2(v0, t3.positive.hovered),
      pressed: stateThemeColor_v0_v2(v0, t3.positive.pressed),
      selected: stateThemeColor_v0_v2(v0, t3.positive.selected),
      disabled: stateThemeColor_v0_v2(v0, t3.positive.disabled)
    },
    caution: {
      enabled: stateThemeColor_v0_v2(v0, t3.caution.enabled),
      hovered: stateThemeColor_v0_v2(v0, t3.caution.hovered),
      pressed: stateThemeColor_v0_v2(v0, t3.caution.pressed),
      selected: stateThemeColor_v0_v2(v0, t3.caution.selected),
      disabled: stateThemeColor_v0_v2(v0, t3.caution.disabled)
    },
    critical: {
      enabled: stateThemeColor_v0_v2(v0, t3.critical.enabled),
      hovered: stateThemeColor_v0_v2(v0, t3.critical.hovered),
      pressed: stateThemeColor_v0_v2(v0, t3.critical.pressed),
      selected: stateThemeColor_v0_v2(v0, t3.critical.selected),
      disabled: stateThemeColor_v0_v2(v0, t3.critical.disabled)
    }
  };
}
function stateThemeColor_v0_v2(v0, state) {
  return {
    ...state,
    avatar: {
      gray: {
        bg: v0.spot.gray,
        fg: v0.base.bg
      },
      blue: {
        bg: v0.spot.blue,
        fg: v0.base.bg
      },
      purple: {
        bg: v0.spot.purple,
        fg: v0.base.bg
      },
      magenta: {
        bg: v0.spot.magenta,
        fg: v0.base.bg
      },
      red: {
        bg: v0.spot.red,
        fg: v0.base.bg
      },
      orange: {
        bg: v0.spot.orange,
        fg: v0.base.bg
      },
      yellow: {
        bg: v0.spot.yellow,
        fg: v0.base.bg
      },
      green: {
        bg: v0.spot.green,
        fg: v0.base.bg
      },
      cyan: {
        bg: v0.spot.cyan,
        fg: v0.base.bg
      }
    },
    badge: {
      default: {
        bg: v0.muted.default.enabled.bg,
        fg: v0.muted.default.enabled.fg,
        dot: v0.muted.default.enabled.muted.fg,
        icon: v0.muted.default.enabled.muted.fg
      },
      neutral: {
        bg: v0.muted.transparent.enabled.bg,
        fg: v0.muted.transparent.enabled.fg,
        dot: v0.muted.transparent.enabled.muted.fg,
        icon: v0.muted.transparent.enabled.muted.fg
      },
      primary: {
        bg: v0.muted.primary.enabled.bg,
        fg: v0.muted.primary.enabled.fg,
        dot: v0.muted.primary.enabled.muted.fg,
        icon: v0.muted.primary.enabled.muted.fg
      },
      suggest: {
        bg: v0.muted.primary.enabled.bg,
        fg: v0.muted.primary.enabled.fg,
        dot: v0.muted.primary.enabled.muted.fg,
        icon: v0.muted.primary.enabled.muted.fg
      },
      positive: {
        bg: v0.muted.positive.enabled.bg,
        fg: v0.muted.positive.enabled.fg,
        dot: v0.muted.positive.enabled.muted.fg,
        icon: v0.muted.positive.enabled.muted.fg
      },
      caution: {
        bg: v0.muted.caution.enabled.bg,
        fg: v0.muted.caution.enabled.fg,
        dot: v0.muted.caution.enabled.muted.fg,
        icon: v0.muted.caution.enabled.muted.fg
      },
      critical: {
        bg: v0.muted.critical.enabled.bg,
        fg: v0.muted.critical.enabled.fg,
        dot: v0.muted.critical.enabled.muted.fg,
        icon: v0.muted.critical.enabled.muted.fg
      }
    },
    kbd: {
      bg: v0.muted.default.enabled.bg,
      fg: v0.muted.default.enabled.fg,
      border: v0.muted.default.enabled.border
    },
    muted: {
      ...v0.muted.default.enabled.muted,
      bg: state.bg2 || state.bg
    },
    skeleton: {
      from: state.skeleton?.from || state.border,
      to: state.skeleton?.to || state.border
    }
  };
}
function inputStatesThemeColor_v0_v2(states) {
  return {
    enabled: inputStateThemeColor_v0_v2(states.enabled),
    disabled: inputStateThemeColor_v0_v2(states.disabled),
    readOnly: inputStateThemeColor_v0_v2(states.readOnly),
    hovered: inputStateThemeColor_v0_v2(states.hovered)
  };
}
function inputStateThemeColor_v0_v2(state) {
  return {
    bg: state.bg,
    border: state.border,
    fg: state.fg,
    muted: {
      bg: state.bg2
    },
    placeholder: state.placeholder
  };
}
var cache$3 = /* @__PURE__ */ new WeakMap();
function getTheme_v2(theme) {
  if (theme.sanity.v2?._resolved) return theme.sanity.v2;
  const cached_v2 = cache$3.get(theme);
  if (cached_v2) return cached_v2;
  const v2 = {
    _version: 2,
    _resolved: true,
    avatar: {
      ...defaultThemeConfig.avatar,
      ...theme.sanity.avatar
    },
    button: {
      ...defaultThemeConfig.button,
      ...theme.sanity.button
    },
    card: defaultThemeConfig.card,
    color: themeColor_v0_v2(theme.sanity.color),
    container: theme.sanity.container,
    font: theme.sanity.fonts,
    input: {
      ...defaultThemeConfig.input,
      ...theme.sanity.input,
      checkbox: {
        ...defaultThemeConfig.input.checkbox,
        ...theme.sanity.input.checkbox
      },
      radio: {
        ...defaultThemeConfig.input.radio,
        ...theme.sanity.input.radio
      },
      switch: {
        ...defaultThemeConfig.input.switch,
        ...theme.sanity.input.switch
      }
    },
    layer: theme.sanity.layer ?? defaultThemeConfig.layer,
    media: theme.sanity.media,
    radius: theme.sanity.radius,
    shadow: theme.sanity.shadows,
    space: theme.sanity.space,
    style: theme.sanity.styles
  };
  return cache$3.set(theme, v2), v2;
}
function is_v2(themeProp) {
  return themeProp._version === 2;
}
var cache$2 = /* @__PURE__ */ new WeakMap();
function v0_v2(v0) {
  if (v0.v2) return v0.v2;
  const cached_v2 = cache$2.get(v0);
  if (cached_v2) return cached_v2;
  const {
    avatar,
    button,
    color: color2,
    container: container2,
    fonts: font,
    input,
    layer,
    media: media2,
    radius,
    shadows: shadow,
    space,
    styles: style
  } = v0, v2 = {
    _version: 2,
    avatar: {
      ...defaultThemeConfig.avatar,
      ...avatar
    },
    button: {
      ...defaultThemeConfig.button,
      ...button
    },
    card: defaultThemeConfig.card,
    color: {
      light: {
        transparent: themeColor_v0_v2(color2.light.transparent),
        default: themeColor_v0_v2(color2.light.default),
        neutral: themeColor_v0_v2(color2.light.transparent),
        primary: themeColor_v0_v2(color2.light.primary),
        suggest: themeColor_v0_v2(color2.light.primary),
        positive: themeColor_v0_v2(color2.light.positive),
        caution: themeColor_v0_v2(color2.light.caution),
        critical: themeColor_v0_v2(color2.light.critical)
      },
      dark: {
        transparent: themeColor_v0_v2(color2.dark.transparent),
        default: themeColor_v0_v2(color2.dark.default),
        neutral: themeColor_v0_v2(color2.dark.transparent),
        primary: themeColor_v0_v2(color2.dark.primary),
        suggest: themeColor_v0_v2(color2.dark.primary),
        positive: themeColor_v0_v2(color2.dark.positive),
        caution: themeColor_v0_v2(color2.dark.caution),
        critical: themeColor_v0_v2(color2.dark.critical)
      }
    },
    container: container2,
    font,
    input: {
      ...defaultThemeConfig.input,
      ...input,
      checkbox: {
        ...defaultThemeConfig.input.checkbox,
        ...input.checkbox
      },
      radio: {
        ...defaultThemeConfig.input.radio,
        ...input.radio
      },
      switch: {
        ...defaultThemeConfig.input.switch,
        ...input.switch
      }
    },
    layer: layer ?? defaultThemeConfig.layer,
    media: media2,
    radius,
    shadow,
    space,
    style
  };
  return cache$2.set(v0, v2), v2;
}
var cache$1 = /* @__PURE__ */ new WeakMap();
function v2_v0(v2) {
  const cachedTheme = cache$1.get(v2);
  if (cachedTheme) return cachedTheme;
  const {
    avatar,
    button,
    color: color2,
    container: container2,
    font: fonts,
    input,
    media: media2,
    radius,
    shadow: shadows,
    space,
    style: styles
  } = v2;
  return {
    _version: 0,
    avatar,
    button,
    container: container2,
    color: {
      light: {
        transparent: themeColor_v2_v0(color2.light.transparent),
        default: themeColor_v2_v0(color2.light.default),
        primary: themeColor_v2_v0(color2.light.primary),
        positive: themeColor_v2_v0(color2.light.positive),
        caution: themeColor_v2_v0(color2.light.caution),
        critical: themeColor_v2_v0(color2.light.critical)
      },
      dark: {
        transparent: themeColor_v2_v0(color2.dark.transparent),
        default: themeColor_v2_v0(color2.dark.default),
        primary: themeColor_v2_v0(color2.dark.primary),
        positive: themeColor_v2_v0(color2.dark.positive),
        caution: themeColor_v2_v0(color2.dark.caution),
        critical: themeColor_v2_v0(color2.dark.critical)
      }
    },
    focusRing: input.text.focusRing,
    fonts,
    input,
    media: media2,
    radius,
    shadows,
    space,
    styles,
    v2
  };
}
function themeColor_v2_v0(color_v2) {
  return {
    base: {
      bg: color_v2.bg,
      fg: color_v2.fg,
      border: color_v2.border,
      focusRing: color_v2.focusRing,
      shadow: color_v2.shadow
    },
    button: color_v2.button,
    card: color_v2.selectable.default,
    dark: color_v2._dark,
    input: {
      default: inputStatesThemeColor_v2_v0(color_v2.input.default),
      invalid: inputStatesThemeColor_v2_v0(color_v2.input.invalid)
    },
    muted: {
      ...color_v2.button.ghost,
      transparent: color_v2.button.ghost.default
    },
    solid: {
      ...color_v2.button.default,
      transparent: color_v2.button.default.default
    },
    selectable: color_v2.selectable,
    spot: {
      gray: color_v2.avatar.gray.bg,
      blue: color_v2.avatar.blue.bg,
      purple: color_v2.avatar.purple.bg,
      magenta: color_v2.avatar.magenta.bg,
      red: color_v2.avatar.red.bg,
      orange: color_v2.avatar.orange.bg,
      yellow: color_v2.avatar.yellow.bg,
      green: color_v2.avatar.green.bg,
      cyan: color_v2.avatar.cyan.bg
    },
    syntax: color_v2.syntax
  };
}
function inputStatesThemeColor_v2_v0(t3) {
  return {
    enabled: inputStateThemeColor_v2_v0(t3.enabled),
    disabled: inputStateThemeColor_v2_v0(t3.disabled),
    readOnly: inputStateThemeColor_v2_v0(t3.readOnly),
    hovered: inputStateThemeColor_v2_v0(t3.hovered)
  };
}
function inputStateThemeColor_v2_v0(t3) {
  return {
    bg: t3.bg,
    bg2: t3.muted.bg,
    border: t3.border,
    fg: t3.fg,
    placeholder: t3.placeholder
  };
}
var THEME_COLOR_BLEND_MODES = ["multiply", "screen"];
var THEME_COLOR_CARD_TONES = [
  "transparent",
  "default",
  "neutral",
  "primary",
  // deprecated
  "suggest",
  "positive",
  "caution",
  "critical"
];
var THEME_COLOR_STATE_TONES = [
  "default",
  "neutral",
  "primary",
  // deprecated
  "suggest",
  "positive",
  "caution",
  "critical"
];
var THEME_COLOR_STATES = ["enabled", "hovered", "pressed", "selected", "disabled"];
var THEME_COLOR_BUTTON_MODES = ["default", "ghost", "bleed"];
var THEME_COLOR_INPUT_MODES = ["default", "invalid"];
var THEME_COLOR_INPUT_STATES = ["enabled", "hovered", "readOnly", "disabled"];
var THEME_COLOR_AVATAR_COLORS = COLOR_HUES;
function isColorBlendModeValue(str) {
  return THEME_COLOR_BLEND_MODES.includes(str);
}
function isColorHueKey(str) {
  return COLOR_HUES.includes(str);
}
function isColorTintKey(str) {
  return COLOR_TINTS.includes(str);
}
var COLOR_CONFIG_STATE_KEYS = ["_hue", "bg", "fg", "border", "focusRing", "muted/fg", "accent/fg", "link/fg", "code/bg", "code/fg", "skeleton/from", "skeleton/to", "status/dot", "status/icon"];
var COLOR_CONFIG_CARD_KEYS = [...COLOR_CONFIG_STATE_KEYS, "_hue", "bg", "fg", "border", "focusRing", "shadow/outline", "shadow/umbra", "shadow/penumbra", "shadow/ambient"];
var COLOR_CONFIG_AVATAR_COLORS = ["*", ...THEME_COLOR_AVATAR_COLORS];
var COLOR_CONFIG_CARD_TONES = ["*", ...THEME_COLOR_CARD_TONES];
var COLOR_CONFIG_STATE_TONES = ["*", ...THEME_COLOR_STATE_TONES];
var COLOR_CONFIG_STATES = ["*", ...THEME_COLOR_STATES];
var COLOR_CONFIG_INPUT_MODES = ["*", ...THEME_COLOR_INPUT_MODES];
var COLOR_CONFIG_INPUT_STATES = ["*", ...THEME_COLOR_INPUT_STATES];
function isColorMixPercentValue(str) {
  return /^\d+%$/.test(str);
}
function parseTokenValue(str) {
  const segments = str.split("/");
  let nextSegment = segments.shift() || "";
  const [segment0, segment0mix] = nextSegment.split(" ");
  if (isColorTintKey(segment0)) {
    const tint = segment0, segment1 = segments.shift() || "";
    if (isColorMixPercentValue(segment0mix)) {
      const mix2 = Number(segment0mix.slice(0, -1)) / 100;
      return {
        type: "color",
        tint,
        mix: mix2
      };
    }
    if (isColorOpacityValue(segment1)) {
      const opacity = Number(segment1);
      return {
        type: "color",
        tint,
        opacity
      };
    }
    return {
      type: "color",
      tint
    };
  }
  if (isColorValue(segment0)) {
    const key2 = segment0, segment1 = segments.shift() || "";
    if (isColorMixPercentValue(segment0mix)) {
      const mix2 = Number(segment0mix.slice(0, -1)) / 100;
      return {
        type: "color",
        key: key2,
        mix: mix2
      };
    }
    if (isColorOpacityValue(segment1)) {
      const opacity = Number(segment1);
      return {
        type: "color",
        key: key2,
        opacity
      };
    }
    return {
      type: "color",
      key: key2
    };
  }
  if (isColorHueKey(segment0)) {
    const hue = segment0;
    nextSegment = segments.shift() || "";
    const [segment1, segment1mix] = nextSegment.split(" ");
    if (isColorTintKey(segment1)) {
      const tint = segment1, segment2 = segments.shift() || "";
      if (isColorMixPercentValue(segment1mix)) {
        const mix2 = Number(segment1mix.slice(0, -1)) / 100;
        return {
          type: "color",
          hue,
          tint,
          mix: mix2
        };
      }
      if (isColorOpacityValue(segment2)) {
        const opacity = Number(segment2);
        return {
          type: "color",
          hue,
          tint,
          opacity
        };
      }
      return {
        type: "color",
        hue,
        tint
      };
    }
    return {
      type: "hue",
      value: hue
    };
  }
  if (isColorBlendModeValue(segment0))
    return {
      type: "blendMode",
      value: segment0
    };
}
function isColorValue(str) {
  return str === "black" || str === "white";
}
function isColorOpacityValue(str) {
  return str === "0" || /^0\.[0-9]+$/.test(str) || str === "1";
}
function compileColorTokenValue(node2) {
  let key2 = "";
  return node2.key === "black" || node2.key === "white" ? key2 = node2.key : key2 = `${node2.hue}/${node2.tint}`, node2.mix !== void 0 ? `${key2} ${node2.mix * 100}%` : (node2.opacity !== void 0 && (key2 += `/${node2.opacity}`), key2);
}
var DEFAULT_COLOR_TOKEN_VALUE = ["500", "500"];
function resolveColorTokenValue(context, value = DEFAULT_COLOR_TOKEN_VALUE) {
  const {
    hue,
    scheme
  } = context, node2 = parseTokenValue(value[scheme === "light" ? 0 : 1]);
  if (!node2 || node2.type !== "color")
    throw new Error(`Invalid color token: ${value[0]}`);
  return compileColorTokenValue({
    ...node2,
    hue: node2.hue || hue
  });
}
var defaultColorTokens = {
  base: {
    "*": {
      _blend: ["multiply", "screen"],
      accent: {
        fg: ["purple/600", "purple/400"]
      },
      avatar: {
        "*": {
          _blend: ["screen", "multiply"],
          bg: ["500", "400"],
          fg: ["white", "black"]
        }
      },
      backdrop: ["gray/200/0.5", "black/0.5"],
      badge: {
        "*": {
          bg: ["100", "900"],
          fg: ["600", "400"],
          icon: ["500", "500"],
          dot: ["500", "500"]
        },
        positive: {
          bg: ["200 50%", "900"],
          fg: ["600", "500"]
        },
        caution: {
          bg: ["200 50%", "900"],
          fg: ["600", "500"]
        }
      },
      bg: ["50", "950"],
      border: ["200", "800"],
      code: {
        bg: ["50", "950"],
        fg: ["600", "400"]
      },
      fg: ["800", "200"],
      focusRing: ["blue/500", "blue/500"],
      icon: ["600", "400"],
      kbd: {
        bg: ["white", "black"],
        fg: ["600", "400"],
        border: ["200", "800"]
      },
      link: {
        fg: ["blue/600", "blue/300"]
      },
      muted: {
        bg: ["50", "950"],
        fg: ["700 75%", "300 75%"]
      },
      shadow: {
        outline: ["500/0.3", "500/0.4"],
        umbra: ["gray/500/0.1", "black/0.2"],
        penumbra: ["gray/500/0.07", "black/0.14"],
        ambient: ["gray/500/0.06", "black/0.12"]
      },
      skeleton: {
        from: ["100", "900"],
        to: ["100 50%", "900 50%"]
      }
    },
    transparent: {
      bg: ["50", "black"]
    },
    default: {
      bg: ["white", "950"],
      fg: ["800", "200"],
      muted: {
        fg: ["600", "400"]
      }
    },
    primary: {
      _hue: "blue"
    },
    suggest: {
      _hue: "purple"
    },
    positive: {
      _hue: "green",
      shadow: {
        outline: ["500/0.4", "500/0.4"]
      }
    },
    caution: {
      _hue: "yellow",
      shadow: {
        outline: ["600/0.3", "500/0.4"]
      }
    },
    critical: {
      _hue: "red"
    }
  },
  button: {
    default: {
      "*": {
        "*": {
          _blend: ["screen", "multiply"],
          accent: {
            fg: ["purple/300", "purple/700"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["900", "100"],
              fg: ["400", "600"],
              dot: ["500", "500"],
              icon: ["500", "500"]
            }
          },
          bg: ["500", "400"],
          border: ["500/0", "400/0"],
          code: {
            bg: ["500 20%", "400 20%"],
            fg: ["200", "600"]
          },
          fg: ["white", "black"],
          icon: ["100 70%", "900 70%"],
          kbd: {
            bg: ["black", "white"],
            fg: ["200", "600"],
            border: ["800", "200"]
          },
          link: {
            fg: ["blue/200", "blue/600"]
          },
          muted: {
            bg: ["950", "50"],
            fg: ["100 70%", "900 70%"]
          },
          skeleton: {
            from: ["900", "100"],
            to: ["900 50%", "100 50%"]
          }
        },
        hovered: {
          bg: ["600", "300"],
          border: ["700/0", "300/0"]
        },
        pressed: {
          bg: ["700", "300"]
        },
        selected: {
          bg: ["700", "300"]
        },
        disabled: {
          _hue: "gray",
          accent: {
            fg: ["100 70%", "900 70%"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["gray/500", "gray/400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["gray/700", "gray/300"],
              fg: ["white", "black"],
              dot: ["white", "black"],
              icon: ["white", "black"]
            }
          },
          bg: ["300", "600"],
          code: {
            bg: ["950", "50"],
            fg: ["300", "600"]
          },
          fg: ["300", "600"],
          muted: {
            bg: ["950", "50"],
            fg: ["300", "600"]
          },
          kbd: {
            bg: ["black", "white"],
            fg: ["white", "black"],
            border: ["700", "300"]
          },
          link: {
            fg: ["100 70%", "900 70%"]
          }
        }
      },
      default: {
        "*": {
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          bg: ["800", "200"],
          muted: {
            bg: ["950", "50"],
            fg: ["400", "600"]
          }
        },
        hovered: {
          bg: ["900", "100"]
        },
        pressed: {
          bg: ["black", "white"]
        },
        selected: {
          bg: ["black", "white"]
        }
      }
    },
    ghost: {
      "*": {
        "*": {
          _blend: ["multiply", "screen"],
          accent: {
            fg: ["purple/700 60%", "purple/300 70%"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["100", "900"],
              fg: ["600", "400"],
              dot: ["500", "500"],
              icon: ["500", "500"]
            }
          },
          bg: ["50", "950"],
          border: ["100", "900"],
          code: {
            bg: ["500 10%", "400 10%"],
            fg: ["700 60%", "400 60%"]
          },
          fg: ["600", "400"],
          icon: ["700 60%", "300 60%"],
          kbd: {
            bg: ["white", "black"],
            fg: ["600", "400"],
            border: ["200", "800"]
          },
          link: {
            fg: ["blue/700 60%", "blue/300 60%"]
          },
          muted: {
            bg: ["100", "950"],
            fg: ["700 60%", "300 60%"]
          },
          skeleton: {
            from: ["100", "900"],
            to: ["100 50%", "900 50%"]
          }
        },
        hovered: {
          bg: ["100", "900"],
          fg: ["700", "300"]
        },
        pressed: {
          bg: ["200", "800"],
          fg: ["800", "200"]
        },
        selected: {
          bg: ["200", "800"],
          fg: ["800", "200"]
        },
        disabled: {
          _hue: "gray",
          accent: {
            fg: ["200", "800"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["gray/100", "gray/900"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              _hue: "gray",
              bg: ["50", "950"],
              fg: ["gray/200", "gray/800"],
              dot: ["gray/200", "gray/800"],
              icon: ["gray/200", "gray/800"]
            }
          },
          border: ["100", "900"],
          code: {
            bg: ["50", "950"],
            fg: ["200", "800"]
          },
          fg: ["400", "600"],
          icon: ["300", "700"],
          muted: {
            fg: ["300", "700"]
          },
          kbd: {
            bg: ["white", "black"],
            fg: ["200", "800"],
            border: ["100", "900"]
          },
          link: {
            fg: ["200", "800"]
          }
        }
      },
      positive: {
        "*": {
          border: ["600 20%", "800"]
        }
      },
      caution: {
        "*": {
          border: ["600 20%", "800"]
        }
      }
    },
    bleed: {
      "*": {
        "*": {
          _blend: ["multiply", "screen"],
          accent: {
            fg: ["purple/700 70%", "purple/300 70%"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["100", "900"],
              fg: ["600", "400"],
              dot: ["500", "500"],
              icon: ["500", "500"]
            }
          },
          bg: ["white", "black"],
          border: ["white/0", "black/0"],
          code: {
            bg: ["50", "950"],
            fg: ["700 75%", "300 75%"]
          },
          fg: ["700", "300"],
          icon: ["700 75%", "300 75%"],
          kbd: {
            bg: ["white", "black"],
            fg: ["700", "300"],
            border: ["200", "800"]
          },
          link: {
            fg: ["blue/700 70%", "blue/300 70%"]
          },
          muted: {
            bg: ["100", "950"],
            fg: ["700 75%", "300 75%"]
          },
          skeleton: {
            from: ["100", "900"],
            to: ["100 50%", "900 50%"]
          }
        },
        hovered: {
          bg: ["50", "900"],
          fg: ["800", "200"],
          icon: ["800 70%", "300 70%"]
        },
        pressed: {
          bg: ["100", "800"],
          fg: ["800", "200"],
          icon: ["800 70%", "200 70%"]
        },
        selected: {
          bg: ["100", "900"],
          fg: ["800", "200"],
          icon: ["800 60%", "200 60%"]
        },
        disabled: {
          _hue: "gray",
          accent: {
            fg: ["200", "800"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["gray/100", "gray/900"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              _hue: "gray",
              bg: ["50", "950"],
              fg: ["gray/200", "gray/800"],
              dot: ["gray/200", "gray/800"],
              icon: ["gray/200", "gray/800"]
            }
          },
          code: {
            bg: ["50", "950"],
            fg: ["200", "800"]
          },
          fg: ["400", "600"],
          icon: ["300", "700"],
          muted: {
            fg: ["400", "600"]
          },
          kbd: {
            bg: ["white", "black"],
            fg: ["200", "800"],
            border: ["100", "900"]
          },
          link: {
            fg: ["200", "800"]
          }
        }
      }
    }
  },
  input: {
    "*": {
      "*": {
        _blend: ["multiply", "screen"],
        bg: ["white", "black"],
        border: ["200", "700"],
        fg: ["black", "200"],
        muted: {
          bg: ["50", "950"]
        },
        placeholder: ["400", "600"]
      },
      hovered: {
        border: ["300", "700"]
      },
      readOnly: {
        bg: ["50", "950"],
        border: ["200", "800"],
        fg: ["800", "200"]
      },
      disabled: {
        bg: ["50", "950"],
        fg: ["400", "600"],
        border: ["100", "900"],
        placeholder: ["200", "800 50%"]
      }
    },
    invalid: {
      "*": {
        _hue: "red",
        bg: ["100", "950"]
      }
    }
  },
  selectable: {
    "*": {
      "*": {
        _blend: ["multiply", "screen"],
        accent: {
          fg: ["purple/700 70%", "purple/300 70%"]
        },
        avatar: {
          "*": {
            _blend: ["screen", "multiply"],
            bg: ["500", "400"],
            fg: ["white", "black"]
          }
        },
        badge: {
          "*": {
            bg: ["100", "900"],
            fg: ["600", "400"],
            dot: ["500", "500"],
            icon: ["500", "500"]
          }
        },
        bg: ["white", "black"],
        border: ["200", "800"],
        code: {
          bg: ["50", "950"],
          fg: ["600", "400"]
        },
        fg: ["700", "300"],
        icon: ["700 75%", "300 75%"],
        kbd: {
          bg: ["white", "black"],
          fg: ["600", "400"],
          border: ["200", "800"]
        },
        link: {
          fg: ["blue/700 70%", "blue/300 70%"]
        },
        muted: {
          bg: ["50", "950"],
          fg: ["700 75%", "300 75%"]
        },
        skeleton: {
          from: ["100", "900"],
          to: ["100 50%", "900 50%"]
        }
      },
      hovered: {
        bg: ["50", "950"]
      },
      pressed: {
        bg: ["100", "900"]
      },
      selected: {
        _blend: ["screen", "multiply"],
        accent: {
          fg: ["purple/300", "purple/700"]
        },
        avatar: {
          "*": {
            _blend: ["multiply", "screen"],
            bg: ["white", "black"],
            fg: ["black", "white"]
          }
        },
        badge: {
          "*": {
            bg: ["900", "100"],
            fg: ["400", "600"],
            dot: ["500", "500"],
            icon: ["500", "500"]
          }
        },
        bg: ["500", "400"],
        border: ["500 20%", "400 20%"],
        code: {
          bg: ["500 20%", "400 20%"],
          fg: ["200", "600"]
        },
        fg: ["white", "black"],
        icon: ["100 70%", "900 70%"],
        kbd: {
          bg: ["black", "white"],
          fg: ["200", "600"],
          border: ["800", "200"]
        },
        link: {
          fg: ["blue/200", "blue/600"]
        },
        muted: {
          bg: ["500 10%", "400 10%"],
          fg: ["100 70%", "900 70%"]
        },
        skeleton: {
          from: ["900", "100"],
          to: ["900 50%", "100 50%"]
        }
      },
      disabled: {
        _hue: "gray",
        accent: {
          fg: ["200", "800"]
        },
        avatar: {
          "*": {
            _blend: ["screen", "multiply"],
            bg: ["gray/100", "gray/900"],
            fg: ["white", "black"]
          }
        },
        badge: {
          "*": {
            _hue: "gray",
            bg: ["50", "950"],
            fg: ["gray/200", "gray/800"],
            dot: ["gray/200", "gray/800"],
            icon: ["gray/200", "gray/800"]
          }
        },
        border: ["100", "900"],
        code: {
          bg: ["50", "950"],
          fg: ["200", "800"]
        },
        fg: ["200", "800"],
        icon: ["200", "800"],
        kbd: {
          bg: ["white", "black"],
          fg: ["200", "800"],
          border: ["100", "900"]
        },
        link: {
          fg: ["200", "800"]
        },
        muted: {
          bg: ["50 50%", "950 50%"],
          fg: ["200", "800"]
        }
      }
    },
    default: {
      selected: {
        _hue: "blue"
      }
    },
    critical: {
      disabled: {
        bg: ["50 50%", "950 50%"]
      }
    }
  },
  syntax: {
    atrule: ["purple/600", "purple/400"],
    attrName: ["green/600", "green/400"],
    attrValue: ["yellow/600", "yellow/400"],
    attribute: ["yellow/600", "yellow/400"],
    boolean: ["purple/600", "purple/400"],
    builtin: ["purple/600", "purple/400"],
    cdata: ["yellow/600", "yellow/400"],
    char: ["yellow/600", "yellow/400"],
    class: ["orange/600", "orange/400"],
    className: ["cyan/600", "cyan/400"],
    comment: ["gray/400", "gray/600"],
    constant: ["purple/600", "purple/400"],
    deleted: ["red/600", "red/400"],
    entity: ["red/600", "red/400"],
    function: ["green/600", "green/400"],
    hexcode: ["blue/600", "blue/400"],
    id: ["purple/600", "purple/400"],
    important: ["purple/600", "purple/400"],
    inserted: ["yellow/600", "yellow/400"],
    keyword: ["magenta/600", "magenta/400"],
    number: ["purple/600", "purple/400"],
    operator: ["magenta/600", "magenta/400"],
    property: ["blue/600", "blue/400"],
    pseudoClass: ["yellow/600", "yellow/400"],
    pseudoElement: ["yellow/600", "yellow/400"],
    punctuation: ["gray/600", "gray/400"],
    regex: ["blue/600", "blue/400"],
    selector: ["red/600", "red/400"],
    string: ["yellow/600", "yellow/400"],
    symbol: ["purple/600", "purple/400"],
    tag: ["red/600", "red/400"],
    unit: ["orange/600", "orange/400"],
    url: ["red/600", "red/400"],
    variable: ["red/600", "red/400"]
  }
};
function isRecord(value) {
  return !!(value && typeof value == "object" && !Array.isArray(value));
}
function merge2(...records) {
  const _records = records.filter(Boolean);
  return _records.length === 0 ? {} : _records.reduce(_merge, {});
}
function _merge(acc, source) {
  for (const key2 of Object.keys(source)) {
    const prevValue = acc[key2], nextValue = source[key2];
    isRecord(prevValue) && isRecord(nextValue) ? acc[key2] = merge2(prevValue, nextValue) : acc[key2] = nextValue;
  }
  return acc;
}
function resolveColorTokens(inputTokens) {
  const tokens = merge2(defaultColorTokens, inputTokens);
  return {
    base: resolveBaseColorTokens(tokens),
    button: resolveButtonColorTokens(tokens),
    input: resolveInputColorTokens(tokens),
    selectable: resolveSelectableColorTokens(tokens),
    syntax: tokens.syntax
  };
}
function resolveBaseColorTokens(sparseTokens) {
  const tokens = {};
  for (const tone of THEME_COLOR_CARD_TONES)
    tokens[tone] = resolveBaseColorTones(sparseTokens, tone);
  return tokens;
}
function resolveBaseColorTones(inputTokens, tone) {
  const spec = merge2(inputTokens?.base?.["*"], inputTokens?.base?.[tone]), hue = spec._hue || inputTokens?.base?.[tone]?._hue || "gray";
  return {
    ...spec,
    _hue: hue,
    avatar: COLOR_HUES.reduce((acc, hue2) => ({
      ...acc,
      [hue2]: merge2({
        _hue: hue2
      }, spec.avatar?.["*"], spec.avatar?.[hue2])
    }), {}),
    badge: THEME_COLOR_STATE_TONES.reduce((acc, tone2) => ({
      ...acc,
      [tone2]: {
        _hue: inputTokens?.base?.[tone2]?._hue || hue,
        ...spec.badge?.["*"],
        ...spec.badge?.[tone2]
      }
    }), {})
  };
}
function resolveButtonColorTokens(inputTokens) {
  const tokens = {};
  for (const mode of THEME_COLOR_BUTTON_MODES)
    tokens[mode] = resolveButtonToneColorTokens(inputTokens, mode);
  return tokens;
}
function resolveButtonToneColorTokens(inputTokens, mode) {
  const tokens = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tokens[tone] = resolveButtonModeColorTokens(inputTokens, mode, tone);
  return tokens;
}
function resolveButtonModeColorTokens(inputTokens, mode, tone) {
  const tokens = {};
  for (const state of THEME_COLOR_STATES)
    tokens[state] = resolveButtonStateColorTokens(inputTokens, tone, mode, state);
  return tokens;
}
function resolveButtonStateColorTokens(inputTokens, tone, mode, state) {
  const spec = merge2(inputTokens?.button?.[mode]?.["*"]?.["*"], inputTokens?.button?.[mode]?.[tone]?.["*"], inputTokens?.button?.[mode]?.["*"]?.[state], inputTokens?.button?.[mode]?.[tone]?.[state]), hue = spec._hue || inputTokens?.base?.[tone]?._hue;
  return {
    ...spec,
    _hue: hue,
    avatar: COLOR_HUES.reduce((acc, hue2) => ({
      ...acc,
      [hue2]: merge2({
        _hue: hue2
      }, spec.avatar?.["*"], spec.avatar?.[hue2])
    }), {}),
    badge: THEME_COLOR_STATE_TONES.reduce((acc, tone2) => ({
      ...acc,
      [tone2]: {
        _hue: inputTokens?.base?.[tone2]?._hue || hue,
        ...spec.badge?.["*"],
        ...spec.badge?.[tone2]
      }
    }), {})
  };
}
function resolveInputColorTokens(inputTokens) {
  const tokens = {};
  for (const mode of THEME_COLOR_INPUT_MODES)
    tokens[mode] = resolveInputModeColorTokens(inputTokens, mode);
  return tokens;
}
function resolveInputModeColorTokens(inputTokens, mode) {
  const states = {};
  for (const state of THEME_COLOR_INPUT_STATES)
    states[state] = resolveInputStateColorTokens(inputTokens, mode, state);
  return states;
}
function resolveInputStateColorTokens(inputTokens, mode, state) {
  const spec = merge2(inputTokens?.input?.["*"]?.["*"], inputTokens?.input?.[mode]?.["*"], inputTokens?.input?.["*"]?.[state], inputTokens?.input?.[mode]?.[state]), hue = spec._hue || inputTokens?.input?.[mode]?._hue;
  return {
    ...spec,
    _hue: hue
  };
}
function resolveSelectableColorTokens(inputTokens) {
  const tokens = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tokens[tone] = resolveSelectableToneColorTokens(inputTokens, tone);
  return tokens;
}
function resolveSelectableToneColorTokens(inputTokens, tone) {
  const states = {
    _hue: inputTokens?.selectable?.[tone]?._hue || inputTokens?.base?.[tone]?._hue
  };
  for (const state of THEME_COLOR_STATES)
    states[state] = resolveSelectableStateColorTokens(inputTokens, tone, state);
  return states;
}
function resolveSelectableStateColorTokens(inputTokens, tone, state) {
  const spec = merge2(inputTokens?.selectable?.["*"]?.["*"], inputTokens?.selectable?.[tone]?.["*"], inputTokens?.selectable?.["*"]?.[state], inputTokens?.selectable?.[tone]?.[state]), hue = spec._hue || inputTokens?.base?.[tone]?._hue;
  return {
    ...spec,
    _hue: hue,
    avatar: COLOR_HUES.reduce((acc, hue2) => ({
      ...acc,
      [hue2]: merge2({
        _hue: hue2
      }, spec.avatar?.["*"], spec.avatar?.[hue2])
    }), {}),
    badge: THEME_COLOR_STATE_TONES.reduce((acc, tone2) => ({
      ...acc,
      [tone2]: {
        _hue: inputTokens?.base?.[tone2]?._hue || hue,
        ...spec.badge?.["*"],
        ...spec.badge?.[tone2]
      }
    }), {})
  };
}
function buildColorTheme(config) {
  const resolvedConfig = {
    color: resolveColorTokens(config?.color)
  };
  return {
    light: buildColorScheme({
      scheme: "light"
    }, resolvedConfig),
    dark: buildColorScheme({
      scheme: "dark"
    }, resolvedConfig)
  };
}
function buildColorScheme(options2, config) {
  const {
    scheme
  } = options2, colorScheme = {};
  for (const tone of THEME_COLOR_CARD_TONES)
    colorScheme[tone] = buildCardColorTheme({
      scheme,
      tone
    }, config);
  return colorScheme;
}
function buildCardColorTheme(options2, config) {
  const {
    scheme,
    tone
  } = options2, tokens = config?.color?.base?.[tone], context = {
    hue: tokens?._hue || "gray",
    scheme
  };
  return {
    _blend: (tokens?._blend || ["multiply", "screen"])[scheme === "light" ? 0 : 1],
    _dark: scheme === "dark",
    accent: {
      fg: resolveColorTokenValue(context, tokens?.accent?.fg)
    },
    avatar: buildAvatarColorTheme({
      scheme
    }, tokens),
    backdrop: resolveColorTokenValue(context, tokens?.backdrop),
    badge: buildBadgeColorTheme(tokens?.badge, {
      scheme
    }, config),
    bg: resolveColorTokenValue(context, tokens?.bg),
    border: resolveColorTokenValue(context, tokens?.border),
    button: buildButtonColorTheme({
      scheme,
      tone
    }, config),
    code: {
      bg: resolveColorTokenValue(context, tokens?.code?.bg),
      fg: resolveColorTokenValue(context, tokens?.code?.fg)
    },
    fg: resolveColorTokenValue(context, tokens?.fg),
    focusRing: resolveColorTokenValue(context, tokens?.focusRing),
    icon: resolveColorTokenValue(context, tokens?.icon),
    input: buildInputColorTheme({
      scheme,
      tone
    }, config),
    kbd: {
      bg: resolveColorTokenValue(context, tokens?.kbd?.bg),
      fg: resolveColorTokenValue(context, tokens?.kbd?.fg),
      border: resolveColorTokenValue(context, tokens?.kbd?.border)
    },
    link: {
      fg: resolveColorTokenValue(context, tokens?.link?.fg)
    },
    muted: {
      bg: resolveColorTokenValue(context, tokens?.muted?.bg),
      fg: resolveColorTokenValue(context, tokens?.muted?.fg)
    },
    selectable: buildSelectableColorTheme({
      scheme,
      tone
    }, config),
    shadow: buildShadowColorTheme({
      scheme,
      tone
    }, config),
    skeleton: {
      from: resolveColorTokenValue(context, tokens?.skeleton?.from),
      to: resolveColorTokenValue(context, tokens?.skeleton?.to)
    },
    syntax: buildSyntaxColorTheme({
      scheme
    }, config)
  };
}
function buildShadowColorTheme(options2, config) {
  const {
    scheme,
    tone
  } = options2, tokens = config?.color?.base?.[tone], context = {
    hue: tokens?._hue || "gray",
    scheme
  };
  return {
    outline: resolveColorTokenValue(context, tokens?.shadow?.outline),
    umbra: resolveColorTokenValue(context, tokens?.shadow?.umbra),
    penumbra: resolveColorTokenValue(context, tokens?.shadow?.penumbra),
    ambient: resolveColorTokenValue(context, tokens?.shadow?.ambient)
  };
}
function buildAvatarColorTheme(options2, stateTokens) {
  const {
    scheme
  } = options2;
  return {
    gray: _buildAvatarColorTheme({
      color: "gray",
      scheme
    }, stateTokens),
    blue: _buildAvatarColorTheme({
      color: "blue",
      scheme
    }, stateTokens),
    purple: _buildAvatarColorTheme({
      color: "purple",
      scheme
    }, stateTokens),
    magenta: _buildAvatarColorTheme({
      color: "magenta",
      scheme
    }, stateTokens),
    red: _buildAvatarColorTheme({
      color: "red",
      scheme
    }, stateTokens),
    orange: _buildAvatarColorTheme({
      color: "orange",
      scheme
    }, stateTokens),
    yellow: _buildAvatarColorTheme({
      color: "yellow",
      scheme
    }, stateTokens),
    green: _buildAvatarColorTheme({
      color: "green",
      scheme
    }, stateTokens),
    cyan: _buildAvatarColorTheme({
      color: "cyan",
      scheme
    }, stateTokens)
  };
}
function _buildAvatarColorTheme(options2, stateTokens) {
  const {
    color: color2,
    scheme
  } = options2, tokens = stateTokens?.avatar?.[color2], context = {
    hue: tokens?._hue || "gray",
    scheme
  };
  return {
    _blend: (tokens?._blend || ["screen", "multiply"])[scheme === "light" ? 0 : 1],
    bg: resolveColorTokenValue(context, tokens?.bg),
    fg: resolveColorTokenValue(context, tokens?.fg)
  };
}
function buildBadgeColorTheme(tokens, options2, config) {
  const {
    scheme
  } = options2, colorBadge = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    colorBadge[tone] = _buildBadgeColorTheme(tokens, {
      scheme,
      tone
    }, config);
  return colorBadge;
}
function _buildBadgeColorTheme(parentTokens, options2, config) {
  const {
    scheme,
    tone
  } = options2, tokens = parentTokens?.[tone], context = {
    hue: tokens?._hue || config?.color?.base?.[tone]?._hue || "gray",
    scheme
  };
  return {
    bg: resolveColorTokenValue(context, tokens?.bg),
    fg: resolveColorTokenValue(context, tokens?.fg),
    dot: resolveColorTokenValue(context, tokens?.dot),
    icon: resolveColorTokenValue(context, tokens?.icon)
  };
}
function buildButtonColorTheme(options2, config) {
  const {
    scheme,
    tone: cardTone
  } = options2, modes = {};
  for (const mode of THEME_COLOR_BUTTON_MODES)
    modes[mode] = buildButtonTonesColorTheme({
      cardTone,
      scheme,
      mode
    }, config);
  return modes;
}
function buildButtonTonesColorTheme(options2, config) {
  const {
    cardTone,
    mode,
    scheme
  } = options2, tones2 = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tones2[tone] = buildButtonStatesColorTheme({
      cardTone,
      mode,
      scheme,
      tone
    }, config);
  return tones2;
}
function buildButtonStatesColorTheme(options2, config) {
  const {
    cardTone,
    mode,
    scheme,
    tone
  } = options2, states = {};
  for (const state of THEME_COLOR_STATES)
    states[state] = buildButtonStateColorTheme({
      cardTone,
      mode,
      tone,
      scheme,
      state
    }, config);
  return states;
}
function buildButtonStateColorTheme(options2, config) {
  const {
    cardTone,
    mode,
    tone,
    scheme,
    state
  } = options2, cardTokens = config?.color?.base?.[cardTone], tokens = config?.color?.button?.[mode]?.[tone]?.[state], hue = tokens?._hue || cardTokens?._hue || "gray", blendMode = tokens?._blend || ["screen", "multiply"], context = {
    hue,
    scheme
  };
  return {
    _blend: blendMode[scheme === "light" ? 0 : 1],
    accent: {
      fg: resolveColorTokenValue(context, tokens?.accent?.fg)
    },
    avatar: buildAvatarColorTheme({
      scheme
    }, tokens),
    badge: buildBadgeColorTheme(tokens?.badge, {
      scheme
    }, config),
    bg: resolveColorTokenValue(context, tokens?.bg),
    border: resolveColorTokenValue(context, tokens?.border),
    code: {
      bg: resolveColorTokenValue(context, tokens?.code?.bg),
      fg: resolveColorTokenValue(context, tokens?.code?.fg)
    },
    fg: resolveColorTokenValue(context, tokens?.fg),
    icon: resolveColorTokenValue(context, tokens?.icon),
    muted: {
      bg: resolveColorTokenValue(context, tokens?.muted?.bg),
      fg: resolveColorTokenValue(context, tokens?.muted?.fg)
    },
    kbd: {
      bg: resolveColorTokenValue(context, tokens?.kbd?.bg),
      fg: resolveColorTokenValue(context, tokens?.kbd?.fg),
      border: resolveColorTokenValue(context, tokens?.kbd?.border)
    },
    link: {
      fg: resolveColorTokenValue(context, tokens?.link?.fg)
    },
    skeleton: {
      from: resolveColorTokenValue(context, tokens?.skeleton?.from),
      to: resolveColorTokenValue(context, tokens?.skeleton?.to)
    }
  };
}
function buildInputColorTheme(options2, config) {
  const {
    scheme,
    tone
  } = options2;
  return {
    default: buildInputStatesColorTheme({
      mode: "default",
      scheme,
      tone
    }, config),
    invalid: buildInputStatesColorTheme({
      mode: "invalid",
      scheme,
      tone
    }, config)
  };
}
function buildInputStatesColorTheme(options2, config) {
  const {
    mode,
    scheme,
    tone
  } = options2;
  return {
    enabled: buildInputStateColorTheme({
      mode,
      scheme,
      state: "enabled",
      cardTone: tone
    }, config),
    hovered: buildInputStateColorTheme({
      mode,
      scheme,
      state: "hovered",
      cardTone: tone
    }, config),
    readOnly: buildInputStateColorTheme({
      mode,
      scheme,
      state: "readOnly",
      cardTone: tone
    }, config),
    disabled: buildInputStateColorTheme({
      mode,
      scheme,
      state: "disabled",
      cardTone: tone
    }, config)
  };
}
function buildInputStateColorTheme(options2, config) {
  const {
    cardTone,
    mode,
    scheme,
    state
  } = options2, cardTokens = config?.color?.base?.[cardTone], tokens = config?.color?.input?.[mode]?.[state], hue = tokens?._hue || cardTokens?._hue || "gray", blendMode = tokens?._blend || ["screen", "multiply"], context = {
    hue,
    scheme
  };
  return {
    _blend: blendMode[scheme === "light" ? 0 : 1],
    bg: resolveColorTokenValue(context, tokens?.bg),
    border: resolveColorTokenValue(context, tokens?.border),
    fg: resolveColorTokenValue(context, tokens?.fg),
    muted: {
      bg: resolveColorTokenValue(context, tokens?.muted?.bg)
    },
    placeholder: resolveColorTokenValue(context, tokens?.placeholder)
  };
}
function buildSelectableColorTheme(options2, config) {
  const {
    scheme,
    tone: cardTone
  } = options2, tones2 = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tones2[tone] = buildSelectableStatesColorTheme({
      cardTone,
      scheme,
      tone
    }, config);
  return tones2;
}
function buildSelectableStatesColorTheme(options2, config) {
  const {
    cardTone,
    scheme,
    tone
  } = options2, states = {};
  for (const state of THEME_COLOR_STATES)
    states[state] = buildSelectableStateColorTheme({
      cardTone,
      tone,
      scheme,
      state
    }, config);
  return states;
}
function buildSelectableStateColorTheme(options2, config) {
  const {
    cardTone,
    scheme,
    state,
    tone
  } = options2, cardTokens = config?.color?.base?.[cardTone], tokens = config?.color?.selectable?.[tone]?.[state], hue = tokens?._hue || cardTokens?._hue || "gray", blendMode = tokens?._blend || ["screen", "multiply"], context = {
    hue,
    scheme
  };
  return {
    _blend: blendMode[scheme === "light" ? 0 : 1],
    accent: {
      fg: resolveColorTokenValue(context, tokens?.accent?.fg)
    },
    avatar: buildAvatarColorTheme({
      scheme
    }, tokens),
    badge: buildBadgeColorTheme(tokens?.badge, {
      scheme
    }, config),
    bg: resolveColorTokenValue(context, tokens?.bg),
    border: resolveColorTokenValue(context, tokens?.border),
    code: {
      bg: resolveColorTokenValue(context, tokens?.code?.bg),
      fg: resolveColorTokenValue(context, tokens?.code?.fg)
    },
    fg: resolveColorTokenValue(context, tokens?.fg),
    icon: resolveColorTokenValue(context, tokens?.icon),
    muted: {
      bg: resolveColorTokenValue(context, tokens?.muted?.bg),
      fg: resolveColorTokenValue(context, tokens?.muted?.fg)
    },
    kbd: {
      bg: resolveColorTokenValue(context, tokens?.kbd?.bg),
      fg: resolveColorTokenValue(context, tokens?.kbd?.fg),
      border: resolveColorTokenValue(context, tokens?.kbd?.border)
    },
    link: {
      fg: resolveColorTokenValue(context, tokens?.link?.fg)
    },
    skeleton: {
      from: resolveColorTokenValue(context, tokens?.skeleton?.from),
      to: resolveColorTokenValue(context, tokens?.skeleton?.to)
    }
  };
}
function buildSyntaxColorTheme(options2, config) {
  const {
    scheme
  } = options2, tokens = config?.color?.syntax, context = {
    hue: "gray",
    scheme
  };
  return {
    atrule: resolveColorTokenValue(context, tokens?.atrule),
    attrName: resolveColorTokenValue(context, tokens?.attrName),
    attrValue: resolveColorTokenValue(context, tokens?.attrValue),
    attribute: resolveColorTokenValue(context, tokens?.attribute),
    boolean: resolveColorTokenValue(context, tokens?.boolean),
    builtin: resolveColorTokenValue(context, tokens?.builtin),
    cdata: resolveColorTokenValue(context, tokens?.cdata),
    char: resolveColorTokenValue(context, tokens?.char),
    class: resolveColorTokenValue(context, tokens?.class),
    className: resolveColorTokenValue(context, tokens?.className),
    comment: resolveColorTokenValue(context, tokens?.comment),
    constant: resolveColorTokenValue(context, tokens?.constant),
    deleted: resolveColorTokenValue(context, tokens?.deleted),
    doctype: resolveColorTokenValue(context, tokens?.doctype),
    entity: resolveColorTokenValue(context, tokens?.entity),
    function: resolveColorTokenValue(context, tokens?.function),
    hexcode: resolveColorTokenValue(context, tokens?.hexcode),
    id: resolveColorTokenValue(context, tokens?.id),
    important: resolveColorTokenValue(context, tokens?.important),
    inserted: resolveColorTokenValue(context, tokens?.inserted),
    keyword: resolveColorTokenValue(context, tokens?.keyword),
    number: resolveColorTokenValue(context, tokens?.number),
    operator: resolveColorTokenValue(context, tokens?.operator),
    prolog: resolveColorTokenValue(context, tokens?.prolog),
    property: resolveColorTokenValue(context, tokens?.property),
    pseudoClass: resolveColorTokenValue(context, tokens?.pseudoClass),
    pseudoElement: resolveColorTokenValue(context, tokens?.pseudoElement),
    punctuation: resolveColorTokenValue(context, tokens?.punctuation),
    regex: resolveColorTokenValue(context, tokens?.regex),
    selector: resolveColorTokenValue(context, tokens?.selector),
    string: resolveColorTokenValue(context, tokens?.string),
    symbol: resolveColorTokenValue(context, tokens?.symbol),
    tag: resolveColorTokenValue(context, tokens?.tag),
    unit: resolveColorTokenValue(context, tokens?.unit),
    url: resolveColorTokenValue(context, tokens?.url),
    variable: resolveColorTokenValue(context, tokens?.variable)
  };
}
var defaultColorPalette = color;
function mixChannel(b2, s3, weight) {
  const delta = (s3 - b2) * weight;
  return b2 + delta;
}
function mix(b2, s3, weight) {
  return {
    r: mixChannel(b2.r, s3.r, weight),
    g: mixChannel(b2.g, s3.g, weight),
    b: mixChannel(b2.b, s3.b, weight)
  };
}
function multiplyChannel(b2, s3) {
  return b2 * s3;
}
function multiply(b2, s3) {
  return {
    r: multiplyChannel(b2.r / 255, s3.r / 255) * 255,
    g: multiplyChannel(b2.g / 255, s3.g / 255) * 255,
    b: multiplyChannel(b2.b / 255, s3.b / 255) * 255
  };
}
function screenChannel(b2, s3) {
  return b2 + s3 - b2 * s3;
}
function screen(b2, s3) {
  return {
    r: screenChannel(b2.r / 255, s3.r / 255) * 255,
    g: screenChannel(b2.g / 255, s3.g / 255) * 255,
    b: screenChannel(b2.b / 255, s3.b / 255) * 255
  };
}
function lerp(x3, y2, a2) {
  return x3 * (1 - a2) + y2 * a2;
}
function invlerp(x3, y2, a2) {
  return clamp((a2 - x3) / (y2 - x3));
}
function clamp(a2, min = 0, max = 1) {
  return Math.min(max, Math.max(min, a2));
}
function range(x1, y1, x22, y2, a2) {
  return lerp(x22, y2, invlerp(x1, y1, a2));
}
function round(value) {
  return Math.round(value);
}
function hexToRgb(hex) {
  if (hex.length === 4) {
    const hexR = hex.slice(1, 2), hexG = hex.slice(2, 3), hexB = hex.slice(3, 4);
    return {
      r: parseInt(hexR + hexR, 16),
      g: parseInt(hexG + hexG, 16),
      b: parseInt(hexB + hexB, 16)
    };
  }
  return {
    r: parseInt(hex.slice(1, 3), 16),
    g: parseInt(hex.slice(3, 5), 16),
    b: parseInt(hex.slice(5, 7), 16)
  };
}
function rgbaToRGBA(rgba22) {
  const values = rgba22.replace(/rgba\(|\)/g, "").split(",");
  return {
    r: parseInt(values[0]),
    g: parseInt(values[1]),
    b: parseInt(values[2]),
    a: parseFloat(values[3])
  };
}
function rgbToHex(color2) {
  const r3 = round(clamp(Math.round(color2.r), 0, 255)), g2 = round(clamp(Math.round(color2.g), 0, 255)), b2 = round(clamp(Math.round(color2.b), 0, 255));
  return "a" in color2 ? `rgba(${r3},${g2},${b2},${color2.a})` : "#" + ((1 << 24) + (r3 << 16) + (g2 << 8) + b2).toString(16).slice(1);
}
function hslToRgb(hsl) {
  const s3 = hsl.s / 100, l2 = hsl.l / 100, c4 = (1 - Math.abs(2 * l2 - 1)) * s3, x3 = c4 * (1 - Math.abs(hsl.h / 60 % 2 - 1)), m2 = l2 - c4 / 2;
  let r3 = 0, g2 = 0, b2 = 0;
  return 0 <= hsl.h && hsl.h < 60 ? (r3 = c4, g2 = x3, b2 = 0) : 60 <= hsl.h && hsl.h < 120 ? (r3 = x3, g2 = c4, b2 = 0) : 120 <= hsl.h && hsl.h < 180 ? (r3 = 0, g2 = c4, b2 = x3) : 180 <= hsl.h && hsl.h < 240 ? (r3 = 0, g2 = x3, b2 = c4) : 240 <= hsl.h && hsl.h < 300 ? (r3 = x3, g2 = 0, b2 = c4) : 300 <= hsl.h && hsl.h < 360 && (r3 = c4, g2 = 0, b2 = x3), {
    r: Math.round((r3 + m2) * 255),
    g: Math.round((g2 + m2) * 255),
    b: Math.round((b2 + m2) * 255)
  };
}
var HEX_CHARS = "0123456789ABCDEFabcdef";
var HSL_RE = /hsl\(\s*(\d+)\s*,\s*((\d+(?:\.\d+)?)%)\s*,\s*((\d+(?:\.\d+)?)%)\s*\)/i;
function isHexChars(str) {
  for (const c4 of str)
    if (HEX_CHARS.indexOf(c4) === -1)
      return false;
  return true;
}
function isHex(str) {
  return str[0] !== "#" || !(str.length === 4 || str.length === 7) ? false : isHexChars(str.slice(1));
}
function parseHsl(str) {
  const res = HSL_RE.exec(str);
  if (!res)
    throw new Error(`parseHsl: string is not a HSL color: "${str}"`);
  return {
    h: parseInt(res[1]),
    s: parseFloat(res[3]),
    l: parseFloat(res[5])
  };
}
function parseColor(color2) {
  if (!color2) return {
    r: 0,
    g: 0,
    b: 0
  };
  if (typeof color2 != "string")
    throw new Error("parseColor: expected a string");
  if (isHex(color2))
    return hexToRgb(color2);
  if (color2.startsWith("hsl("))
    return hslToRgb(parseHsl(color2));
  if (color2.startsWith("rgba("))
    return rgbaToRGBA(color2);
  throw new Error(`parseColor: unexpected color format: "${color2}"`);
}
function rgba(color2, a2) {
  const rgb = parseColor(color2);
  return `rgba(${rgb.r},${rgb.g},${rgb.b},${a2})`;
}
var RGB_RANGE = [0, 255];
function mixThemeColor(value, options2) {
  const {
    blendMode
  } = options2, color2 = parseColor(value), black2 = parseColor(options2.black), white2 = parseColor(options2.white), bg = options2.bg ? parseColor(options2.bg) : blendMode === "multiply" ? white2 : black2, paletteRange = {
    r: [black2.r, white2.r],
    g: [black2.g, white2.g],
    b: [black2.b, white2.b]
  }, convertedBgColor = {
    r: clamp(range(...paletteRange.r, ...RGB_RANGE, bg.r), ...RGB_RANGE),
    g: clamp(range(...paletteRange.g, ...RGB_RANGE, bg.g), ...RGB_RANGE),
    b: clamp(range(...paletteRange.b, ...RGB_RANGE, bg.b), ...RGB_RANGE)
  }, convertedColor = {
    r: clamp(range(...paletteRange.r, ...RGB_RANGE, color2.r), ...RGB_RANGE),
    g: clamp(range(...paletteRange.g, ...RGB_RANGE, color2.g), ...RGB_RANGE),
    b: clamp(range(...paletteRange.b, ...RGB_RANGE, color2.b), ...RGB_RANGE)
  }, resultColor = blendMode === "multiply" ? multiply(convertedBgColor, convertedColor) : screen(convertedBgColor, convertedColor), v2 = {
    r: clamp(range(...RGB_RANGE, ...paletteRange.r, resultColor.r), ...paletteRange.r),
    g: clamp(range(...RGB_RANGE, ...paletteRange.g, resultColor.g), ...paletteRange.g),
    b: clamp(range(...RGB_RANGE, ...paletteRange.b, resultColor.b), ...paletteRange.b)
  };
  return rgbToHex(v2);
}
function renderColorValue(str, options2) {
  const {
    bg,
    blendMode,
    colorPalette
  } = options2;
  if (bg === "white")
    throw new Error("Cannot blend with white background");
  const node2 = parseTokenValue(str);
  if (!node2 || node2.type !== "color")
    throw new Error(`Invalid color token value: ${str}`);
  let hex = "";
  if (node2.key === "black" && (hex = renderColorHex(colorPalette.black)), node2.key === "white" && (hex = renderColorHex(colorPalette.white)), node2.hue && node2.tint && (hex = renderColorHex(colorPalette[node2.hue][node2.tint])), !hex)
    throw new Error(`Invalid color token value: ${str}`);
  const hexBeforeMix = hex, mixOptions = {
    blendMode,
    bg,
    black: renderColorHex(colorPalette.black),
    // opacity: node.opacity,
    white: renderColorHex(colorPalette.white)
  };
  try {
    if (hex = mixThemeColor(hex, mixOptions), bg && node2.mix !== void 0) {
      const from3 = hexToRgb(bg), to2 = hexToRgb(hex);
      hex = rgbToHex(mix(from3, to2, node2.mix));
    }
  } catch (err) {
    throw console.warn("could not blend", hex, mixOptions), err;
  }
  return hex === "#aN" && (console.warn(`invalid color token value: ${str}`), hex = hexBeforeMix), node2.opacity !== void 0 && (hex = rgba(hex, node2.opacity)), hex;
}
function renderColorHex(color2) {
  return typeof color2 == "string" ? color2 : color2.hex;
}
function renderThemeColorSchemes(value, config) {
  const colorPalette = config?.palette ?? defaultColorPalette;
  return {
    light: renderThemeColorScheme(colorPalette, value.light),
    dark: renderThemeColorScheme(colorPalette, value.dark)
  };
}
function renderThemeColorScheme(colorPalette, value) {
  const toneEntries = Object.entries(value), [, transparentTone] = toneEntries.find(([k2]) => k2 === "transparent"), [, defaultTone] = toneEntries.find(([k2]) => k2 === "default"), renderedTransparentTone = renderThemeColor(transparentTone, {
    colorPalette
  }), renderedDefaultTone = renderThemeColor(defaultTone, {
    colorPalette
  }), bg = renderedDefaultTone.bg;
  if (bg === "white")
    throw new Error("Cannot blend with white background");
  return Object.fromEntries([["transparent", renderedTransparentTone], ["default", renderedDefaultTone], ...toneEntries.filter(([k2]) => k2 !== "default" && k2 !== "transparent").map(([k2, v2]) => [k2, renderThemeColor(v2, {
    bg,
    colorPalette
  })])]);
}
function renderThemeColor(value, options2) {
  const {
    colorPalette,
    bg
  } = options2, blendMode = value._blend || "multiply", baseBg = renderColorValue(value.bg, {
    colorPalette,
    bg,
    blendMode
  }), colorOptions = {
    colorPalette,
    bg: baseBg,
    blendMode
  }, button = renderThemeColorButton(value.button, {
    baseBg,
    blendMode,
    colorPalette
  }), selectable = renderThemeColorSelectable(value.selectable, {
    colorPalette,
    baseBg,
    blendMode
  }), shadow = {
    outline: renderColorValue(value.shadow.outline, colorOptions),
    umbra: renderColorValue(value.shadow.umbra, {
      ...colorOptions,
      bg: void 0,
      colorPalette: {
        ...colorPalette,
        black: "#000000"
      }
    }),
    penumbra: renderColorValue(value.shadow.penumbra, {
      ...colorOptions,
      bg: void 0,
      colorPalette: {
        ...colorPalette,
        black: "#000000"
      }
    }),
    ambient: renderColorValue(value.shadow.ambient, {
      ...colorOptions,
      bg: void 0,
      colorPalette: {
        ...colorPalette,
        black: "#000000"
      }
    })
  };
  return {
    _blend: blendMode,
    _dark: value._dark,
    accent: {
      fg: renderColorValue(value.accent.fg, colorOptions)
    },
    avatar: renderThemeColorAvatar(value.avatar, {
      baseBg,
      colorPalette,
      blendMode
    }),
    backdrop: renderColorValue(value.backdrop, colorOptions),
    badge: renderThemeColorBadge(value.badge, {
      baseBg,
      colorPalette,
      blendMode
    }),
    bg: baseBg,
    border: renderColorValue(value.border, colorOptions),
    button,
    code: {
      bg: renderColorValue(value.code.bg, colorOptions),
      fg: renderColorValue(value.code.fg, colorOptions)
    },
    fg: renderColorValue(value.fg, colorOptions),
    focusRing: renderColorValue(value.focusRing, colorOptions),
    icon: renderColorValue(value.icon, colorOptions),
    input: renderThemeColorInput(value.input, {
      baseBg,
      colorPalette,
      blendMode
    }),
    kbd: renderThemeColorKBD(value.kbd, {
      baseBg,
      colorPalette,
      blendMode
    }),
    link: {
      fg: renderColorValue(value.link.fg, colorOptions)
    },
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions),
      fg: renderColorValue(value.muted.fg, colorOptions)
    },
    shadow,
    skeleton: {
      from: renderColorValue(value.skeleton.from, colorOptions),
      to: renderColorValue(value.skeleton.to, colorOptions)
    },
    syntax: renderSyntaxColorTheme(value.syntax, {
      baseBg,
      colorPalette,
      blendMode
    }),
    selectable
  };
}
function renderThemeColorKBD(value, options2) {
  const {
    baseBg,
    blendMode,
    colorPalette
  } = options2, rootOptions = {
    bg: baseBg,
    blendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    bg,
    fg: renderColorValue(value.fg, colorOptions),
    border: renderColorValue(value.border, colorOptions)
  };
}
function renderThemeColorAvatar(value, options2) {
  const colorAvatar = {};
  for (const hue of COLOR_HUES)
    colorAvatar[hue] = renderThemeColorAvatarColor(value[hue], options2);
  return colorAvatar;
}
function renderThemeColorAvatarColor(value, options2) {
  const {
    baseBg,
    blendMode: rootBlendMode,
    colorPalette
  } = options2, blendMode = value._blend || "multiply", rootOptions = {
    bg: baseBg,
    blendMode: rootBlendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    _blend: blendMode,
    bg,
    fg: renderColorValue(value.fg, colorOptions)
  };
}
function renderThemeColorBadge(value, options2) {
  const colorBadge = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    colorBadge[tone] = renderThemeColorBadgeColor(value[tone], options2);
  return colorBadge;
}
function renderThemeColorBadgeColor(value, options2) {
  const {
    baseBg,
    blendMode: rootBlendMode,
    colorPalette
  } = options2, blendMode = rootBlendMode, rootOptions = {
    bg: baseBg,
    blendMode: rootBlendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    bg,
    dot: renderColorValue(value.dot, colorOptions),
    fg: renderColorValue(value.fg, colorOptions),
    icon: renderColorValue(value.icon, colorOptions)
  };
}
function renderThemeColorButton(value, options2) {
  return {
    default: renderThemeColorButtonTones(value.default, options2),
    ghost: renderThemeColorButtonTones(value.ghost, options2),
    bleed: renderThemeColorButtonTones(value.bleed, options2)
  };
}
function renderThemeColorButtonTones(value, options2) {
  const colorButtonMode = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    colorButtonMode[tone] = renderThemeColorButtonStates(value[tone], options2);
  return colorButtonMode;
}
function renderThemeColorButtonStates(value, options2) {
  return {
    enabled: renderThemeColorState(value.enabled, options2),
    hovered: renderThemeColorState(value.hovered, options2),
    pressed: renderThemeColorState(value.pressed, options2),
    selected: renderThemeColorState(value.selected, options2),
    disabled: renderThemeColorState(value.disabled, options2)
  };
}
function renderThemeColorState(value, options2) {
  const {
    baseBg,
    blendMode: rootBlendMode,
    colorPalette
  } = options2, blendMode = value._blend || "multiply", rootOptions = {
    bg: baseBg,
    blendMode: rootBlendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    _blend: blendMode,
    accent: {
      fg: renderColorValue(value.accent.fg, colorOptions)
    },
    avatar: renderThemeColorAvatar(value.avatar, {
      baseBg: bg,
      colorPalette,
      blendMode
    }),
    badge: renderThemeColorBadge(value.badge, {
      baseBg: bg,
      colorPalette,
      blendMode
    }),
    bg,
    border: renderColorValue(value.border, colorOptions),
    code: {
      bg: renderColorValue(value.code.bg, colorOptions),
      fg: renderColorValue(value.code.fg, colorOptions)
    },
    fg: renderColorValue(value.fg, colorOptions),
    icon: renderColorValue(value.icon, colorOptions),
    link: {
      fg: renderColorValue(value.link.fg, colorOptions)
    },
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions),
      fg: renderColorValue(value.muted.fg, colorOptions)
    },
    kbd: {
      bg: renderColorValue(value.kbd.bg, colorOptions),
      fg: renderColorValue(value.kbd.fg, colorOptions),
      border: renderColorValue(value.kbd.border, colorOptions)
    },
    skeleton: {
      from: renderColorValue(value.skeleton?.from, colorOptions),
      to: renderColorValue(value.skeleton?.to, colorOptions)
    }
  };
}
function renderThemeColorInput(value, options2) {
  return {
    default: renderInputStatesColorTheme(value.default, options2),
    invalid: renderInputStatesColorTheme(value.invalid, options2)
  };
}
function renderInputStatesColorTheme(value, options2) {
  return {
    enabled: renderInputStateColorTheme(value.enabled, options2),
    hovered: renderInputStateColorTheme(value.hovered, options2),
    readOnly: renderInputStateColorTheme(value.readOnly, options2),
    disabled: renderInputStateColorTheme(value.disabled, options2)
  };
}
function renderInputStateColorTheme(value, options2) {
  const {
    baseBg,
    blendMode: rootBlendMode,
    colorPalette
  } = options2, blendMode = value._blend || "multiply", rootOptions = {
    colorPalette,
    bg: baseBg,
    blendMode: rootBlendMode
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    colorPalette,
    bg,
    blendMode
  };
  return {
    _blend: blendMode,
    bg,
    border: renderColorValue(value.border, colorOptions),
    fg: renderColorValue(value.fg, colorOptions),
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions)
    },
    placeholder: renderColorValue(value.placeholder, colorOptions)
  };
}
function renderThemeColorSelectable(value, options2) {
  const colorSelectable = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    colorSelectable[tone] = renderThemeColorSelectableStates(value[tone], options2);
  return colorSelectable;
}
function renderThemeColorSelectableStates(value, options2) {
  return {
    enabled: renderThemeColorState(value.enabled, options2),
    hovered: renderThemeColorState(value.hovered, options2),
    pressed: renderThemeColorState(value.pressed, options2),
    selected: renderThemeColorState(value.selected, options2),
    disabled: renderThemeColorState(value.disabled, options2)
  };
}
function renderSyntaxColorTheme(value, options2) {
  const {
    colorPalette,
    baseBg,
    blendMode
  } = options2, colorOptions = {
    colorPalette,
    bg: baseBg,
    blendMode
  };
  return {
    atrule: renderColorValue(value.atrule, colorOptions),
    attrName: renderColorValue(value.attrName, colorOptions),
    attrValue: renderColorValue(value.attrValue, colorOptions),
    attribute: renderColorValue(value.attribute, colorOptions),
    boolean: renderColorValue(value.boolean, colorOptions),
    builtin: renderColorValue(value.builtin, colorOptions),
    cdata: renderColorValue(value.cdata, colorOptions),
    char: renderColorValue(value.char, colorOptions),
    class: renderColorValue(value.class, colorOptions),
    className: renderColorValue(value.className, colorOptions),
    comment: renderColorValue(value.comment, colorOptions),
    constant: renderColorValue(value.constant, colorOptions),
    deleted: renderColorValue(value.deleted, colorOptions),
    doctype: renderColorValue(value.doctype, colorOptions),
    entity: renderColorValue(value.entity, colorOptions),
    function: renderColorValue(value.function, colorOptions),
    hexcode: renderColorValue(value.hexcode, colorOptions),
    id: renderColorValue(value.id, colorOptions),
    important: renderColorValue(value.important, colorOptions),
    inserted: renderColorValue(value.inserted, colorOptions),
    keyword: renderColorValue(value.keyword, colorOptions),
    number: renderColorValue(value.number, colorOptions),
    operator: renderColorValue(value.operator, colorOptions),
    prolog: renderColorValue(value.prolog, colorOptions),
    property: renderColorValue(value.property, colorOptions),
    pseudoClass: renderColorValue(value.pseudoClass, colorOptions),
    pseudoElement: renderColorValue(value.pseudoElement, colorOptions),
    punctuation: renderColorValue(value.punctuation, colorOptions),
    regex: renderColorValue(value.regex, colorOptions),
    selector: renderColorValue(value.selector, colorOptions),
    string: renderColorValue(value.string, colorOptions),
    symbol: renderColorValue(value.symbol, colorOptions),
    tag: renderColorValue(value.tag, colorOptions),
    unit: renderColorValue(value.unit, colorOptions),
    url: renderColorValue(value.url, colorOptions),
    variable: renderColorValue(value.variable, colorOptions)
  };
}
function buildTheme(config) {
  const colorTheme = buildColorTheme(config), v2 = {
    _version: 2,
    avatar: config?.avatar ?? defaultThemeConfig.avatar,
    button: config?.button ?? defaultThemeConfig.button,
    card: config?.card ?? defaultThemeConfig.card,
    // How colors are generated:
    // 1. Merge custom tokens with default tokens
    // 2. Generate tree of color keys (gray/500, black, white, etc.)
    // 3. Apply mixing and render to hex values
    // render(build(mergeWithDefaults()))
    color: renderThemeColorSchemes(colorTheme, config),
    container: config?.container ?? defaultThemeConfig.container,
    font: config?.font ?? defaultThemeFonts,
    input: config?.input ?? defaultThemeConfig.input,
    layer: config?.layer ?? defaultThemeConfig.layer,
    media: config?.media ?? defaultThemeConfig.media,
    radius: config?.radius ?? defaultThemeConfig.radius,
    shadow: config?.shadow ?? defaultThemeConfig.shadow,
    space: config?.space ?? defaultThemeConfig.space,
    style: config?.style ?? defaultThemeConfig.style
  };
  return v2_v0(v2);
}
function themeColor_v0_v2_9(color2) {
  if ("neutral" in color2.badge)
    return color2;
  const colors22 = color2;
  return {
    ...colors22,
    badge: {
      ...colors22.badge,
      neutral: colors22.badge.default,
      suggest: colors22.badge.primary
    },
    button: {
      bleed: {
        ...colors22.button.bleed,
        neutral: colors22.button.bleed.default,
        suggest: colors22.button.bleed.primary
      },
      default: {
        ...colors22.button.default,
        neutral: colors22.button.default.default,
        suggest: colors22.button.default.primary
      },
      ghost: {
        ...colors22.button.ghost,
        neutral: colors22.button.ghost.default,
        suggest: colors22.button.ghost.primary
      }
    },
    selectable: {
      ...colors22.selectable,
      neutral: colors22.selectable.default,
      suggest: colors22.selectable.primary
    }
  };
}
var cache = /* @__PURE__ */ new Map();
function getScopedTheme(themeProp, scheme, tone) {
  const cachedTheme = _getCachedTheme(themeProp, scheme, tone);
  if (cachedTheme) return cachedTheme;
  const v0 = is_v2(themeProp) ? v2_v0(themeProp) : themeProp, v2 = is_v2(themeProp) ? themeProp : v0_v2(themeProp), colorScheme_v0 = v0.color[scheme] || v0.color.light, color_v0 = colorScheme_v0[tone] || colorScheme_v0.default, layer_v0 = v0.layer || defaultThemeConfig.layer, colorScheme_v2 = v2.color[scheme] || v2.color.light, color_v2 = colorScheme_v2[tone] || colorScheme_v2.default, color_v2_9 = themeColor_v0_v2_9(color_v2), layer_v2 = v2.layer || defaultThemeConfig.layer, theme = {
    sanity: {
      ...v0,
      color: color_v0,
      layer: layer_v0,
      v2: {
        ...v2,
        _resolved: true,
        color: color_v2_9,
        layer: layer_v2
      }
    }
  };
  return _setCachedTheme(themeProp, scheme, tone, theme), theme;
}
function _getCachedTheme(rootTheme, scheme, tone) {
  const schemeCache = cache.get(scheme);
  if (!schemeCache) return;
  const toneCache = schemeCache.get(tone);
  if (toneCache)
    return toneCache.get(rootTheme);
}
function _setCachedTheme(rootTheme, scheme, tone, theme) {
  cache.has(scheme) || cache.set(scheme, /* @__PURE__ */ new Map());
  const schemeCache = cache.get(scheme);
  schemeCache.has(tone) || schemeCache.set(tone, /* @__PURE__ */ new WeakMap()), schemeCache.get(tone).set(rootTheme, theme);
}

// node_modules/sanity-plugin-media/node_modules/@sanity/ui/dist/_chunks-es/_visual-editing.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react_compiler_runtime = __toESM(require_dist(), 1);
var import_react = __toESM(require_react(), 1);
var import_react_is = __toESM(require_react_is(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
var studioTheme = buildTheme();
var EMPTY_ARRAY = [];
var EMPTY_RECORD = {};
var POPOVER_MOTION_PROPS = {
  card: {
    initial: {
      scale: 0.97,
      willChange: "transform"
    },
    hidden: {
      opacity: 0
    },
    visible: {
      opacity: 1,
      transition: {
        when: "beforeChildren",
        duration: 0.1
      }
    },
    scaleIn: {
      scale: 1
    },
    scaleOut: {
      scale: 0.97
    }
  },
  children: {
    hidden: {
      opacity: 0
    },
    visible: {
      opacity: 1
    }
  },
  transition: {
    type: "spring",
    visualDuration: 0.2,
    bounce: 0.25
  }
};
function _isEnterToClickElement(element) {
  return isHTMLAnchorElement(element) || isHTMLButtonElement(element);
}
function isHTMLElement(node2) {
  return node2 instanceof Node && node2.nodeType === Node.ELEMENT_NODE;
}
function isHTMLAnchorElement(element) {
  return isHTMLElement(element) && element.nodeName === "A";
}
function isHTMLInputElement(element) {
  return isHTMLElement(element) && element.nodeName === "INPUT";
}
function isHTMLButtonElement(element) {
  return isHTMLElement(element) && element.nodeName === "BUTTON";
}
function isHTMLSelectElement(element) {
  return isHTMLElement(element) && element.nodeName === "SELECT";
}
function isHTMLTextAreaElement(element) {
  return isHTMLElement(element) && element.nodeName === "TEXTAREA";
}
function containsOrEqualsElement(element, node2) {
  return element.contains(node2) || element === node2;
}
function _isScrollable(el) {
  if (!(el instanceof Element)) return false;
  const style = window.getComputedStyle(el);
  return style.overflowX.includes("auto") || style.overflowX.includes("scroll") || style.overflowY.includes("auto") || style.overflowY.includes("scroll");
}
function _fillCSSObject(keys, value) {
  return keys.reduce((style, key2) => (style[key2] = value, style), {});
}
function rem(pixelValue) {
  return pixelValue === 0 ? 0 : `${pixelValue / 16}rem`;
}
function _responsive(media2, values, callback) {
  return (values?.map(callback) || []).map((statement, mediaIndex) => mediaIndex === 0 ? statement : {
    [`@media screen and (min-width: ${media2[mediaIndex - 1]}px)`]: statement
  });
}
function _getArrayProp(val, defaultVal) {
  return val === void 0 ? defaultVal || EMPTY_ARRAY : Array.isArray(val) ? val : [val];
}
function _getResponsiveSpace(theme, props, spaceIndexes = EMPTY_ARRAY) {
  if (!Array.isArray(spaceIndexes))
    throw new Error("the property must be array of numbers");
  if (spaceIndexes.length === 0)
    return null;
  const {
    media: media2,
    space
  } = getTheme_v2(theme);
  return _responsive(media2, spaceIndexes, (spaceIndex) => _fillCSSObject(props, rem(space[spaceIndex])));
}
function responsiveFont(fontKey, props) {
  const {
    $size,
    $weight
  } = props, {
    font,
    media: media2
  } = getTheme_v2(props.theme), {
    family,
    sizes,
    weights
  } = font[fontKey], fontWeight = $weight && weights[$weight] || weights.regular, defaultSize = sizes[2], base = {
    position: "relative",
    fontFamily: family,
    fontWeight: `${fontWeight}`,
    padding: "1px 0",
    margin: 0,
    "&:before": {
      content: '""',
      display: "block",
      height: 0
    },
    "&:after": {
      content: '""',
      display: "block",
      height: 0
    },
    "& > code, & > span": {
      display: "block"
    },
    "&:not([hidden])": {
      display: "block"
    }
  };
  if (!$size)
    return responsiveFont.warned || (console.warn("No size specified for responsive font", {
      fontKey,
      $size,
      props,
      base
    }), responsiveFont.warned = true), [base];
  const resp = _responsive(media2, $size, (sizeIndex) => fontSize(sizes[sizeIndex] || defaultSize));
  return [base, ...resp];
}
function fontSize(size2) {
  const {
    ascenderHeight,
    descenderHeight,
    fontSize: fontSize2,
    iconSize,
    letterSpacing,
    lineHeight
  } = size2, negHeight = ascenderHeight + descenderHeight, capHeight = lineHeight - negHeight, iconOffset = (capHeight - iconSize) / 2, customIconSize = Math.floor(fontSize2 * 1.125 / 2) * 2 + 1, customIconOffset = (capHeight - customIconSize) / 2;
  return {
    fontSize: rem(fontSize2),
    lineHeight: `calc(${lineHeight} / ${fontSize2})`,
    letterSpacing: rem(letterSpacing),
    transform: `translateY(${rem(descenderHeight)})`,
    "&:before": {
      marginTop: `calc(${rem(0 - negHeight)} - 1px)`
    },
    "&:after": {
      marginBottom: "-1px"
    },
    "& svg:not([data-sanity-icon])": {
      fontSize: `calc(${customIconSize} / 16 * 1rem)`,
      margin: rem(customIconOffset)
    },
    "& [data-sanity-icon]": {
      fontSize: `calc(${iconSize} / 16 * 1rem)`,
      margin: rem(iconOffset)
    }
  };
}
function responsiveCodeFontStyle(props) {
  return responsiveFont("code", props);
}
function responsiveHeadingFont(props) {
  return responsiveFont("heading", props);
}
function responsiveLabelFont(props) {
  return responsiveFont("label", props);
}
function responsiveTextAlignStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$align, (textAlign) => ({
    textAlign
  }));
}
function responsiveTextFont(props) {
  return responsiveFont("text", props);
}
function getGlobalScope() {
  if (typeof globalThis < "u") return globalThis;
  if (typeof window < "u") return window;
  if (typeof self < "u") return self;
  if (typeof global < "u") return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
var globalScope = getGlobalScope();
function createGlobalScopedContext(key2, defaultValue) {
  const symbol = Symbol.for(key2);
  if (typeof document > "u") {
    const context = (0, import_react.createContext)(defaultValue);
    return context.displayName = key2, context;
  }
  return globalScope[symbol] = globalScope[symbol] || (0, import_react.createContext)(defaultValue), globalScope[symbol];
}
var ThemeContext = createGlobalScopedContext("@sanity/ui/context/theme", null);
function ThemeProvider(props) {
  const $3 = (0, import_react_compiler_runtime.c)(15), parentTheme = (0, import_react.useContext)(ThemeContext), {
    children
  } = props, scheme = props.scheme ?? (parentTheme?.scheme || "light"), rootTheme = props.theme ?? (parentTheme?.theme || null), tone = props.tone ?? (parentTheme?.tone || "default");
  let t0;
  bb0: {
    if (!rootTheme) {
      t0 = null;
      break bb0;
    }
    let t12;
    $3[0] !== rootTheme || $3[1] !== scheme || $3[2] !== tone ? (t12 = {
      version: 0,
      theme: rootTheme,
      scheme,
      tone
    }, $3[0] = rootTheme, $3[1] = scheme, $3[2] = tone, $3[3] = t12) : t12 = $3[3], t0 = t12;
  }
  const themeContext = t0;
  let t1;
  bb1: {
    if (!rootTheme) {
      t1 = null;
      break bb1;
    }
    let t222;
    $3[4] !== rootTheme || $3[5] !== scheme || $3[6] !== tone ? (t222 = getScopedTheme(rootTheme, scheme, tone), $3[4] = rootTheme, $3[5] = scheme, $3[6] = tone, $3[7] = t222) : t222 = $3[7], t1 = t222;
  }
  const theme = t1;
  if (!theme) {
    let t222;
    return $3[8] === Symbol.for("react.memo_cache_sentinel") ? (t222 = (0, import_jsx_runtime.jsx)("pre", { children: 'ThemeProvider: no "theme" property provided' }), $3[8] = t222) : t222 = $3[8], t222;
  }
  let t22;
  $3[9] !== children || $3[10] !== theme ? (t22 = (0, import_jsx_runtime.jsx)(ot, { theme, children }), $3[9] = children, $3[10] = theme, $3[11] = t22) : t22 = $3[11];
  let t3;
  return $3[12] !== t22 || $3[13] !== themeContext ? (t3 = (0, import_jsx_runtime.jsx)(ThemeContext.Provider, { value: themeContext, children: t22 }), $3[12] = t22, $3[13] = themeContext, $3[14] = t3) : t3 = $3[14], t3;
}
ThemeProvider.displayName = "ThemeProvider";
function useRootTheme() {
  const value = (0, import_react.useContext)(ThemeContext);
  if (!value)
    throw new Error("useRootTheme(): missing context value");
  return value;
}
function ThemeColorProvider(props) {
  const $3 = (0, import_react_compiler_runtime.c)(5), {
    children,
    scheme,
    tone
  } = props, root = useRootTheme(), t0 = scheme || root.scheme;
  let t1;
  return $3[0] !== children || $3[1] !== root.theme || $3[2] !== t0 || $3[3] !== tone ? (t1 = (0, import_jsx_runtime.jsx)(ThemeProvider, { scheme: t0, theme: root.theme, tone, children }), $3[0] = children, $3[1] = root.theme, $3[2] = t0, $3[3] = tone, $3[4] = t1) : t1 = $3[4], t1;
}
ThemeColorProvider.displayName = "ThemeColorProvider";
function useTheme_v2() {
  const $3 = (0, import_react_compiler_runtime.c)(2), t0 = nt();
  let t1;
  return $3[0] !== t0 ? (t1 = getTheme_v2(t0), $3[0] = t0, $3[1] = t1) : t1 = $3[1], t1;
}
function responsiveBorderStyle() {
  return [border, borderTop, borderRight, borderBottom, borderLeft];
}
function border(props) {
  const {
    card,
    media: media2
  } = getTheme_v2(props.theme), borderStyle = `${card.border?.width ?? 1}px solid var(--card-border-color)`;
  return _responsive(media2, props.$border, (value) => value ? {
    "&&": {
      border: borderStyle
    }
  } : {
    "&&": {
      border: 0
    }
  });
}
function borderTop(props) {
  const {
    card,
    media: media2
  } = getTheme_v2(props.theme), borderStyle = `${card.border?.width ?? 1}px solid var(--card-border-color)`;
  return _responsive(media2, props.$borderTop, (value) => value ? {
    "&&": {
      borderTop: borderStyle
    }
  } : {
    "&&": {
      borderTop: 0
    }
  });
}
function borderRight(props) {
  const {
    card,
    media: media2
  } = getTheme_v2(props.theme), borderStyle = `${card.border?.width ?? 1}px solid var(--card-border-color)`;
  return _responsive(media2, props.$borderRight, (value) => value ? {
    "&&": {
      borderRight: borderStyle
    }
  } : {
    "&&": {
      borderRight: 0
    }
  });
}
function borderBottom(props) {
  const {
    card,
    media: media2
  } = getTheme_v2(props.theme), borderStyle = `${card.border?.width ?? 1}px solid var(--card-border-color)`;
  return _responsive(media2, props.$borderBottom, (value) => value ? {
    "&&": {
      borderBottom: borderStyle
    }
  } : {
    "&&": {
      borderBottom: 0
    }
  });
}
function borderLeft(props) {
  const {
    card,
    media: media2
  } = getTheme_v2(props.theme), borderStyle = `${card.border?.width ?? 1}px solid var(--card-border-color)`;
  return _responsive(media2, props.$borderLeft, (value) => value ? {
    "&&": {
      borderLeft: borderStyle
    }
  } : {
    "&&": {
      borderLeft: 0
    }
  });
}
var BASE_STYLE$4 = {
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
var BOX_SIZING = {
  content: "content-box",
  border: "border-box"
};
var BOX_HEIGHT = {
  stretch: "stretch",
  fill: "100%"
};
function boxStyle() {
  return BASE_STYLE$4;
}
function responsiveBoxStyle() {
  return [responsiveBoxSizingStyle, responsiveBoxHeightStyle, responsiveBoxOverflowStyle, responsiveBoxDisplayStyle];
}
function responsiveBoxDisplayStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$display, (display) => ({
    "&:not([hidden])": {
      display
    }
  }));
}
function responsiveBoxSizingStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$sizing, (sizing) => ({
    boxSizing: BOX_SIZING[sizing]
  }));
}
function responsiveBoxHeightStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$height, (height) => ({
    height: BOX_HEIGHT[height]
  }));
}
function responsiveBoxOverflowStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$overflow, (overflow) => ({
    overflow
  }));
}
var BASE_STYLE$3 = {
  minWidth: 0,
  minHeight: 0
};
function flexItemStyle() {
  return [BASE_STYLE$3, responsiveFlexItemStyle];
}
function responsiveFlexItemStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return props.$flex ? _responsive(media2, props.$flex, (flex) => ({
    flex: `${flex}`
  })) : EMPTY_ARRAY;
}
var BASE_STYLE$2 = {
  "&&:not([hidden])": {
    display: "flex"
  }
};
function responsiveFlexStyle() {
  return [BASE_STYLE$2, responsiveFlexAlignStyle, responsiveFlexGapStyle, responsiveFlexWrapStyle, responsiveFlexJustifyStyle, responsiveFlexDirectionStyle];
}
function responsiveFlexAlignStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$align, (align) => ({
    alignItems: align
  }));
}
function responsiveFlexGapStyle(props) {
  const {
    media: media2,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$gap, (gap) => ({
    gap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveFlexWrapStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$wrap, (wrap) => ({
    flexWrap: wrap
  }));
}
function responsiveFlexJustifyStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$justify, (justify) => ({
    justifyContent: justify
  }));
}
function responsiveFlexDirectionStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$direction, (direction) => ({
    flexDirection: direction
  }));
}
function focusRingBorderStyle(border2) {
  return `inset 0 0 0 ${border2.width}px ${border2.color}`;
}
function focusRingStyle(opts) {
  const {
    base,
    border: border2,
    focusRing
  } = opts, focusRingOutsetWidth = focusRing.offset + focusRing.width, focusRingInsetWidth = 0 - focusRing.offset, bgColor = base ? base.bg : "var(--card-bg-color)";
  return [focusRingInsetWidth > 0 && `inset 0 0 0 ${focusRingInsetWidth}px var(--card-focus-ring-color)`, border2 && focusRingBorderStyle(border2), focusRingInsetWidth < 0 && `0 0 0 ${0 - focusRingInsetWidth}px ${bgColor}`, focusRingOutsetWidth > 0 && `0 0 0 ${focusRingOutsetWidth}px var(--card-focus-ring-color)`].filter(Boolean).join(",");
}
function responsiveGridItemStyle() {
  return [responsiveGridItemRowStyle, responsiveGridItemRowStartStyle, responsiveGridItemRowEndStyle, responsiveGridItemColumnStyle, responsiveGridItemColumnStartStyle, responsiveGridItemColumnEndStyle];
}
var GRID_ITEM_ROW = {
  auto: "auto",
  full: "1 / -1"
};
var GRID_ITEM_COLUMN = {
  auto: "auto",
  full: "1 / -1"
};
function responsiveGridItemRowStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$row, (row) => typeof row == "number" ? {
    gridRow: `span ${row} / span ${row}`
  } : {
    gridRow: GRID_ITEM_ROW[row]
  });
}
function responsiveGridItemRowStartStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$rowStart, (rowStart) => ({
    gridRowStart: `${rowStart}`
  }));
}
function responsiveGridItemRowEndStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$rowEnd, (rowEnd) => ({
    gridRowEnd: `${rowEnd}`
  }));
}
function responsiveGridItemColumnStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$column, (column2) => typeof column2 == "number" ? {
    gridColumn: `span ${column2} / span ${column2}`
  } : {
    gridColumn: GRID_ITEM_COLUMN[column2]
  });
}
function responsiveGridItemColumnStartStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$columnStart, (columnStart) => ({
    gridColumnStart: `${columnStart}`
  }));
}
function responsiveGridItemColumnEndStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$columnEnd, (columnEnd) => ({
    gridColumnEnd: `${columnEnd}`
  }));
}
var GRID_CSS = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
var GRID_AUTO_COLUMS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
var GRID_AUTO_ROWS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
function responsiveGridStyle() {
  return [GRID_CSS, responsiveGridAutoFlowStyle, responsiveGridAutoRowsStyle, responsiveGridAutoColsStyle, responsiveGridColumnsStyle, responsiveGridRowsStyle, responsiveGridGapStyle, responsiveGridGapXStyle, responsiveGridGapYStyle];
}
function responsiveGridAutoFlowStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$autoFlow, (autoFlow) => ({
    gridAutoFlow: autoFlow
  }));
}
function responsiveGridAutoRowsStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$autoRows, (autoRows) => ({
    gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows]
  }));
}
function responsiveGridAutoColsStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$autoCols, (autoCols) => ({
    gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols]
  }));
}
function responsiveGridColumnsStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$columns, (columns) => ({
    gridTemplateColumns: columns && `repeat(${columns},minmax(0,1fr));`
  }));
}
function responsiveGridRowsStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$rows, (rows) => ({
    gridTemplateRows: rows && `repeat(${rows},minmax(0,1fr));`
  }));
}
function responsiveGridGapStyle(props) {
  const {
    media: media2,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$gap, (gap) => ({
    gridGap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveGridGapXStyle(props) {
  const {
    media: media2,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$gapX, (gapX) => ({
    columnGap: gapX ? rem(space[gapX]) : void 0
  }));
}
function responsiveGridGapYStyle(props) {
  const {
    media: media2,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$gapY, (gapY) => ({
    rowGap: gapY ? rem(space[gapY]) : void 0
  }));
}
function responsiveInputPaddingStyle(props) {
  const {
    $fontSize,
    $iconLeft,
    $iconRight,
    $padding,
    $space
  } = props, {
    font,
    media: media2,
    space
  } = getTheme_v2(props.theme), len = Math.max($padding.length, $space.length, $fontSize.length), _padding = [], _space = [], _fontSize = [];
  for (let i3 = 0; i3 < len; i3 += 1)
    _fontSize[i3] = $fontSize[i3] === void 0 ? _fontSize[i3 - 1] : $fontSize[i3], _padding[i3] = $padding[i3] === void 0 ? _padding[i3 - 1] : $padding[i3], _space[i3] = $space[i3] === void 0 ? _space[i3 - 1] : $space[i3];
  return _responsive(media2, _padding, (_, i3) => {
    const size2 = font.text.sizes[_fontSize[i3]] || font.text.sizes[2], emSize = size2.lineHeight - size2.ascenderHeight - size2.descenderHeight, p2 = space[_padding[i3]], s3 = space[_space[i3]], styles = {
      paddingTop: rem(p2 - size2.ascenderHeight),
      paddingRight: rem(p2),
      paddingBottom: rem(p2 - size2.descenderHeight),
      paddingLeft: rem(p2)
    };
    return $iconRight && (styles.paddingRight = rem(p2 + emSize + s3)), $iconLeft && (styles.paddingLeft = rem(p2 + emSize + s3)), styles;
  });
}
function responsiveInputPaddingIconRightStyle(props) {
  return responsiveInputPaddingStyle({
    ...props,
    $iconRight: true
  });
}
var ROOT_STYLE = lt`
  &:not([hidden]) {
    display: flex;
  }

  align-items: center;
`;
function textInputRootStyle() {
  return ROOT_STYLE;
}
function textInputBaseStyle(props) {
  const {
    $scheme,
    $tone,
    $weight
  } = props, {
    color: color2,
    font
  } = getTheme_v2(props.theme);
  return lt`
    appearance: none;
    background: none;
    border: 0;
    border-radius: 0;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    font-family: ${font.text.family};
    font-weight: ${$weight && font.text.weights[$weight] || font.text.weights.regular};
    margin: 0;
    position: relative;
    z-index: 1;
    display: block;

    /* NOTE: This is a hack to disable Chrome’s autofill styles */
    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-text-fill-color: var(--input-fg-color) !important;
      transition: background-color 5000s;
      transition-delay: 86400s /* 24h */;
    }

    /* &:is(textarea) */
    &[data-as='textarea'] {
      resize: none;
    }

    color: var(--input-fg-color);

    &::placeholder {
      color: var(--input-placeholder-color);
    }

    &[data-scheme='${$scheme}'][data-tone='${$tone}'] {
      --input-fg-color: ${color2.input.default.enabled.fg};
      --input-placeholder-color: ${color2.input.default.enabled.placeholder};

      /* enabled */
      &:not(:invalid):not(:disabled):not(:read-only) {
        --input-fg-color: ${color2.input.default.enabled.fg};
        --input-placeholder-color: ${color2.input.default.enabled.placeholder};
      }

      /* disabled */
      &:not(:invalid):disabled {
        --input-fg-color: ${color2.input.default.disabled.fg};
        --input-placeholder-color: ${color2.input.default.disabled.placeholder};
      }

      /* invalid */
      &:invalid {
        --input-fg-color: ${color2.input.invalid.enabled.fg};
        --input-placeholder-color: ${color2.input.invalid.enabled.placeholder};
      }

      /* readOnly */
      &:read-only {
        --input-fg-color: ${color2.input.default.readOnly.fg};
        --input-placeholder-color: ${color2.input.default.readOnly.placeholder};
      }
    }
  `;
}
function textInputFontSizeStyle(props) {
  const {
    font,
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$fontSize, (sizeIndex) => {
    const size2 = font.text.sizes[sizeIndex] || font.text.sizes[2];
    return {
      fontSize: rem(size2.fontSize),
      lineHeight: `${size2.lineHeight / size2.fontSize}`
    };
  });
}
function textInputRepresentationStyle(props) {
  const {
    $hasPrefix,
    $hasSuffix,
    $scheme,
    $tone,
    $unstableDisableFocusRing
  } = props, {
    color: color2,
    input
  } = getTheme_v2(props.theme);
  return lt`
    --input-box-shadow: none;

    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: block;
    pointer-events: none;
    z-index: 0;

    background-color: var(--card-bg-color);
    box-shadow: var(--input-box-shadow);

    border-top-left-radius: ${$hasPrefix ? 0 : void 0};
    border-bottom-left-radius: ${$hasPrefix ? 0 : void 0};
    border-top-right-radius: ${$hasSuffix ? 0 : void 0};
    border-bottom-right-radius: ${$hasSuffix ? 0 : void 0};

    &[data-scheme='${$scheme}'][data-tone='${$tone}'] {
      --card-bg-color: ${color2.input.default.enabled.bg};
      --card-fg-color: ${color2.input.default.enabled.fg};

      /* enabled */
      *:not(:disabled) + &[data-border] {
        --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};
      }

      /* invalid */
      *:not(:disabled):invalid + & {
        --card-bg-color: ${color2.input.invalid.enabled.bg};
        --card-fg-color: ${color2.input.invalid.enabled.fg};

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.invalid.enabled.border,
    width: input.border.width
  })};
        }
      }

      /* focused */
      *:not(:disabled):focus + & {
        &[data-border] {
          --input-box-shadow: ${$unstableDisableFocusRing ? void 0 : focusRingStyle({
    border: {
      color: color2.input.default.enabled.border,
      width: input.border.width
    },
    focusRing: input.text.focusRing
  })};
        }

        &:not([data-border]) {
          --input-box-shadow: ${$unstableDisableFocusRing ? void 0 : focusRingStyle({
    focusRing: input.text.focusRing
  })};
        }
      }

      /* disabled */
      *:not(:invalid):disabled + & {
        --card-bg-color: ${color2.input.default.disabled.bg} !important;
        --card-fg-color: ${color2.input.default.disabled.fg} !important;
        --card-icon-color: ${color2.input.default.disabled.fg} !important;

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.disabled.border,
    width: input.border.width
  })};
        }
      }

      *:invalid:disabled + & {
        --card-bg-color: ${color2.input.invalid.disabled.bg} !important;
        --card-fg-color: ${color2.input.invalid.disabled.fg} !important;
        --card-icon-color: ${color2.input.invalid.disabled.fg} !important;

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.invalid.disabled.border,
    width: input.border.width
  })};
        }
      }

      /* readOnly */
      *:not(:invalid):read-only + & {
        --card-bg-color: ${color2.input.default.readOnly.bg} !important;
        --card-fg-color: ${color2.input.default.readOnly.fg} !important;
      }

      *:invalid:read-only + & {
        --card-bg-color: ${color2.input.invalid.readOnly.bg} !important;
        --card-fg-color: ${color2.input.invalid.readOnly.fg} !important;
      }

      /* hovered */
      @media (hover: hover) {
        *:not(:disabled):not(:read-only):not(:invalid):hover + & {
          --card-bg-color: ${color2.input.default.hovered.bg};
          --card-fg-color: ${color2.input.default.hovered.fg};
        }

        *:invalid:not(:disabled):not(:read-only):hover + & {
          --card-bg-color: ${color2.input.invalid.hovered.bg};
          --card-fg-color: ${color2.input.invalid.hovered.fg};
        }

        *:not(:disabled):not(:read-only):not(:invalid):not(:focus):hover + &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.hovered.border,
    width: input.border.width
  })};
        }

        *:invalid:not(:disabled):not(:read-only):not(:focus):hover + &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.invalid.hovered.border,
    width: input.border.width
  })};
        }
      }
    }
  `;
}
function responsiveMarginStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["margin"], props.$margin), _getResponsiveSpace(theme, ["marginLeft", "marginRight"], props.$marginX), _getResponsiveSpace(theme, ["marginTop", "marginBottom"], props.$marginY), _getResponsiveSpace(theme, ["marginTop"], props.$marginTop), _getResponsiveSpace(theme, ["marginRight"], props.$marginRight), _getResponsiveSpace(theme, ["marginBottom"], props.$marginBottom), _getResponsiveSpace(theme, ["marginLeft"], props.$marginLeft)].filter(Boolean);
}
function responsivePaddingStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["padding"], props.$padding), _getResponsiveSpace(theme, ["paddingLeft", "paddingRight"], props.$paddingX), _getResponsiveSpace(theme, ["paddingTop", "paddingBottom"], props.$paddingY), _getResponsiveSpace(theme, ["paddingTop"], props.$paddingTop), _getResponsiveSpace(theme, ["paddingRight"], props.$paddingRight), _getResponsiveSpace(theme, ["paddingBottom"], props.$paddingBottom), _getResponsiveSpace(theme, ["paddingLeft"], props.$paddingLeft)].filter(Boolean);
}
function responsiveRadiusStyle(props) {
  const {
    media: media2,
    radius
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$radius, (value) => {
    let borderRadius2 = 0;
    return typeof value == "number" && (borderRadius2 = rem(radius[value])), value === "full" && (borderRadius2 = "9999px"), {
      borderRadius: borderRadius2
    };
  });
}
function toBoxShadow(shadow, color2) {
  return `${shadow.map(rem).join(" ")} ${color2}`;
}
function shadowStyle(shadow, outlineWidth = 1) {
  if (!shadow) return EMPTY_RECORD;
  const outline = `0 0 0 ${rem(outlineWidth)} var(--card-shadow-outline-color)`, umbra = toBoxShadow(shadow.umbra, "var(--card-shadow-umbra-color)"), penumbra = toBoxShadow(shadow.penumbra, "var(--card-shadow-penumbra-color)"), ambient = toBoxShadow(shadow.ambient, "var(--card-shadow-ambient-color)");
  return {
    boxShadow: `${outline}, ${umbra}, ${penumbra}, ${ambient}`
  };
}
function responsiveShadowStyle(props) {
  const {
    card,
    media: media2,
    shadow
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$shadow, (index2) => shadowStyle(shadow[index2], card.shadow.outline));
}
var SpanWithTextOverflow = dt.span.withConfig({
  displayName: "SpanWithTextOverflow",
  componentId: "sc-ol2i3b-0"
})`display:block;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;overflow:clip;`;
function labelBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props, {
    font
  } = getTheme_v2(props.theme);
  return lt`
    text-transform: uppercase;

    ${$accent && lt`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && lt`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
var StyledLabel = dt.div.withConfig({
  displayName: "StyledLabel",
  componentId: "sc-1luap7z-0"
})(responsiveLabelFont, responsiveTextAlignStyle, labelBaseStyle);
var Label = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(26);
  let accent, align, childrenProp, restProps, t0, t1, textOverflow, weight;
  $3[0] !== props ? ({
    accent,
    align,
    children: childrenProp,
    muted: t0,
    size: t1,
    textOverflow,
    weight,
    ...restProps
  } = props, $3[0] = props, $3[1] = accent, $3[2] = align, $3[3] = childrenProp, $3[4] = restProps, $3[5] = t0, $3[6] = t1, $3[7] = textOverflow, $3[8] = weight) : (accent = $3[1], align = $3[2], childrenProp = $3[3], restProps = $3[4], t0 = $3[5], t1 = $3[6], textOverflow = $3[7], weight = $3[8]);
  const muted = t0 === void 0 ? false : t0, size2 = t1 === void 0 ? 2 : t1;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    let t222;
    $3[9] !== children ? (t222 = (0, import_jsx_runtime.jsx)(SpanWithTextOverflow, { children }), $3[9] = children, $3[10] = t222) : t222 = $3[10], children = t222;
  } else {
    let t222;
    $3[11] !== children ? (t222 = (0, import_jsx_runtime.jsx)("span", { children }), $3[11] = children, $3[12] = t222) : t222 = $3[12], children = t222;
  }
  let t22;
  $3[13] !== align ? (t22 = _getArrayProp(align), $3[13] = align, $3[14] = t22) : t22 = $3[14];
  let t3;
  $3[15] !== size2 ? (t3 = _getArrayProp(size2), $3[15] = size2, $3[16] = t3) : t3 = $3[16];
  let t4;
  return $3[17] !== accent || $3[18] !== children || $3[19] !== muted || $3[20] !== ref || $3[21] !== restProps || $3[22] !== t22 || $3[23] !== t3 || $3[24] !== weight ? (t4 = (0, import_jsx_runtime.jsx)(StyledLabel, { "data-ui": "Label", ...restProps, $accent: accent, $align: t22, $muted: muted, $size: t3, $weight: weight, ref, children }), $3[17] = accent, $3[18] = children, $3[19] = muted, $3[20] = ref, $3[21] = restProps, $3[22] = t22, $3[23] = t3, $3[24] = weight, $3[25] = t4) : t4 = $3[25], t4;
});
Label.displayName = "ForwardRef(Label)";
var avatarStyle = {
  root: avatarRootStyle,
  arrow: avatarArrowStyle,
  bgStroke: avatarBgStrokeStyle,
  stroke: avatarStrokeStyle,
  initials: avatarInitialsStyle,
  image: avatarImageStyle
};
function avatarArrowStyle() {
  return {
    position: "absolute",
    boxSizing: "border-box",
    zIndex: "0",
    opacity: "0",
    transition: "all 0.2s linear",
    transform: "rotate(-90deg) translate3d(0, 6px, 0)",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    "& > svg": {
      width: "11px",
      height: "7px",
      position: "absolute",
      top: "-5px",
      left: "50%",
      transform: "translateX(-6px)",
      "&:not([hidden])": {
        display: "block"
      }
    },
    "[data-arrow-position='inside'] > &": {
      transform: "rotate(-90deg) translate3d(0, 6px, 0)",
      opacity: "0"
    },
    "[data-arrow-position='top'] > &": {
      opacity: "1",
      transform: "rotate(0deg)"
    },
    "[data-arrow-position='bottom'] > &": {
      opacity: "1",
      transform: "rotate(-180deg)"
    }
  };
}
function avatarRootStyle(props) {
  const {
    $color
  } = props, {
    avatar
  } = getTheme_v2(props.theme);
  return {
    "--avatar-bg-color": `var(--card-avatar-${$color}-bg-color)`,
    "--avatar-fg-color": `var(--card-avatar-${$color}-fg-color)`,
    backgroundColor: "var(--avatar-bg-color)",
    position: "relative",
    boxSizing: "border-box",
    userSelect: "none",
    boxShadow: "0 0 0 1px var(--card-bg-color)",
    '&[data-status="inactive"]': {
      opacity: "0.5"
    },
    "&>svg": {
      "&:not([hidden])": {
        display: "block"
      }
    },
    /* &:is(button) */
    '&[data-as="button"]': {
      WebkitFontSmoothing: "inherit",
      appearance: "none",
      margin: 0,
      padding: 0,
      border: 0,
      font: "inherit",
      color: "inherit",
      outline: "none",
      "&:focus": {
        boxShadow: focusRingStyle({
          focusRing: avatar.focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: "none"
      }
    }
  };
}
function responsiveAvatarSizeStyle(props) {
  const {
    avatar,
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2] || avatar.sizes[0];
    return {
      width: rem(avatarSize.size),
      height: rem(avatarSize.size),
      borderRadius: rem(avatarSize.size / 2),
      "&>svg": {
        width: rem(avatarSize.size),
        height: rem(avatarSize.size),
        borderRadius: rem(avatarSize.size / 2)
      }
    };
  });
}
function avatarImageStyle() {
  return {
    position: "relative"
  };
}
function avatarInitialsStyle() {
  return {
    width: "100%",
    height: "100%",
    color: "var(--avatar-fg-color)",
    alignItems: "center",
    justifyContent: "center",
    textTransform: "uppercase",
    textAlign: "center",
    borderRadius: "50%",
    "&:not([hidden])": {
      display: "flex"
    }
  };
}
function avatarBgStrokeStyle() {
  return {
    strokeWidth: "4px",
    stroke: "var(--card-bg-color)"
  };
}
function avatarStrokeStyle() {
  return {
    strokeWidth: "2px",
    stroke: "var(--avatar-bg-color)",
    '[data-status="editing"] &': {
      strokeDasharray: "2 4",
      strokeLinecap: "round"
    }
  };
}
var StyledAvatar = dt.div.withConfig({
  displayName: "StyledAvatar",
  componentId: "sc-1rj7kl0-0"
})(responsiveAvatarSizeStyle, avatarStyle.root);
var Arrow$1 = dt.div.withConfig({
  displayName: "Arrow",
  componentId: "sc-1rj7kl0-1"
})(avatarStyle.arrow);
var BgStroke = dt.ellipse.withConfig({
  displayName: "BgStroke",
  componentId: "sc-1rj7kl0-2"
})(avatarStyle.bgStroke);
var Stroke = dt.ellipse.withConfig({
  displayName: "Stroke",
  componentId: "sc-1rj7kl0-3"
})(avatarStyle.stroke);
var Initials = dt.div.withConfig({
  displayName: "Initials",
  componentId: "sc-1rj7kl0-4"
})(avatarStyle.initials);
var InitialsLabel = dt(Label).withConfig({
  displayName: "InitialsLabel",
  componentId: "sc-1rj7kl0-5"
})({
  color: "inherit"
});
var AvatarImage = dt.svg.withConfig({
  displayName: "AvatarImage",
  componentId: "sc-1rj7kl0-6"
})(avatarStyle.image);
var Avatar = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(46);
  let __unstable_hideInnerStroke, animateArrowFrom, arrowPositionProp, asProp, initials, onImageLoadError, restProps, src, t0, t1, t22, title;
  $3[0] !== props ? ({
    __unstable_hideInnerStroke,
    as: asProp,
    color: t0,
    src,
    title,
    initials,
    onImageLoadError,
    arrowPosition: arrowPositionProp,
    animateArrowFrom,
    status: t1,
    size: t22,
    ...restProps
  } = props, $3[0] = props, $3[1] = __unstable_hideInnerStroke, $3[2] = animateArrowFrom, $3[3] = arrowPositionProp, $3[4] = asProp, $3[5] = initials, $3[6] = onImageLoadError, $3[7] = restProps, $3[8] = src, $3[9] = t0, $3[10] = t1, $3[11] = t22, $3[12] = title) : (__unstable_hideInnerStroke = $3[1], animateArrowFrom = $3[2], arrowPositionProp = $3[3], asProp = $3[4], initials = $3[5], onImageLoadError = $3[6], restProps = $3[7], src = $3[8], t0 = $3[9], t1 = $3[10], t22 = $3[11], title = $3[12]);
  const color2 = t0 === void 0 ? "gray" : t0, status = t1 === void 0 ? "online" : t1, sizeProp = t22 === void 0 ? 1 : t22, {
    avatar
  } = useTheme_v2(), as = import_react_is.default.isValidElementType(asProp) ? asProp : "div", size2 = _getArrayProp(sizeProp), _sizeRem = (avatar.sizes[size2[0]] || avatar.sizes[0]).size, _radius = _sizeRem / 2, elementId = (0, import_react.useId)(), [arrowPosition, setArrowPosition] = (0, import_react.useState)(animateArrowFrom || arrowPositionProp || "inside"), [imageFailed, setImageFailed] = (0, import_react.useState)(false), imageId = `avatar-image-${elementId}`;
  let t3, t4;
  $3[13] !== arrowPosition || $3[14] !== arrowPositionProp ? (t3 = () => {
    if (arrowPosition === arrowPositionProp)
      return;
    const raf = requestAnimationFrame(() => setArrowPosition(arrowPositionProp));
    return () => cancelAnimationFrame(raf);
  }, t4 = [arrowPosition, arrowPositionProp], $3[13] = arrowPosition, $3[14] = arrowPositionProp, $3[15] = t3, $3[16] = t4) : (t3 = $3[15], t4 = $3[16]), (0, import_react.useEffect)(t3, t4);
  let t5, t6;
  $3[17] !== src ? (t5 = () => {
    src && setImageFailed(false);
  }, t6 = [src], $3[17] = src, $3[18] = t5, $3[19] = t6) : (t5 = $3[18], t6 = $3[19]), (0, import_react.useEffect)(t5, t6);
  let t7;
  $3[20] !== onImageLoadError ? (t7 = () => {
    setImageFailed(true), onImageLoadError && onImageLoadError(new Error("Avatar: the image failed to load"));
  }, $3[20] = onImageLoadError, $3[21] = t7) : t7 = $3[21];
  const handleImageError = t7, T0 = StyledAvatar, t8 = typeof as == "string" ? as : void 0, t9 = "Avatar";
  let t10;
  $3[22] !== color2 ? (t10 = (0, import_jsx_runtime.jsx)(Arrow$1, { children: (0, import_jsx_runtime.jsx)("svg", { width: "11", height: "7", viewBox: "0 0 11 7", fill: "none", children: (0, import_jsx_runtime.jsx)("path", { d: "M6.67948 1.50115L11 7L0 7L4.32052 1.50115C4.92109 0.736796 6.07891 0.736795 6.67948 1.50115Z", fill: color2 }) }) }), $3[22] = color2, $3[23] = t10) : t10 = $3[23];
  let t11;
  $3[24] !== __unstable_hideInnerStroke || $3[25] !== _radius || $3[26] !== _sizeRem || $3[27] !== handleImageError || $3[28] !== imageFailed || $3[29] !== imageId || $3[30] !== src ? (t11 = !imageFailed && src && (0, import_jsx_runtime.jsxs)(AvatarImage, { viewBox: `0 0 ${_sizeRem} ${_sizeRem}`, fill: "none", children: [
    (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsx)("pattern", { id: imageId, patternContentUnits: "objectBoundingBox", width: "1", height: "1", children: (0, import_jsx_runtime.jsx)("image", { href: src, width: "1", height: "1", onError: handleImageError }) }) }),
    (0, import_jsx_runtime.jsx)("circle", { cx: _radius, cy: _radius, r: _radius, fill: `url(#${imageId})` }),
    !__unstable_hideInnerStroke && (0, import_jsx_runtime.jsx)(BgStroke, { cx: _radius, cy: _radius, rx: _radius, ry: _radius, vectorEffect: "non-scaling-stroke" }),
    (0, import_jsx_runtime.jsx)(Stroke, { cx: _radius, cy: _radius, rx: _radius, ry: _radius, vectorEffect: "non-scaling-stroke" })
  ] }), $3[24] = __unstable_hideInnerStroke, $3[25] = _radius, $3[26] = _sizeRem, $3[27] = handleImageError, $3[28] = imageFailed, $3[29] = imageId, $3[30] = src, $3[31] = t11) : t11 = $3[31];
  const t12 = (imageFailed || !src) && initials && (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsx)(Initials, { children: (0, import_jsx_runtime.jsx)(InitialsLabel, { forwardedAs: "span", size: size2.map(_temp$a), weight: "medium", children: initials }) }) });
  let t13;
  return $3[32] !== T0 || $3[33] !== arrowPosition || $3[34] !== as || $3[35] !== color2 || $3[36] !== ref || $3[37] !== restProps || $3[38] !== size2 || $3[39] !== status || $3[40] !== t10 || $3[41] !== t11 || $3[42] !== t12 || $3[43] !== t8 || $3[44] !== title ? (t13 = (0, import_jsx_runtime.jsxs)(T0, { as, "data-as": t8, "data-ui": t9, ...restProps, $color: color2, $size: size2, "aria-label": title, "data-arrow-position": arrowPosition, "data-status": status, ref, title, children: [
    t10,
    t11,
    t12
  ] }), $3[32] = T0, $3[33] = arrowPosition, $3[34] = as, $3[35] = color2, $3[36] = ref, $3[37] = restProps, $3[38] = size2, $3[39] = status, $3[40] = t10, $3[41] = t11, $3[42] = t12, $3[43] = t8, $3[44] = title, $3[45] = t13) : t13 = $3[45], t13;
});
Avatar.displayName = "ForwardRef(Avatar)";
function _temp$a(s3) {
  return s3 === 1 ? 1 : s3 === 2 ? 3 : s3 === 3 ? 5 : 0;
}
function _responsiveAvatarCounterSizeStyle(props) {
  const {
    avatar,
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2];
    return avatarSize ? {
      borderRadius: rem(avatarSize.size / 2),
      minWidth: rem(avatarSize.size),
      height: rem(avatarSize.size)
    } : EMPTY_RECORD;
  });
}
function _avatarCounterBaseStyle(props) {
  const {
    space
  } = getTheme_v2(props.theme);
  return lt`
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    user-select: none;
    color: inherit;
    color: var(--card-fg-color);
    background: var(--card-bg-color);
    box-shadow:
      0 0 0 1px var(--card-bg-color),
      inset 0 0 0 1px var(--card-hairline-hard-color);
    padding: 0 ${rem(space[2])};

    &:not([hidden]) {
      display: flex;
    }
  `;
}
var StyledAvatarCounter = dt.div.withConfig({
  displayName: "StyledAvatarCounter",
  componentId: "sc-1ydx86y-0"
})(_responsiveAvatarCounterSizeStyle, _avatarCounterBaseStyle);
var AvatarCounter = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(20), {
    count,
    size: t0
  } = props, sizeProp = t0 === void 0 ? 1 : t0;
  let T0, T1, t1, t22, t3, t4, t5;
  if ($3[0] !== ref || $3[1] !== sizeProp) {
    const size2 = _getArrayProp(sizeProp);
    T1 = StyledAvatarCounter, t3 = size2, t4 = "AvatarCounter", t5 = ref, T0 = Label, t1 = "span", t22 = size2.map(_temp$9), $3[0] = ref, $3[1] = sizeProp, $3[2] = T0, $3[3] = T1, $3[4] = t1, $3[5] = t22, $3[6] = t3, $3[7] = t4, $3[8] = t5;
  } else
    T0 = $3[2], T1 = $3[3], t1 = $3[4], t22 = $3[5], t3 = $3[6], t4 = $3[7], t5 = $3[8];
  let t6;
  $3[9] !== T0 || $3[10] !== count || $3[11] !== t1 || $3[12] !== t22 ? (t6 = (0, import_jsx_runtime.jsx)(T0, { as: t1, size: t22, weight: "medium", children: count }), $3[9] = T0, $3[10] = count, $3[11] = t1, $3[12] = t22, $3[13] = t6) : t6 = $3[13];
  let t7;
  return $3[14] !== T1 || $3[15] !== t3 || $3[16] !== t4 || $3[17] !== t5 || $3[18] !== t6 ? (t7 = (0, import_jsx_runtime.jsx)(T1, { $size: t3, "data-ui": t4, ref: t5, children: t6 }), $3[14] = T1, $3[15] = t3, $3[16] = t4, $3[17] = t5, $3[18] = t6, $3[19] = t7) : t7 = $3[19], t7;
});
AvatarCounter.displayName = "ForwardRef(AvatarCounter)";
function _temp$9(s3) {
  return s3 === 1 ? 1 : s3 === 2 ? 3 : s3 === 3 ? 5 : 0;
}
var BASE_STYLES = lt`
  white-space: nowrap;

  & > div {
    vertical-align: top;

    &:not([hidden]) {
      display: inline-block;
    }
  }
`;
function avatarStackStyle() {
  return BASE_STYLES;
}
function responsiveAvatarStackSizeStyle(props) {
  const {
    avatar,
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2];
    return avatarSize ? {
      "& > div + div": {
        marginLeft: rem(avatarSize.distance)
      }
    } : EMPTY_RECORD;
  });
}
var StyledAvatarStack = dt.div.withConfig({
  displayName: "StyledAvatarStack",
  componentId: "sc-cysmbb-0"
})(responsiveAvatarStackSizeStyle, avatarStackStyle);
var AvatarStack = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(38);
  let childrenProp, restProps, t0, t1;
  $3[0] !== props ? ({
    children: childrenProp,
    maxLength: t0,
    size: t1,
    ...restProps
  } = props, $3[0] = props, $3[1] = childrenProp, $3[2] = restProps, $3[3] = t0, $3[4] = t1) : (childrenProp = $3[1], restProps = $3[2], t0 = $3[3], t1 = $3[4]);
  const maxLengthProp = t0 === void 0 ? 4 : t0, sizeProp = t1 === void 0 ? 1 : t1;
  let T0, t22, t3, t4, t5, t6, t7, t8;
  if ($3[5] !== childrenProp || $3[6] !== maxLengthProp || $3[7] !== ref || $3[8] !== restProps || $3[9] !== sizeProp) {
    const children = import_react.Children.toArray(childrenProp).filter(import_react.isValidElement), maxLength = Math.max(maxLengthProp, 0);
    let t92;
    $3[18] !== sizeProp ? (t92 = _getArrayProp(sizeProp), $3[18] = sizeProp, $3[19] = t92) : t92 = $3[19];
    const size2 = t92, len = children.length, visibleCount = maxLength - 1, extraCount = len - visibleCount, visibleChildren = extraCount > 1 ? children.slice(extraCount, len) : children;
    T0 = StyledAvatarStack, t22 = "AvatarStack", t3 = restProps, t4 = ref, t5 = size2, $3[20] !== len || $3[21] !== size2 ? (t6 = len === 0 && (0, import_jsx_runtime.jsx)("div", { children: (0, import_jsx_runtime.jsx)(AvatarCounter, { count: len, size: size2 }) }), $3[20] = len, $3[21] = size2, $3[22] = t6) : t6 = $3[22], $3[23] !== extraCount || $3[24] !== len || $3[25] !== size2 ? (t7 = len !== 0 && extraCount > 1 && (0, import_jsx_runtime.jsx)("div", { children: (0, import_jsx_runtime.jsx)(AvatarCounter, { count: extraCount, size: size2 }) }), $3[23] = extraCount, $3[24] = len, $3[25] = size2, $3[26] = t7) : t7 = $3[26];
    let t10;
    $3[27] !== size2 ? (t10 = (child, childIndex) => (0, import_jsx_runtime.jsx)("div", { children: (0, import_react.cloneElement)(child, {
      size: size2
    }) }, String(childIndex)), $3[27] = size2, $3[28] = t10) : t10 = $3[28], t8 = visibleChildren.map(t10), $3[5] = childrenProp, $3[6] = maxLengthProp, $3[7] = ref, $3[8] = restProps, $3[9] = sizeProp, $3[10] = T0, $3[11] = t22, $3[12] = t3, $3[13] = t4, $3[14] = t5, $3[15] = t6, $3[16] = t7, $3[17] = t8;
  } else
    T0 = $3[10], t22 = $3[11], t3 = $3[12], t4 = $3[13], t5 = $3[14], t6 = $3[15], t7 = $3[16], t8 = $3[17];
  let t9;
  return $3[29] !== T0 || $3[30] !== t22 || $3[31] !== t3 || $3[32] !== t4 || $3[33] !== t5 || $3[34] !== t6 || $3[35] !== t7 || $3[36] !== t8 ? (t9 = (0, import_jsx_runtime.jsxs)(T0, { "data-ui": t22, ...t3, ref: t4, $size: t5, children: [
    t6,
    t7,
    t8
  ] }), $3[29] = T0, $3[30] = t22, $3[31] = t3, $3[32] = t4, $3[33] = t5, $3[34] = t6, $3[35] = t7, $3[36] = t8, $3[37] = t9) : t9 = $3[37], t9;
});
AvatarStack.displayName = "ForwardRef(AvatarStack)";
var StyledBox = dt.div.withConfig({
  displayName: "StyledBox",
  componentId: "sc-1hhky9f-0"
})(boxStyle, flexItemStyle, responsiveBoxStyle, responsiveGridItemStyle, responsiveMarginStyle, responsivePaddingStyle);
var Box = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(109);
  let column2, columnEnd, columnStart, flex, height, marginBottom, marginLeft, marginRight, marginTop, marginX, marginY, overflow, paddingBottom, paddingLeft, paddingRight, paddingTop, paddingX, paddingY, restProps, row, rowEnd, rowStart, sizing, t0, t1, t22, t3;
  $3[0] !== props ? ({
    as: t0,
    column: column2,
    columnStart,
    columnEnd,
    display: t1,
    flex,
    height,
    margin: t22,
    marginX,
    marginY,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    overflow,
    padding: t3,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    row,
    rowStart,
    rowEnd,
    sizing,
    ...restProps
  } = props, $3[0] = props, $3[1] = column2, $3[2] = columnEnd, $3[3] = columnStart, $3[4] = flex, $3[5] = height, $3[6] = marginBottom, $3[7] = marginLeft, $3[8] = marginRight, $3[9] = marginTop, $3[10] = marginX, $3[11] = marginY, $3[12] = overflow, $3[13] = paddingBottom, $3[14] = paddingLeft, $3[15] = paddingRight, $3[16] = paddingTop, $3[17] = paddingX, $3[18] = paddingY, $3[19] = restProps, $3[20] = row, $3[21] = rowEnd, $3[22] = rowStart, $3[23] = sizing, $3[24] = t0, $3[25] = t1, $3[26] = t22, $3[27] = t3) : (column2 = $3[1], columnEnd = $3[2], columnStart = $3[3], flex = $3[4], height = $3[5], marginBottom = $3[6], marginLeft = $3[7], marginRight = $3[8], marginTop = $3[9], marginX = $3[10], marginY = $3[11], overflow = $3[12], paddingBottom = $3[13], paddingLeft = $3[14], paddingRight = $3[15], paddingTop = $3[16], paddingX = $3[17], paddingY = $3[18], restProps = $3[19], row = $3[20], rowEnd = $3[21], rowStart = $3[22], sizing = $3[23], t0 = $3[24], t1 = $3[25], t22 = $3[26], t3 = $3[27]);
  const asProp = t0 === void 0 ? "div" : t0, display = t1 === void 0 ? "block" : t1, margin = t22 === void 0 ? 0 : t22, padding = t3 === void 0 ? 0 : t3, t4 = typeof asProp == "string" ? asProp : void 0;
  let t5;
  $3[28] !== column2 ? (t5 = _getArrayProp(column2), $3[28] = column2, $3[29] = t5) : t5 = $3[29];
  let t6;
  $3[30] !== columnStart ? (t6 = _getArrayProp(columnStart), $3[30] = columnStart, $3[31] = t6) : t6 = $3[31];
  let t7;
  $3[32] !== columnEnd ? (t7 = _getArrayProp(columnEnd), $3[32] = columnEnd, $3[33] = t7) : t7 = $3[33];
  let t8;
  $3[34] !== display ? (t8 = _getArrayProp(display), $3[34] = display, $3[35] = t8) : t8 = $3[35];
  let t9;
  $3[36] !== flex ? (t9 = _getArrayProp(flex), $3[36] = flex, $3[37] = t9) : t9 = $3[37];
  let t10;
  $3[38] !== height ? (t10 = _getArrayProp(height), $3[38] = height, $3[39] = t10) : t10 = $3[39];
  let t11;
  $3[40] !== margin ? (t11 = _getArrayProp(margin), $3[40] = margin, $3[41] = t11) : t11 = $3[41];
  let t12;
  $3[42] !== marginX ? (t12 = _getArrayProp(marginX), $3[42] = marginX, $3[43] = t12) : t12 = $3[43];
  let t13;
  $3[44] !== marginY ? (t13 = _getArrayProp(marginY), $3[44] = marginY, $3[45] = t13) : t13 = $3[45];
  let t14;
  $3[46] !== marginTop ? (t14 = _getArrayProp(marginTop), $3[46] = marginTop, $3[47] = t14) : t14 = $3[47];
  let t15;
  $3[48] !== marginRight ? (t15 = _getArrayProp(marginRight), $3[48] = marginRight, $3[49] = t15) : t15 = $3[49];
  let t16;
  $3[50] !== marginBottom ? (t16 = _getArrayProp(marginBottom), $3[50] = marginBottom, $3[51] = t16) : t16 = $3[51];
  let t17;
  $3[52] !== marginLeft ? (t17 = _getArrayProp(marginLeft), $3[52] = marginLeft, $3[53] = t17) : t17 = $3[53];
  let t18;
  $3[54] !== overflow ? (t18 = _getArrayProp(overflow), $3[54] = overflow, $3[55] = t18) : t18 = $3[55];
  let t19;
  $3[56] !== padding ? (t19 = _getArrayProp(padding), $3[56] = padding, $3[57] = t19) : t19 = $3[57];
  let t20;
  $3[58] !== paddingX ? (t20 = _getArrayProp(paddingX), $3[58] = paddingX, $3[59] = t20) : t20 = $3[59];
  let t21;
  $3[60] !== paddingY ? (t21 = _getArrayProp(paddingY), $3[60] = paddingY, $3[61] = t21) : t21 = $3[61];
  let t222;
  $3[62] !== paddingTop ? (t222 = _getArrayProp(paddingTop), $3[62] = paddingTop, $3[63] = t222) : t222 = $3[63];
  let t23;
  $3[64] !== paddingRight ? (t23 = _getArrayProp(paddingRight), $3[64] = paddingRight, $3[65] = t23) : t23 = $3[65];
  let t24;
  $3[66] !== paddingBottom ? (t24 = _getArrayProp(paddingBottom), $3[66] = paddingBottom, $3[67] = t24) : t24 = $3[67];
  let t25;
  $3[68] !== paddingLeft ? (t25 = _getArrayProp(paddingLeft), $3[68] = paddingLeft, $3[69] = t25) : t25 = $3[69];
  let t26;
  $3[70] !== row ? (t26 = _getArrayProp(row), $3[70] = row, $3[71] = t26) : t26 = $3[71];
  let t27;
  $3[72] !== rowStart ? (t27 = _getArrayProp(rowStart), $3[72] = rowStart, $3[73] = t27) : t27 = $3[73];
  let t28;
  $3[74] !== rowEnd ? (t28 = _getArrayProp(rowEnd), $3[74] = rowEnd, $3[75] = t28) : t28 = $3[75];
  let t29;
  $3[76] !== sizing ? (t29 = _getArrayProp(sizing), $3[76] = sizing, $3[77] = t29) : t29 = $3[77];
  let t30;
  return $3[78] !== asProp || $3[79] !== props.children || $3[80] !== ref || $3[81] !== restProps || $3[82] !== t10 || $3[83] !== t11 || $3[84] !== t12 || $3[85] !== t13 || $3[86] !== t14 || $3[87] !== t15 || $3[88] !== t16 || $3[89] !== t17 || $3[90] !== t18 || $3[91] !== t19 || $3[92] !== t20 || $3[93] !== t21 || $3[94] !== t222 || $3[95] !== t23 || $3[96] !== t24 || $3[97] !== t25 || $3[98] !== t26 || $3[99] !== t27 || $3[100] !== t28 || $3[101] !== t29 || $3[102] !== t4 || $3[103] !== t5 || $3[104] !== t6 || $3[105] !== t7 || $3[106] !== t8 || $3[107] !== t9 ? (t30 = (0, import_jsx_runtime.jsx)(StyledBox, { "data-as": t4, "data-ui": "Box", ...restProps, $column: t5, $columnStart: t6, $columnEnd: t7, $display: t8, $flex: t9, $height: t10, $margin: t11, $marginX: t12, $marginY: t13, $marginTop: t14, $marginRight: t15, $marginBottom: t16, $marginLeft: t17, $overflow: t18, $padding: t19, $paddingX: t20, $paddingY: t21, $paddingTop: t222, $paddingRight: t23, $paddingBottom: t24, $paddingLeft: t25, $row: t26, $rowStart: t27, $rowEnd: t28, $sizing: t29, as: asProp, ref, children: props.children }), $3[78] = asProp, $3[79] = props.children, $3[80] = ref, $3[81] = restProps, $3[82] = t10, $3[83] = t11, $3[84] = t12, $3[85] = t13, $3[86] = t14, $3[87] = t15, $3[88] = t16, $3[89] = t17, $3[90] = t18, $3[91] = t19, $3[92] = t20, $3[93] = t21, $3[94] = t222, $3[95] = t23, $3[96] = t24, $3[97] = t25, $3[98] = t26, $3[99] = t27, $3[100] = t28, $3[101] = t29, $3[102] = t4, $3[103] = t5, $3[104] = t6, $3[105] = t7, $3[106] = t8, $3[107] = t9, $3[108] = t30) : t30 = $3[108], t30;
});
Box.displayName = "ForwardRef(Box)";
function textBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props, {
    font
  } = getTheme_v2(props.theme);
  return lt`
    color: var(--card-fg-color);

    ${$accent && lt`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && lt`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
      background-color: var(--card-code-bg-color);
      color: var(--card-code-fg-color);
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
      color: var(--card-link-color);
      outline: none;

      @media (hover: hover) {
        &:hover {
          text-decoration: underline;
        }
      }

      &:focus {
        box-shadow:
          0 0 0 1px var(--card-bg-color),
          0 0 0 3px var(--card-focus-ring-color);
      }

      &:focus:not(:focus-visible) {
        box-shadow: none;
      }
    }

    & strong {
      font-weight: ${font.text.weights.bold};
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
      color: var(--card-icon-color);

      & path {
        vector-effect: non-scaling-stroke !important;
      }
    }
  `;
}
var StyledText = dt.div.withConfig({
  displayName: "StyledText",
  componentId: "sc-11ov82j-0"
})(responsiveTextFont, responsiveTextAlignStyle, textBaseStyle);
var Text = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(26);
  let align, childrenProp, restProps, t0, t1, t22, textOverflow, weight;
  $3[0] !== props ? ({
    accent: t0,
    align,
    children: childrenProp,
    muted: t1,
    size: t22,
    textOverflow,
    weight,
    ...restProps
  } = props, $3[0] = props, $3[1] = align, $3[2] = childrenProp, $3[3] = restProps, $3[4] = t0, $3[5] = t1, $3[6] = t22, $3[7] = textOverflow, $3[8] = weight) : (align = $3[1], childrenProp = $3[2], restProps = $3[3], t0 = $3[4], t1 = $3[5], t22 = $3[6], textOverflow = $3[7], weight = $3[8]);
  const accent = t0 === void 0 ? false : t0, muted = t1 === void 0 ? false : t1, size2 = t22 === void 0 ? 2 : t22;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    let t32;
    $3[9] !== children ? (t32 = (0, import_jsx_runtime.jsx)(SpanWithTextOverflow, { children }), $3[9] = children, $3[10] = t32) : t32 = $3[10], children = t32;
  }
  let t3;
  $3[11] !== align ? (t3 = _getArrayProp(align), $3[11] = align, $3[12] = t3) : t3 = $3[12];
  let t4;
  $3[13] !== size2 ? (t4 = _getArrayProp(size2), $3[13] = size2, $3[14] = t4) : t4 = $3[14];
  let t5;
  $3[15] !== children ? (t5 = (0, import_jsx_runtime.jsx)("span", { children }), $3[15] = children, $3[16] = t5) : t5 = $3[16];
  let t6;
  return $3[17] !== accent || $3[18] !== muted || $3[19] !== ref || $3[20] !== restProps || $3[21] !== t3 || $3[22] !== t4 || $3[23] !== t5 || $3[24] !== weight ? (t6 = (0, import_jsx_runtime.jsx)(StyledText, { "data-ui": "Text", ...restProps, $accent: accent, $align: t3, $muted: muted, ref, $size: t4, $weight: weight, children: t5 }), $3[17] = accent, $3[18] = muted, $3[19] = ref, $3[20] = restProps, $3[21] = t3, $3[22] = t4, $3[23] = t5, $3[24] = weight, $3[25] = t6) : t6 = $3[25], t6;
});
Text.displayName = "ForwardRef(Text)";
function badgeStyle(props) {
  const {
    $tone
  } = props;
  return {
    "--card-bg-color": `var(--card-badge-${$tone}-bg-color)`,
    "--card-fg-color": `var(--card-badge-${$tone}-fg-color)`,
    backgroundColor: "var(--card-bg-color)",
    cursor: "default",
    "&:not([hidden])": {
      display: "inline-block",
      verticalAlign: "top"
    }
  };
}
var StyledBadge = dt(Box).withConfig({
  displayName: "StyledBadge",
  componentId: "sc-5u140l-0"
})(responsiveRadiusStyle, badgeStyle);
var Badge = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(21);
  let children, restProps, t0, t1, t22, t3;
  if ($3[0] !== props) {
    const {
      children: t42,
      fontSize: t52,
      mode: _deprecated_mode,
      padding: t62,
      radius: t72,
      tone: t8,
      ...t9
    } = props;
    children = t42, t0 = t52, t1 = t62, t22 = t72, t3 = t8, restProps = t9, $3[0] = props, $3[1] = children, $3[2] = restProps, $3[3] = t0, $3[4] = t1, $3[5] = t22, $3[6] = t3;
  } else
    children = $3[1], restProps = $3[2], t0 = $3[3], t1 = $3[4], t22 = $3[5], t3 = $3[6];
  const fontSize2 = t0 === void 0 ? 1 : t0, padding = t1 === void 0 ? 1 : t1, radius = t22 === void 0 ? "full" : t22, tone = t3 === void 0 ? "default" : t3;
  let t4;
  $3[7] !== radius ? (t4 = _getArrayProp(radius), $3[7] = radius, $3[8] = t4) : t4 = $3[8];
  let t5;
  $3[9] !== padding ? (t5 = _getArrayProp(padding), $3[9] = padding, $3[10] = t5) : t5 = $3[10];
  let t6;
  $3[11] !== children || $3[12] !== fontSize2 ? (t6 = (0, import_jsx_runtime.jsx)(Text, { size: fontSize2, children }), $3[11] = children, $3[12] = fontSize2, $3[13] = t6) : t6 = $3[13];
  let t7;
  return $3[14] !== ref || $3[15] !== restProps || $3[16] !== t4 || $3[17] !== t5 || $3[18] !== t6 || $3[19] !== tone ? (t7 = (0, import_jsx_runtime.jsx)(StyledBadge, { "data-ui": "Badge", ...restProps, $tone: tone, $radius: t4, padding: t5, ref, children: t6 }), $3[14] = ref, $3[15] = restProps, $3[16] = t4, $3[17] = t5, $3[18] = t6, $3[19] = tone, $3[20] = t7) : t7 = $3[20], t7;
});
Badge.displayName = "ForwardRef(Badge)";
var StyledFlex = dt(Box).withConfig({
  displayName: "StyledFlex",
  componentId: "sc-oxesg3-0"
})(flexItemStyle, responsiveFlexStyle);
var Flex = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(27);
  let align, as, gap, justify, restProps, t0, wrap;
  $3[0] !== props ? ({
    align,
    as,
    direction: t0,
    gap,
    justify,
    wrap,
    ...restProps
  } = props, $3[0] = props, $3[1] = align, $3[2] = as, $3[3] = gap, $3[4] = justify, $3[5] = restProps, $3[6] = t0, $3[7] = wrap) : (align = $3[1], as = $3[2], gap = $3[3], justify = $3[4], restProps = $3[5], t0 = $3[6], wrap = $3[7]);
  const direction = t0 === void 0 ? "row" : t0;
  let t1;
  $3[8] !== align ? (t1 = _getArrayProp(align), $3[8] = align, $3[9] = t1) : t1 = $3[9];
  let t22;
  $3[10] !== direction ? (t22 = _getArrayProp(direction), $3[10] = direction, $3[11] = t22) : t22 = $3[11];
  let t3;
  $3[12] !== gap ? (t3 = _getArrayProp(gap), $3[12] = gap, $3[13] = t3) : t3 = $3[13];
  let t4;
  $3[14] !== justify ? (t4 = _getArrayProp(justify), $3[14] = justify, $3[15] = t4) : t4 = $3[15];
  let t5;
  $3[16] !== wrap ? (t5 = _getArrayProp(wrap), $3[16] = wrap, $3[17] = t5) : t5 = $3[17];
  let t6;
  return $3[18] !== as || $3[19] !== ref || $3[20] !== restProps || $3[21] !== t1 || $3[22] !== t22 || $3[23] !== t3 || $3[24] !== t4 || $3[25] !== t5 ? (t6 = (0, import_jsx_runtime.jsx)(StyledFlex, { "data-ui": "Flex", ...restProps, $align: t1, $direction: t22, $gap: t3, $justify: t4, $wrap: t5, forwardedAs: as, ref }), $3[18] = as, $3[19] = ref, $3[20] = restProps, $3[21] = t1, $3[22] = t22, $3[23] = t3, $3[24] = t4, $3[25] = t5, $3[26] = t6) : t6 = $3[26], t6;
});
Flex.displayName = "ForwardRef(Flex)";
var rotate = mt`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`;
var StyledSpinner = dt(Text).withConfig({
  displayName: "StyledSpinner",
  componentId: "sc-124hnd0-0"
})`& > span > svg{animation:${rotate} 500ms linear infinite;}`;
var Spinner = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(4);
  let t0;
  $3[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = (0, import_jsx_runtime.jsx)(SpinnerIcon, {}), $3[0] = t0) : t0 = $3[0];
  let t1;
  return $3[1] !== props || $3[2] !== ref ? (t1 = (0, import_jsx_runtime.jsx)(StyledSpinner, { "data-ui": "Spinner", ...props, ref, children: t0 }), $3[1] = props, $3[2] = ref, $3[3] = t1) : t1 = $3[3], t1;
});
Spinner.displayName = "ForwardRef(Spinner)";
function _cardColorStyle(base, color2, checkered = false) {
  return {
    // from base
    "--card-backdrop-color": base.backdrop,
    "--card-focus-ring-color": base.focusRing,
    "--card-shadow-outline-color": base.shadow.outline,
    "--card-shadow-umbra-color": base.shadow.umbra,
    "--card-shadow-penumbra-color": base.shadow.penumbra,
    "--card-shadow-ambient-color": base.shadow.ambient,
    // from state
    "--card-accent-fg-color": color2.accent.fg,
    "--card-avatar-gray-bg-color": color2.avatar.gray.bg,
    "--card-avatar-gray-fg-color": color2.avatar.gray.fg,
    "--card-avatar-blue-bg-color": color2.avatar.blue.bg,
    "--card-avatar-blue-fg-color": color2.avatar.blue.fg,
    "--card-avatar-purple-bg-color": color2.avatar.purple.bg,
    "--card-avatar-purple-fg-color": color2.avatar.purple.fg,
    "--card-avatar-magenta-bg-color": color2.avatar.magenta.bg,
    "--card-avatar-magenta-fg-color": color2.avatar.magenta.fg,
    "--card-avatar-red-bg-color": color2.avatar.red.bg,
    "--card-avatar-red-fg-color": color2.avatar.red.fg,
    "--card-avatar-orange-bg-color": color2.avatar.orange.bg,
    "--card-avatar-orange-fg-color": color2.avatar.orange.fg,
    "--card-avatar-yellow-bg-color": color2.avatar.yellow.bg,
    "--card-avatar-yellow-fg-color": color2.avatar.yellow.fg,
    "--card-avatar-green-bg-color": color2.avatar.green.bg,
    "--card-avatar-green-fg-color": color2.avatar.green.fg,
    "--card-avatar-cyan-bg-color": color2.avatar.cyan.bg,
    "--card-avatar-cyan-fg-color": color2.avatar.cyan.fg,
    "--card-bg-color": color2.bg,
    "--card-bg-image": checkered ? `repeating-conic-gradient(${color2.bg} 0% 25%, ${color2.muted.bg} 0% 50%)` : void 0,
    "--card-border-color": color2.border,
    "--card-badge-default-bg-color": color2.badge.default.bg,
    "--card-badge-default-dot-color": color2.badge.default.dot,
    "--card-badge-default-fg-color": color2.badge.default.fg,
    "--card-badge-default-icon-color": color2.badge.default.icon,
    "--card-badge-neutral-bg-color": color2.badge.neutral?.bg,
    "--card-badge-neutral-dot-color": color2.badge.neutral?.dot,
    "--card-badge-neutral-fg-color": color2.badge.neutral?.fg,
    "--card-badge-neutral-icon-color": color2.badge.neutral?.icon,
    "--card-badge-primary-bg-color": color2.badge.primary.bg,
    "--card-badge-primary-dot-color": color2.badge.primary.dot,
    "--card-badge-primary-fg-color": color2.badge.primary.fg,
    "--card-badge-primary-icon-color": color2.badge.primary.icon,
    "--card-badge-suggest-bg-color": color2.badge.suggest?.bg,
    "--card-badge-suggest-dot-color": color2.badge.suggest?.dot,
    "--card-badge-suggest-fg-color": color2.badge.suggest?.fg,
    "--card-badge-suggest-icon-color": color2.badge.suggest?.icon,
    "--card-badge-positive-bg-color": color2.badge.positive.bg,
    "--card-badge-positive-dot-color": color2.badge.positive.dot,
    "--card-badge-positive-fg-color": color2.badge.positive.fg,
    "--card-badge-positive-icon-color": color2.badge.positive.icon,
    "--card-badge-caution-bg-color": color2.badge.caution.bg,
    "--card-badge-caution-dot-color": color2.badge.caution.dot,
    "--card-badge-caution-fg-color": color2.badge.caution.fg,
    "--card-badge-caution-icon-color": color2.badge.caution.icon,
    "--card-badge-critical-bg-color": color2.badge.critical.bg,
    "--card-badge-critical-dot-color": color2.badge.critical.dot,
    "--card-badge-critical-fg-color": color2.badge.critical.fg,
    "--card-badge-critical-icon-color": color2.badge.critical.icon,
    "--card-code-bg-color": color2.code.bg,
    "--card-code-fg-color": color2.code.fg,
    "--card-fg-color": color2.fg,
    "--card-icon-color": color2.icon,
    "--card-kbd-bg-color": color2.kbd.bg,
    "--card-kbd-border-color": color2.kbd.border,
    "--card-kbd-fg-color": color2.kbd.fg,
    "--card-link-fg-color": color2.link.fg,
    "--card-muted-bg-color": color2.muted.bg,
    "--card-muted-fg-color": color2.muted.fg,
    "--card-skeleton-color-from": color2.skeleton.from,
    "--card-skeleton-color-to": color2.skeleton.to,
    // deprecated variables (kept for legacy)
    "--card-bg2-color": color2.muted.bg,
    "--card-link-color": color2.link.fg,
    "--card-hairline-soft-color": color2.border,
    "--card-hairline-hard-color": color2.border
  };
}
function buttonBaseStyles(props) {
  const {
    $width
  } = props, {
    style
  } = getTheme_v2(props.theme);
  return lt`
    ${style?.button};

    -webkit-font-smoothing: inherit;
    appearance: none;
    display: inline-flex;
    align-items: center;
    font: inherit;
    border: 0;
    outline: none;
    user-select: none;
    text-decoration: none;
    border: 0;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
    white-space: nowrap;
    text-align: left;
    position: relative;
    vertical-align: top;

    ${$width === "fill" && lt`
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    `}

    & > span {
      display: block;
      flex: 1;
      min-width: 0;
      border-radius: inherit;
    }

    &::-moz-focus-inner {
      border: 0;
      padding: 0;
    }
  `;
}
function combineBoxShadow(...boxShadows) {
  return boxShadows.filter(Boolean).join(",");
}
function buttonColorStyles(props) {
  const {
    $mode
  } = props, {
    button,
    color: baseColor,
    style
  } = getTheme_v2(props.theme), shadow = props.$mode === "ghost", mode = baseColor.button[$mode] || baseColor.button.default, color2 = mode[props.$tone] || mode.default, border2 = {
    width: button.border.width,
    color: "var(--card-border-color)"
  }, defaultBoxShadow = void 0;
  return [_cardColorStyle(baseColor, color2.enabled), {
    backgroundColor: "var(--card-bg-color)",
    color: "var(--card-fg-color)",
    boxShadow: focusRingBorderStyle(border2),
    '&:disabled, &[data-disabled="true"]': _cardColorStyle(baseColor, color2.disabled),
    "&:not([data-disabled='true'])": {
      boxShadow: combineBoxShadow(focusRingBorderStyle(border2), shadow ? defaultBoxShadow : void 0),
      "&:focus": {
        boxShadow: focusRingStyle({
          base: baseColor,
          border: {
            width: 2,
            color: baseColor.bg
          },
          focusRing: button.focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: combineBoxShadow(focusRingBorderStyle(border2), shadow ? defaultBoxShadow : void 0)
      },
      "@media (hover: hover)": {
        "&:hover": _cardColorStyle(baseColor, color2.hovered),
        "&:active": _cardColorStyle(baseColor, color2.pressed),
        "&[data-hovered]": _cardColorStyle(baseColor, color2.hovered)
      },
      "&[data-selected]": _cardColorStyle(baseColor, color2.pressed)
    }
  }, style?.button?.root].filter(Boolean);
}
var StyledButton = dt.button.withConfig({
  displayName: "StyledButton",
  componentId: "sc-aaekt4-0"
})(responsiveRadiusStyle, buttonBaseStyles, buttonColorStyles);
var LoadingBox = dt.div.withConfig({
  displayName: "LoadingBox",
  componentId: "sc-aaekt4-1"
})`position:absolute;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;background-color:var(--card-bg-color);border-radius:inherit;z-index:1;box-shadow:inherit;`;
var Button = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(86);
  let IconComponent, IconRightComponent, children, disabled, loading, paddingBottomProp, paddingLeftProp, paddingRightProp, paddingTopProp, paddingXProp, paddingYProp, restProps, selected, t0, t1, t22, t3, t4, t5, t6, t7, t8, text, textAlign, textWeight, width;
  $3[0] !== props ? ({
    children,
    disabled,
    fontSize: t0,
    icon: IconComponent,
    iconRight: IconRightComponent,
    justify: t1,
    loading,
    mode: t22,
    padding: t3,
    paddingX: paddingXProp,
    paddingY: paddingYProp,
    paddingTop: paddingTopProp,
    paddingBottom: paddingBottomProp,
    paddingLeft: paddingLeftProp,
    paddingRight: paddingRightProp,
    radius: t4,
    selected,
    space: t5,
    text,
    textAlign,
    textWeight,
    tone: t6,
    type: t7,
    muted: t8,
    width,
    ...restProps
  } = props, $3[0] = props, $3[1] = IconComponent, $3[2] = IconRightComponent, $3[3] = children, $3[4] = disabled, $3[5] = loading, $3[6] = paddingBottomProp, $3[7] = paddingLeftProp, $3[8] = paddingRightProp, $3[9] = paddingTopProp, $3[10] = paddingXProp, $3[11] = paddingYProp, $3[12] = restProps, $3[13] = selected, $3[14] = t0, $3[15] = t1, $3[16] = t22, $3[17] = t3, $3[18] = t4, $3[19] = t5, $3[20] = t6, $3[21] = t7, $3[22] = t8, $3[23] = text, $3[24] = textAlign, $3[25] = textWeight, $3[26] = width) : (IconComponent = $3[1], IconRightComponent = $3[2], children = $3[3], disabled = $3[4], loading = $3[5], paddingBottomProp = $3[6], paddingLeftProp = $3[7], paddingRightProp = $3[8], paddingTopProp = $3[9], paddingXProp = $3[10], paddingYProp = $3[11], restProps = $3[12], selected = $3[13], t0 = $3[14], t1 = $3[15], t22 = $3[16], t3 = $3[17], t4 = $3[18], t5 = $3[19], t6 = $3[20], t7 = $3[21], t8 = $3[22], text = $3[23], textAlign = $3[24], textWeight = $3[25], width = $3[26]);
  const fontSize2 = t0 === void 0 ? 1 : t0, justifyProp = t1 === void 0 ? "center" : t1, mode = t22 === void 0 ? "default" : t22, paddingProp = t3 === void 0 ? 3 : t3, radiusProp = t4 === void 0 ? 2 : t4, spaceProp = t5 === void 0 ? 3 : t5, tone = t6 === void 0 ? "default" : t6, type = t7 === void 0 ? "button" : t7, muted = t8 === void 0 ? false : t8, {
    button
  } = useTheme_v2();
  let t9;
  $3[27] !== justifyProp ? (t9 = _getArrayProp(justifyProp), $3[27] = justifyProp, $3[28] = t9) : t9 = $3[28];
  const justify = t9;
  let t10;
  $3[29] !== paddingProp ? (t10 = _getArrayProp(paddingProp), $3[29] = paddingProp, $3[30] = t10) : t10 = $3[30];
  const padding = t10;
  let t11;
  $3[31] !== paddingXProp ? (t11 = _getArrayProp(paddingXProp), $3[31] = paddingXProp, $3[32] = t11) : t11 = $3[32];
  const paddingX = t11;
  let t12;
  $3[33] !== paddingYProp ? (t12 = _getArrayProp(paddingYProp), $3[33] = paddingYProp, $3[34] = t12) : t12 = $3[34];
  const paddingY = t12;
  let t13;
  $3[35] !== paddingTopProp ? (t13 = _getArrayProp(paddingTopProp), $3[35] = paddingTopProp, $3[36] = t13) : t13 = $3[36];
  const paddingTop = t13;
  let t14;
  $3[37] !== paddingBottomProp ? (t14 = _getArrayProp(paddingBottomProp), $3[37] = paddingBottomProp, $3[38] = t14) : t14 = $3[38];
  const paddingBottom = t14;
  let t15;
  $3[39] !== paddingLeftProp ? (t15 = _getArrayProp(paddingLeftProp), $3[39] = paddingLeftProp, $3[40] = t15) : t15 = $3[40];
  const paddingLeft = t15;
  let t16;
  $3[41] !== paddingRightProp ? (t16 = _getArrayProp(paddingRightProp), $3[41] = paddingRightProp, $3[42] = t16) : t16 = $3[42];
  const paddingRight = t16;
  let t17;
  $3[43] !== radiusProp ? (t17 = _getArrayProp(radiusProp), $3[43] = radiusProp, $3[44] = t17) : t17 = $3[44];
  const radius = t17;
  let t18;
  $3[45] !== spaceProp ? (t18 = _getArrayProp(spaceProp), $3[45] = spaceProp, $3[46] = t18) : t18 = $3[46];
  const space = t18;
  let t19;
  $3[47] !== padding || $3[48] !== paddingBottom || $3[49] !== paddingLeft || $3[50] !== paddingRight || $3[51] !== paddingTop || $3[52] !== paddingX || $3[53] !== paddingY ? (t19 = {
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight
  }, $3[47] = padding, $3[48] = paddingBottom, $3[49] = paddingLeft, $3[50] = paddingRight, $3[51] = paddingTop, $3[52] = paddingX, $3[53] = paddingY, $3[54] = t19) : t19 = $3[54];
  const boxProps = t19, t20 = !!(loading || disabled), t21 = selected ? "" : void 0, t222 = !!(loading || disabled);
  let t23;
  $3[55] !== loading ? (t23 = !!loading && (0, import_jsx_runtime.jsx)(LoadingBox, { children: (0, import_jsx_runtime.jsx)(Spinner, {}) }), $3[55] = loading, $3[56] = t23) : t23 = $3[56];
  let t24;
  $3[57] !== IconComponent || $3[58] !== IconRightComponent || $3[59] !== boxProps || $3[60] !== button || $3[61] !== fontSize2 || $3[62] !== justify || $3[63] !== muted || $3[64] !== space || $3[65] !== text || $3[66] !== textAlign || $3[67] !== textWeight ? (t24 = (IconComponent || text || IconRightComponent) && (0, import_jsx_runtime.jsx)(Box, { as: "span", ...boxProps, children: (0, import_jsx_runtime.jsxs)(Flex, { as: "span", justify, gap: space, children: [
    IconComponent && (0, import_jsx_runtime.jsxs)(Text, { size: fontSize2, children: [
      (0, import_react.isValidElement)(IconComponent) && IconComponent,
      (0, import_react_is.isValidElementType)(IconComponent) && (0, import_jsx_runtime.jsx)(IconComponent, {})
    ] }),
    text && (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(Text, { muted, align: textAlign, size: fontSize2, textOverflow: "ellipsis", weight: textWeight ?? button.textWeight, children: text }) }),
    IconRightComponent && (0, import_jsx_runtime.jsxs)(Text, { size: fontSize2, children: [
      (0, import_react.isValidElement)(IconRightComponent) && IconRightComponent,
      (0, import_react_is.isValidElementType)(IconRightComponent) && (0, import_jsx_runtime.jsx)(IconRightComponent, {})
    ] })
  ] }) }), $3[57] = IconComponent, $3[58] = IconRightComponent, $3[59] = boxProps, $3[60] = button, $3[61] = fontSize2, $3[62] = justify, $3[63] = muted, $3[64] = space, $3[65] = text, $3[66] = textAlign, $3[67] = textWeight, $3[68] = t24) : t24 = $3[68];
  let t25;
  $3[69] !== boxProps || $3[70] !== children ? (t25 = children && (0, import_jsx_runtime.jsx)(Box, { as: "span", ...boxProps, children }), $3[69] = boxProps, $3[70] = children, $3[71] = t25) : t25 = $3[71];
  let t26;
  return $3[72] !== mode || $3[73] !== radius || $3[74] !== ref || $3[75] !== restProps || $3[76] !== t20 || $3[77] !== t21 || $3[78] !== t222 || $3[79] !== t23 || $3[80] !== t24 || $3[81] !== t25 || $3[82] !== tone || $3[83] !== type || $3[84] !== width ? (t26 = (0, import_jsx_runtime.jsxs)(StyledButton, { "data-ui": "Button", ...restProps, $mode: mode, $radius: radius, $tone: tone, "data-disabled": t20, "data-selected": t21, disabled: t222, ref, type, $width: width, children: [
    t23,
    t24,
    t25
  ] }), $3[72] = mode, $3[73] = radius, $3[74] = ref, $3[75] = restProps, $3[76] = t20, $3[77] = t21, $3[78] = t222, $3[79] = t23, $3[80] = t24, $3[81] = t25, $3[82] = tone, $3[83] = type, $3[84] = width, $3[85] = t26) : t26 = $3[85], t26;
});
Button.displayName = "ForwardRef(Button)";
function cardStyle(props) {
  return [cardBaseStyle(props), cardColorStyle(props)];
}
function cardBaseStyle(props) {
  const {
    $checkered
  } = props, {
    space
  } = getTheme_v2(props.theme);
  return lt`
    ${$checkered && lt`
      background-size: ${space[3]}px ${space[3]}px;
      background-position: 50% 50%;
      background-image: var(--card-bg-image);
    `}

    &[data-as='button'] {
      -webkit-font-smoothing: inherit;
      appearance: none;
      outline: none;
      font: inherit;
      text-align: inherit;
      border: 0;
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    }

    /* &:is(a) */
    &[data-as='a'] {
      outline: none;
      text-decoration: none;
    }

    /* &:is(pre) */
    &[data-as='pre'] {
      font: inherit;
    }
  `;
}
function cardColorStyle(props) {
  const {
    $checkered,
    $focusRing,
    $muted
  } = props, {
    card,
    color: color2,
    style
  } = getTheme_v2(props.theme), border2 = {
    width: card.border.width,
    color: "var(--card-border-color)"
  };
  return lt`
    color-scheme: ${color2._dark ? "dark" : "light"};

    ${_cardColorStyle(color2, color2, $checkered)}

    background-color: ${$muted ? "var(--card-muted-bg-color)" : "var(--card-bg-color)"};
    color: var(--card-fg-color);

    /* &:is(button) */
    &[data-as='button'] {
      --card-focus-ring-box-shadow: none;

      cursor: default;
      box-shadow: var(--card-focus-ring-box-shadow);

      &:disabled {
        ${_cardColorStyle(color2, color2.selectable.default.disabled, $checkered)}
      }

      &:not(:disabled) {
        &[data-pressed] {
          ${_cardColorStyle(color2, color2.selectable.default.pressed, $checkered)}
        }

        &[data-selected] {
          ${_cardColorStyle(color2, color2.selectable.default.selected, $checkered)}
        }

        @media (hover: hover) {
          &:not([data-pressed]):not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color2, color2.selectable.default.hovered, $checkered)}
            }

            &:active {
              ${_cardColorStyle(color2, color2.selectable.default.pressed, $checkered)}
            }
          }
        }

        &:focus-visible {
          --card-focus-ring-box-shadow: ${$focusRing ? focusRingStyle({
    base: color2,
    border: border2,
    focusRing: card.focusRing
  }) : void 0};
        }
      }
    }

    /* &:is(a) */
    &[data-as='a'] {
      cursor: pointer;
      box-shadow: var(--card-focus-ring-box-shadow);

      &[data-disabled] {
        ${_cardColorStyle(color2, color2.selectable.default.disabled, $checkered)}
      }

      &:not([data-disabled]) {
        &[data-pressed] {
          ${_cardColorStyle(color2, color2.selectable.default.pressed, $checkered)}
        }

        &[data-selected] {
          ${_cardColorStyle(color2, color2.selectable.default.selected, $checkered)}
        }

        @media (hover: hover) {
          &:not([data-pressed]):not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color2, color2.selectable.default.hovered, $checkered)}
            }

            &:active {
              ${_cardColorStyle(color2, color2.selectable.default.pressed, $checkered)}
            }
          }
        }

        &:focus-visible {
          --card-focus-ring-box-shadow: ${$focusRing ? focusRingStyle({
    base: color2,
    border: border2,
    focusRing: card.focusRing
  }) : void 0};
        }
      }
    }

    ${style?.card?.root}
  `;
}
var StyledCard = dt(Box).withConfig({
  displayName: "StyledCard",
  componentId: "sc-osnro2-0"
})(responsiveBorderStyle, responsiveRadiusStyle, responsiveShadowStyle, cardStyle);
var Card = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(56);
  let asProp, border2, borderBottom2, borderLeft2, borderRight2, borderTop2, muted, pressed, restProps, scheme, selected, shadow, t0, t1, t22, t3;
  $3[0] !== props ? ({
    __unstable_checkered: t0,
    __unstable_focusRing: t1,
    as: asProp,
    border: border2,
    borderTop: borderTop2,
    borderRight: borderRight2,
    borderBottom: borderBottom2,
    borderLeft: borderLeft2,
    muted,
    pressed,
    radius: t22,
    scheme,
    selected,
    shadow,
    tone: t3,
    ...restProps
  } = props, $3[0] = props, $3[1] = asProp, $3[2] = border2, $3[3] = borderBottom2, $3[4] = borderLeft2, $3[5] = borderRight2, $3[6] = borderTop2, $3[7] = muted, $3[8] = pressed, $3[9] = restProps, $3[10] = scheme, $3[11] = selected, $3[12] = shadow, $3[13] = t0, $3[14] = t1, $3[15] = t22, $3[16] = t3) : (asProp = $3[1], border2 = $3[2], borderBottom2 = $3[3], borderLeft2 = $3[4], borderRight2 = $3[5], borderTop2 = $3[6], muted = $3[7], pressed = $3[8], restProps = $3[9], scheme = $3[10], selected = $3[11], shadow = $3[12], t0 = $3[13], t1 = $3[14], t22 = $3[15], t3 = $3[16]);
  const checkered = t0 === void 0 ? false : t0, focusRing = t1 === void 0 ? false : t1, radius = t22 === void 0 ? 0 : t22, toneProp = t3 === void 0 ? "default" : t3, as = (0, import_react_is.isValidElementType)(asProp) ? asProp : "div", rootTheme = useRootTheme(), tone = toneProp === "inherit" ? rootTheme.tone : toneProp, t4 = typeof as == "string" ? as : void 0, t5 = rootTheme.scheme;
  let t6;
  $3[17] !== border2 ? (t6 = _getArrayProp(border2), $3[17] = border2, $3[18] = t6) : t6 = $3[18];
  let t7;
  $3[19] !== borderTop2 ? (t7 = _getArrayProp(borderTop2), $3[19] = borderTop2, $3[20] = t7) : t7 = $3[20];
  let t8;
  $3[21] !== borderRight2 ? (t8 = _getArrayProp(borderRight2), $3[21] = borderRight2, $3[22] = t8) : t8 = $3[22];
  let t9;
  $3[23] !== borderBottom2 ? (t9 = _getArrayProp(borderBottom2), $3[23] = borderBottom2, $3[24] = t9) : t9 = $3[24];
  let t10;
  $3[25] !== borderLeft2 ? (t10 = _getArrayProp(borderLeft2), $3[25] = borderLeft2, $3[26] = t10) : t10 = $3[26];
  let t11;
  $3[27] !== radius ? (t11 = _getArrayProp(radius), $3[27] = radius, $3[28] = t11) : t11 = $3[28];
  let t12;
  $3[29] !== shadow ? (t12 = _getArrayProp(shadow), $3[29] = shadow, $3[30] = t12) : t12 = $3[30];
  const t13 = checkered ? "" : void 0, t14 = pressed ? "" : void 0, t15 = selected ? "" : void 0;
  let t16;
  $3[31] !== as || $3[32] !== checkered || $3[33] !== focusRing || $3[34] !== muted || $3[35] !== ref || $3[36] !== restProps || $3[37] !== rootTheme.scheme || $3[38] !== selected || $3[39] !== t10 || $3[40] !== t11 || $3[41] !== t12 || $3[42] !== t13 || $3[43] !== t14 || $3[44] !== t15 || $3[45] !== t4 || $3[46] !== t6 || $3[47] !== t7 || $3[48] !== t8 || $3[49] !== t9 || $3[50] !== tone ? (t16 = (0, import_jsx_runtime.jsx)(StyledCard, { "data-as": t4, "data-scheme": t5, "data-ui": "Card", "data-tone": tone, ...restProps, $border: t6, $borderTop: t7, $borderRight: t8, $borderBottom: t9, $borderLeft: t10, $checkered: checkered, $focusRing: focusRing, $muted: muted, $radius: t11, $shadow: t12, $tone: tone, "data-checkered": t13, "data-pressed": t14, "data-selected": t15, forwardedAs: as, ref, selected }), $3[31] = as, $3[32] = checkered, $3[33] = focusRing, $3[34] = muted, $3[35] = ref, $3[36] = restProps, $3[37] = rootTheme.scheme, $3[38] = selected, $3[39] = t10, $3[40] = t11, $3[41] = t12, $3[42] = t13, $3[43] = t14, $3[44] = t15, $3[45] = t4, $3[46] = t6, $3[47] = t7, $3[48] = t8, $3[49] = t9, $3[50] = tone, $3[51] = t16) : t16 = $3[51];
  let t17;
  return $3[52] !== scheme || $3[53] !== t16 || $3[54] !== tone ? (t17 = (0, import_jsx_runtime.jsx)(ThemeColorProvider, { scheme, tone, children: t16 }), $3[52] = scheme, $3[53] = t16, $3[54] = tone, $3[55] = t17) : t17 = $3[55], t17;
});
Card.displayName = "ForwardRef(Card)";
function useClickOutsideEvent(listener2, t0, boundaryElement) {
  const $3 = (0, import_react_compiler_runtime.c)(9), elementsArg = t0 === void 0 ? _temp$8 : t0;
  let t1;
  $3[0] !== boundaryElement || $3[1] !== elementsArg || $3[2] !== listener2 ? (t1 = (evt) => {
    if (!listener2)
      return;
    const target = evt.target;
    if (!(target instanceof Node))
      return;
    const resolvedBoundaryElement = boundaryElement?.();
    if (resolvedBoundaryElement && !resolvedBoundaryElement.contains(target))
      return;
    const elements = elementsArg().flat();
    for (const el of elements)
      if (el && (target === el || el.contains(target)))
        return;
    listener2(evt);
  }, $3[0] = boundaryElement, $3[1] = elementsArg, $3[2] = listener2, $3[3] = t1) : t1 = $3[3];
  const onEvent = useEffectEvent(t1), hasListener = !!listener2;
  let t22;
  $3[4] !== hasListener || $3[5] !== onEvent ? (t22 = () => {
    if (!hasListener)
      return;
    const handleEvent = (evt_0) => onEvent(evt_0);
    return document.addEventListener("mousedown", handleEvent), () => {
      document.removeEventListener("mousedown", handleEvent);
    };
  }, $3[4] = hasListener, $3[5] = onEvent, $3[6] = t22) : t22 = $3[6];
  let t3;
  $3[7] !== hasListener ? (t3 = [hasListener], $3[7] = hasListener, $3[8] = t3) : t3 = $3[8], (0, import_react.useEffect)(t22, t3), (0, import_react.useDebugValue)(listener2 ? "MouseDown On" : "MouseDown Off");
}
function _temp$8() {
  return EMPTY_ARRAY;
}
function useCustomValidity(ref, customValidity) {
  const $3 = (0, import_react_compiler_runtime.c)(4);
  let t0, t1;
  $3[0] !== customValidity || $3[1] !== ref ? (t0 = () => {
    ref.current?.setCustomValidity(customValidity || "");
  }, t1 = [customValidity, ref], $3[0] = customValidity, $3[1] = ref, $3[2] = t0, $3[3] = t1) : (t0 = $3[2], t1 = $3[3]), (0, import_react.useEffect)(t0, t1);
}
var _ResizeObserver = typeof document < "u" && typeof window < "u" && window.ResizeObserver ? window.ResizeObserver : ResizeObserver2;
var _elementSizeObserver = _createElementSizeObserver();
function _createElementRectValueListener() {
  return {
    subscribe(element, subscriber) {
      const resizeObserver = new _ResizeObserver(([entry]) => {
        subscriber({
          _contentRect: entry.contentRect,
          border: {
            width: entry.borderBoxSize[0].inlineSize,
            height: entry.borderBoxSize[0].blockSize
          },
          content: {
            width: entry.contentRect.width,
            height: entry.contentRect.height
          }
        });
      });
      return resizeObserver.observe(element), () => {
        resizeObserver.unobserve(element), resizeObserver.disconnect();
      };
    }
  };
}
function _createElementSizeObserver() {
  const disposeCache = /* @__PURE__ */ new WeakMap(), subscribersCache = /* @__PURE__ */ new WeakMap();
  return {
    subscribe(element, subscriber) {
      const subscribers = subscribersCache.get(element) || [];
      let dispose = disposeCache.get(element);
      return subscribersCache.has(element) || (subscribersCache.set(element, subscribers), dispose = _createElementRectValueListener().subscribe(element, (elementRect) => {
        for (const sub of subscribers)
          sub(elementRect);
      })), subscribers.push(subscriber), () => {
        const idx = subscribers.indexOf(subscriber);
        idx > -1 && subscribers.splice(idx, 1), subscribers.length === 0 && dispose && dispose();
      };
    }
  };
}
function useElementSize(element) {
  const $3 = (0, import_react_compiler_runtime.c)(3), [size2, setSize] = (0, import_react.useState)(null);
  let t0, t1;
  return $3[0] !== element ? (t0 = () => {
    if (element)
      return _elementSizeObserver.subscribe(element, setSize);
  }, t1 = [element], $3[0] = element, $3[1] = t0, $3[2] = t1) : (t0 = $3[1], t1 = $3[2]), (0, import_react.useEffect)(t0, t1), size2;
}
function useGlobalKeyDown(onKeyDown, options2) {
  const $3 = (0, import_react_compiler_runtime.c)(7);
  let t0;
  $3[0] !== onKeyDown ? (t0 = (event) => onKeyDown(event), $3[0] = onKeyDown, $3[1] = t0) : t0 = $3[1];
  const handleKeyDown = useEffectEvent(t0);
  let t1;
  $3[2] !== handleKeyDown || $3[3] !== options2 ? (t1 = () => {
    const handler = (event_0) => handleKeyDown(event_0);
    return window.addEventListener("keydown", handler, options2), () => window.removeEventListener("keydown", handler, options2);
  }, $3[2] = handleKeyDown, $3[3] = options2, $3[4] = t1) : t1 = $3[4];
  let t22;
  $3[5] !== options2 ? (t22 = [options2], $3[5] = options2, $3[6] = t22) : t22 = $3[6], (0, import_react.useEffect)(t1, t22);
}
function useMatchMedia(mediaQueryString, getServerSnapshot2) {
  const $3 = (0, import_react_compiler_runtime.c)(4);
  (0, import_react.useDebugValue)(mediaQueryString);
  let t0;
  $3[0] !== mediaQueryString ? (t0 = (onStoreChange) => {
    const media2 = window.matchMedia(mediaQueryString);
    return media2.addEventListener("change", onStoreChange), () => media2.removeEventListener("change", onStoreChange);
  }, $3[0] = mediaQueryString, $3[1] = t0) : t0 = $3[1];
  let t1;
  return $3[2] !== mediaQueryString ? (t1 = () => window.matchMedia(mediaQueryString).matches, $3[2] = mediaQueryString, $3[3] = t1) : t1 = $3[3], (0, import_react.useSyncExternalStore)(t0, t1, getServerSnapshot2);
}
function _getMediaQuery(media2, index2) {
  return index2 === 0 ? `screen and (max-width: ${media2[index2] - 1}px)` : index2 === media2.length ? `screen and (min-width: ${media2[index2 - 1]}px)` : `screen and (min-width: ${media2[index2 - 1]}px) and (max-width: ${media2[index2] - 1}px)`;
}
function _createMediaStore(media2) {
  const mediaLen = media2.length;
  let sizes;
  const getSizes = () => {
    if (!sizes) {
      sizes = [];
      for (let index2 = mediaLen; index2 > -1; index2 -= 1) {
        const mediaQuery = _getMediaQuery(media2, index2);
        sizes.push({
          index: index2,
          mq: window.matchMedia(mediaQuery)
        });
      }
    }
    return sizes;
  };
  return {
    getSnapshot: () => {
      for (const {
        index: index2,
        mq
      } of getSizes())
        if (mq.matches) return index2;
      return 0;
    },
    subscribe: (onStoreChange) => {
      const disposeFns = [];
      for (const {
        mq
      } of getSizes()) {
        const handleChange = () => {
          mq.matches && onStoreChange();
        };
        mq.addEventListener("change", handleChange), disposeFns.push(() => mq.removeEventListener("change", handleChange));
      }
      return () => {
        for (const disposeFn of disposeFns)
          disposeFn();
      };
    }
  };
}
function getServerSnapshot() {
  return 0;
}
function useMediaIndex() {
  const $3 = (0, import_react_compiler_runtime.c)(2), {
    media: media2
  } = useTheme_v2();
  let t0;
  $3[0] !== media2 ? (t0 = _createMediaStore(media2), $3[0] = media2, $3[1] = t0) : t0 = $3[1];
  const store = t0;
  return (0, import_react.useSyncExternalStore)(store.subscribe, store.getSnapshot, getServerSnapshot);
}
function usePrefersReducedMotion(t0) {
  return useMatchMedia("(prefers-reduced-motion: reduce)", t0 === void 0 ? _temp$6 : t0);
}
function _temp$6() {
  return false;
}
function checkboxBaseStyles() {
  return lt`
    position: relative;
    display: inline-block;
  `;
}
function inputElementStyles(props) {
  const {
    color: color2,
    input,
    radius
  } = getTheme_v2(props.theme), {
    focusRing
  } = input.checkbox;
  return lt`
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    outline: none;
    opacity: 0;
    z-index: 1;
    padding: 0;
    margin: 0;

    & + span {
      position: relative;
      display: block;
      height: ${rem(input.checkbox.size)};
      width: ${rem(input.checkbox.size)};
      box-sizing: border-box;
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};
      border-radius: ${rem(radius[2])};
      line-height: 1;
      background-color: ${color2.input.default.enabled.bg};

      & > svg {
        display: block;
        position: absolute;
        opacity: 0;
        height: 100%;
        width: 100%;

        & > path {
          vector-effect: non-scaling-stroke;
          stroke-width: 1.5px !important;
        }
      }
    }

    &:checked + span {
      background: ${color2.input.default.enabled.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.fg,
    width: input.border.width
  })};
      color: ${color2.input.default.enabled.bg};
    }

    /* focus */
    &:not(:disabled):focus:focus-visible + span {
      box-shadow: ${focusRingStyle({
    focusRing
  })};
    }

    /* focus when checked - uses a different offset */
    &:not(:disabled):focus:focus-visible&:checked + span {
      box-shadow: ${focusRingStyle({
    focusRing: {
      width: 1,
      offset: 1
    }
  })};
    }

    &[data-error] + span {
      background-color: ${color2.input.invalid.enabled.border};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color2.input.invalid.enabled.muted.bg
  })};
      color: ${color2.input.default.disabled.fg};
    }
    &[data-error]&:checked + span {
      background-color: ${color2.input.invalid.enabled.muted.bg};
      color: ${color2.input.default.enabled.bg};
    }
    &[data-error]&:checked&:not(:disabled):focus:focus-visible + span {
      box-shadow: ${focusRingStyle({
    border: {
      width: input.border.width,
      color: color2.input.invalid.readOnly.muted.bg
    },
    focusRing: {
      width: 1,
      offset: 1
    }
  })};
    }

    &:disabled + span {
      background-color: ${color2.input.default.disabled.bg};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color2.input.default.disabled.border
  })};
      color: ${color2.input.default.disabled.fg};
    }
    &:disabled&:checked + span {
      background-color: ${color2.input.default.disabled.muted.bg};
    }

    &[data-read-only] + span {
      background-color: ${color2.input.default.readOnly.bg};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color2.input.default.readOnly.border
  })};
      color: ${color2.input.default.readOnly.fg};
    }

    &[data-read-only]&:checked + span {
      background-color: ${color2.input.default.readOnly.muted.bg};
    }

    &:checked + span > svg:first-child {
      opacity: 1;
    }
    &:indeterminate + span > svg:last-child {
      opacity: 1;
    }
  `;
}
var StyledCheckbox = dt.div.withConfig({
  displayName: "StyledCheckbox",
  componentId: "sc-1l5mt2l-0"
})(checkboxBaseStyles);
var Input$5 = dt.input.withConfig({
  displayName: "Input",
  componentId: "sc-1l5mt2l-1"
})(inputElementStyles);
var Checkbox = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(25);
  let checked, className, customValidity, disabled, indeterminate, readOnly, restProps, style;
  $3[0] !== props ? ({
    checked,
    className,
    disabled,
    indeterminate,
    customValidity,
    readOnly,
    style,
    ...restProps
  } = props, $3[0] = props, $3[1] = checked, $3[2] = className, $3[3] = customValidity, $3[4] = disabled, $3[5] = indeterminate, $3[6] = readOnly, $3[7] = restProps, $3[8] = style) : (checked = $3[1], className = $3[2], customValidity = $3[3], disabled = $3[4], indeterminate = $3[5], readOnly = $3[6], restProps = $3[7], style = $3[8]);
  const ref = (0, import_react.useRef)(null);
  let t0;
  $3[9] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $3[9] = t0) : t0 = $3[9], (0, import_react.useImperativeHandle)(forwardedRef, t0);
  let t1, t22;
  $3[10] !== indeterminate ? (t1 = () => {
    ref.current && (ref.current.indeterminate = indeterminate || false);
  }, t22 = [indeterminate], $3[10] = indeterminate, $3[11] = t1, $3[12] = t22) : (t1 = $3[11], t22 = $3[12]), (0, import_react.useEffect)(t1, t22), useCustomValidity(ref, customValidity);
  const t3 = !disabled && readOnly ? "" : void 0, t4 = customValidity ? "" : void 0, t5 = disabled || readOnly;
  let t6;
  $3[13] !== checked || $3[14] !== readOnly || $3[15] !== restProps || $3[16] !== t3 || $3[17] !== t4 || $3[18] !== t5 ? (t6 = (0, import_jsx_runtime.jsx)(Input$5, { "data-read-only": t3, "data-error": t4, ...restProps, checked, disabled: t5, type: "checkbox", readOnly, ref }), $3[13] = checked, $3[14] = readOnly, $3[15] = restProps, $3[16] = t3, $3[17] = t4, $3[18] = t5, $3[19] = t6) : t6 = $3[19];
  let t7;
  $3[20] === Symbol.for("react.memo_cache_sentinel") ? (t7 = (0, import_jsx_runtime.jsxs)("span", { children: [
    (0, import_jsx_runtime.jsx)(CheckmarkIcon, {}),
    (0, import_jsx_runtime.jsx)(RemoveIcon, {})
  ] }), $3[20] = t7) : t7 = $3[20];
  let t8;
  return $3[21] !== className || $3[22] !== style || $3[23] !== t6 ? (t8 = (0, import_jsx_runtime.jsxs)(StyledCheckbox, { className, "data-ui": "Checkbox", style, children: [
    t6,
    t7
  ] }), $3[21] = className, $3[22] = style, $3[23] = t6, $3[24] = t8) : t8 = $3[24], t8;
});
Checkbox.displayName = "ForwardRef(Checkbox)";
function codeSyntaxHighlightingStyle({
  theme
}) {
  const {
    color: {
      syntax: color2
    }
  } = getTheme_v2(theme);
  return {
    "&.atrule": {
      color: color2.atrule
    },
    "&.attr-name": {
      color: color2.attrName
    },
    "&.attr-value": {
      color: color2.attrValue
    },
    "&.attribute": {
      color: color2.attribute
    },
    "&.boolean": {
      color: color2.boolean
    },
    "&.builtin": {
      color: color2.builtin
    },
    "&.cdata": {
      color: color2.cdata
    },
    "&.char": {
      color: color2.char
    },
    "&.class": {
      color: color2.class
    },
    "&.class-name": {
      color: color2.className
    },
    "&.comment": {
      color: color2.comment
    },
    "&.constant": {
      color: color2.constant
    },
    "&.deleted": {
      color: color2.deleted
    },
    "&.doctype": {
      color: color2.doctype
    },
    "&.entity": {
      color: color2.entity
    },
    "&.function": {
      color: color2.function
    },
    "&.hexcode": {
      color: color2.hexcode
    },
    "&.id": {
      color: color2.id
    },
    "&.important": {
      color: color2.important
    },
    "&.inserted": {
      color: color2.inserted
    },
    "&.keyword": {
      color: color2.keyword
    },
    "&.number": {
      color: color2.number
    },
    "&.operator": {
      color: color2.operator
    },
    "&.prolog": {
      color: color2.prolog
    },
    "&.property": {
      color: color2.property
    },
    "&.pseudo-class": {
      color: color2.pseudoClass
    },
    "&.pseudo-element": {
      color: color2.pseudoElement
    },
    "&.punctuation": {
      color: color2.punctuation
    },
    "&.regex": {
      color: color2.regex
    },
    "&.selector": {
      color: color2.selector
    },
    "&.string": {
      color: color2.string
    },
    "&.symbol": {
      color: color2.symbol
    },
    "&.tag": {
      color: color2.tag
    },
    "&.unit": {
      color: color2.unit
    },
    "&.url": {
      color: color2.url
    },
    "&.variable": {
      color: color2.variable
    }
  };
}
function codeBaseStyle() {
  return lt`
    color: var(--card-code-fg-color);

    & code {
      font-family: inherit;

      &.refractor .token {
        ${codeSyntaxHighlightingStyle}
      }
    }

    & a {
      color: inherit;
      text-decoration: underline;
      border-radius: 1px;
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
var LazyRefractor = (0, import_react.lazy)(() => import("./refractor-RQZG6BLI.js"));
var StyledCode = dt.pre.withConfig({
  displayName: "StyledCode",
  componentId: "sc-4dymyn-0"
})(codeBaseStyle, responsiveCodeFontStyle);
var Code = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(22);
  let children, language, restProps, t0, weight;
  $3[0] !== props ? ({
    children,
    language,
    size: t0,
    weight,
    ...restProps
  } = props, $3[0] = props, $3[1] = children, $3[2] = language, $3[3] = restProps, $3[4] = t0, $3[5] = weight) : (children = $3[1], language = $3[2], restProps = $3[3], t0 = $3[4], weight = $3[5]);
  const size2 = t0 === void 0 ? 2 : t0;
  let t1;
  $3[6] !== size2 ? (t1 = _getArrayProp(size2), $3[6] = size2, $3[7] = t1) : t1 = $3[7];
  let t22;
  $3[8] !== children ? (t22 = (0, import_jsx_runtime.jsx)("code", { children }), $3[8] = children, $3[9] = t22) : t22 = $3[9];
  let t3;
  $3[10] !== children || $3[11] !== language ? (t3 = (0, import_jsx_runtime.jsx)(LazyRefractor, { language, value: children }), $3[10] = children, $3[11] = language, $3[12] = t3) : t3 = $3[12];
  let t4;
  $3[13] !== t22 || $3[14] !== t3 ? (t4 = (0, import_jsx_runtime.jsx)(import_react.Suspense, { fallback: t22, children: t3 }), $3[13] = t22, $3[14] = t3, $3[15] = t4) : t4 = $3[15];
  let t5;
  return $3[16] !== ref || $3[17] !== restProps || $3[18] !== t1 || $3[19] !== t4 || $3[20] !== weight ? (t5 = (0, import_jsx_runtime.jsx)(StyledCode, { "data-ui": "Code", ...restProps, $size: t1, $weight: weight, ref, children: t4 }), $3[16] = ref, $3[17] = restProps, $3[18] = t1, $3[19] = t4, $3[20] = weight, $3[21] = t5) : t5 = $3[21], t5;
});
Code.displayName = "ForwardRef(Code)";
var BASE_STYLE$1 = {
  width: "100%",
  margin: "0 auto"
};
function containerBaseStyle() {
  return BASE_STYLE$1;
}
function responsiveContainerWidthStyle(props) {
  const {
    container: container2,
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$width, (val) => ({
    maxWidth: val === "auto" ? "none" : rem(container2[val])
  }));
}
var StyledContainer = dt(Box).withConfig({
  displayName: "StyledContainer",
  componentId: "sc-wyroop-0"
})(containerBaseStyle, responsiveContainerWidthStyle);
var Container = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(11);
  let as, restProps, t0;
  $3[0] !== props ? ({
    as,
    width: t0,
    ...restProps
  } = props, $3[0] = props, $3[1] = as, $3[2] = restProps, $3[3] = t0) : (as = $3[1], restProps = $3[2], t0 = $3[3]);
  const width = t0 === void 0 ? 2 : t0;
  let t1;
  $3[4] !== width ? (t1 = _getArrayProp(width), $3[4] = width, $3[5] = t1) : t1 = $3[5];
  let t22;
  return $3[6] !== as || $3[7] !== ref || $3[8] !== restProps || $3[9] !== t1 ? (t22 = (0, import_jsx_runtime.jsx)(StyledContainer, { "data-ui": "Container", ...restProps, $width: t1, forwardedAs: as, ref }), $3[6] = as, $3[7] = ref, $3[8] = restProps, $3[9] = t1, $3[10] = t22) : t22 = $3[10], t22;
});
Container.displayName = "ForwardRef(Container)";
var StyledGrid = dt(Box).withConfig({
  displayName: "StyledGrid",
  componentId: "sc-v8t8oz-0"
})(responsiveGridStyle);
var Grid = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(42);
  let as, autoCols, autoFlow, autoRows, children, columns, gap, gapX, gapY, restProps, rows;
  $3[0] !== props ? ({
    as,
    autoRows,
    autoCols,
    autoFlow,
    columns,
    gap,
    gapX,
    gapY,
    rows,
    children,
    ...restProps
  } = props, $3[0] = props, $3[1] = as, $3[2] = autoCols, $3[3] = autoFlow, $3[4] = autoRows, $3[5] = children, $3[6] = columns, $3[7] = gap, $3[8] = gapX, $3[9] = gapY, $3[10] = restProps, $3[11] = rows) : (as = $3[1], autoCols = $3[2], autoFlow = $3[3], autoRows = $3[4], children = $3[5], columns = $3[6], gap = $3[7], gapX = $3[8], gapY = $3[9], restProps = $3[10], rows = $3[11]);
  const t0 = typeof as == "string" ? as : void 0;
  let t1;
  $3[12] !== autoRows ? (t1 = _getArrayProp(autoRows), $3[12] = autoRows, $3[13] = t1) : t1 = $3[13];
  let t22;
  $3[14] !== autoCols ? (t22 = _getArrayProp(autoCols), $3[14] = autoCols, $3[15] = t22) : t22 = $3[15];
  let t3;
  $3[16] !== autoFlow ? (t3 = _getArrayProp(autoFlow), $3[16] = autoFlow, $3[17] = t3) : t3 = $3[17];
  let t4;
  $3[18] !== columns ? (t4 = _getArrayProp(columns), $3[18] = columns, $3[19] = t4) : t4 = $3[19];
  let t5;
  $3[20] !== gap ? (t5 = _getArrayProp(gap), $3[20] = gap, $3[21] = t5) : t5 = $3[21];
  let t6;
  $3[22] !== gapX ? (t6 = _getArrayProp(gapX), $3[22] = gapX, $3[23] = t6) : t6 = $3[23];
  let t7;
  $3[24] !== gapY ? (t7 = _getArrayProp(gapY), $3[24] = gapY, $3[25] = t7) : t7 = $3[25];
  let t8;
  $3[26] !== rows ? (t8 = _getArrayProp(rows), $3[26] = rows, $3[27] = t8) : t8 = $3[27];
  let t9;
  return $3[28] !== as || $3[29] !== children || $3[30] !== ref || $3[31] !== restProps || $3[32] !== t0 || $3[33] !== t1 || $3[34] !== t22 || $3[35] !== t3 || $3[36] !== t4 || $3[37] !== t5 || $3[38] !== t6 || $3[39] !== t7 || $3[40] !== t8 ? (t9 = (0, import_jsx_runtime.jsx)(StyledGrid, { "data-as": t0, "data-ui": "Grid", ...restProps, $autoRows: t1, $autoCols: t22, $autoFlow: t3, $columns: t4, $gap: t5, $gapX: t6, $gapY: t7, $rows: t8, forwardedAs: as, ref, children }), $3[28] = as, $3[29] = children, $3[30] = ref, $3[31] = restProps, $3[32] = t0, $3[33] = t1, $3[34] = t22, $3[35] = t3, $3[36] = t4, $3[37] = t5, $3[38] = t6, $3[39] = t7, $3[40] = t8, $3[41] = t9) : t9 = $3[41], t9;
});
Grid.displayName = "ForwardRef(Grid)";
function headingBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props, {
    font
  } = getTheme_v2(props.theme);
  return lt`
    ${$accent && lt`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && lt`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
      color: var(--card-link-color);
      outline: none;

      @media (hover: hover) {
        &:hover {
          text-decoration: underline;
        }
      }

      &:focus {
        box-shadow:
          0 0 0 1px var(--card-bg-color),
          0 0 0 3px var(--card-focus-ring-color);
      }

      &:focus:not(:focus-visible) {
        box-shadow: none;
      }
    }

    & strong {
      font-weight: ${font.heading.weights.bold};
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
var StyledHeading = dt.div.withConfig({
  displayName: "StyledHeading",
  componentId: "sc-137lwim-0"
})(headingBaseStyle, responsiveTextAlignStyle, responsiveHeadingFont);
var Heading = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(26);
  let align, childrenProp, restProps, t0, t1, t22, textOverflow, weight;
  $3[0] !== props ? ({
    accent: t0,
    align,
    children: childrenProp,
    muted: t1,
    size: t22,
    textOverflow,
    weight,
    ...restProps
  } = props, $3[0] = props, $3[1] = align, $3[2] = childrenProp, $3[3] = restProps, $3[4] = t0, $3[5] = t1, $3[6] = t22, $3[7] = textOverflow, $3[8] = weight) : (align = $3[1], childrenProp = $3[2], restProps = $3[3], t0 = $3[4], t1 = $3[5], t22 = $3[6], textOverflow = $3[7], weight = $3[8]);
  const accent = t0 === void 0 ? false : t0, muted = t1 === void 0 ? false : t1, size2 = t22 === void 0 ? 2 : t22;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    let t32;
    $3[9] !== children ? (t32 = (0, import_jsx_runtime.jsx)(SpanWithTextOverflow, { children }), $3[9] = children, $3[10] = t32) : t32 = $3[10], children = t32;
  }
  let t3;
  $3[11] !== align ? (t3 = _getArrayProp(align), $3[11] = align, $3[12] = t3) : t3 = $3[12];
  let t4;
  $3[13] !== size2 ? (t4 = _getArrayProp(size2), $3[13] = size2, $3[14] = t4) : t4 = $3[14];
  let t5;
  $3[15] !== children ? (t5 = (0, import_jsx_runtime.jsx)("span", { children }), $3[15] = children, $3[16] = t5) : t5 = $3[16];
  let t6;
  return $3[17] !== accent || $3[18] !== muted || $3[19] !== ref || $3[20] !== restProps || $3[21] !== t3 || $3[22] !== t4 || $3[23] !== t5 || $3[24] !== weight ? (t6 = (0, import_jsx_runtime.jsx)(StyledHeading, { "data-ui": "Heading", ...restProps, $accent: accent, $align: t3, $muted: muted, $size: t4, $weight: weight, ref, children: t5 }), $3[17] = accent, $3[18] = muted, $3[19] = ref, $3[20] = restProps, $3[21] = t3, $3[22] = t4, $3[23] = t5, $3[24] = weight, $3[25] = t6) : t6 = $3[25], t6;
});
Heading.displayName = "ForwardRef(Heading)";
function inlineBaseStyle() {
  return {
    lineHeight: "0",
    "&&:not([hidden])": {
      display: "block"
    },
    "& > div": {
      display: "inline-block",
      verticalAlign: "middle"
    }
  };
}
function inlineSpaceStyle(props) {
  const {
    media: media2,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$space, (spaceIndex) => {
    const _space = rem(spaceIndex === 0.5 ? space[1] / 2 : space[spaceIndex]);
    return {
      margin: `-${_space} 0 0 -${_space}`,
      "& > div": {
        padding: `${_space} 0 0 ${_space}`
      }
    };
  });
}
var StyledInline = dt(Box).withConfig({
  displayName: "StyledInline",
  componentId: "sc-1pkiy6j-0"
})(inlineBaseStyle, inlineSpaceStyle);
var Inline = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(15);
  let as, childrenProp, restProps, space;
  $3[0] !== props ? ({
    as,
    children: childrenProp,
    space,
    ...restProps
  } = props, $3[0] = props, $3[1] = as, $3[2] = childrenProp, $3[3] = restProps, $3[4] = space) : (as = $3[1], childrenProp = $3[2], restProps = $3[3], space = $3[4]);
  let t0;
  $3[5] !== childrenProp ? (t0 = import_react.Children.map(childrenProp, _temp$5), $3[5] = childrenProp, $3[6] = t0) : t0 = $3[6];
  const children = t0;
  let t1;
  $3[7] !== space ? (t1 = _getArrayProp(space), $3[7] = space, $3[8] = t1) : t1 = $3[8];
  const t22 = ref;
  let t3;
  return $3[9] !== as || $3[10] !== children || $3[11] !== restProps || $3[12] !== t1 || $3[13] !== t22 ? (t3 = (0, import_jsx_runtime.jsx)(StyledInline, { "data-ui": "Inline", ...restProps, $space: t1, forwardedAs: as, ref: t22, children }), $3[9] = as, $3[10] = children, $3[11] = restProps, $3[12] = t1, $3[13] = t22, $3[14] = t3) : t3 = $3[14], t3;
});
Inline.displayName = "ForwardRef(Inline)";
function _temp$5(child) {
  return child && (0, import_jsx_runtime.jsx)("div", { children: child });
}
function kbdStyle() {
  return lt`
    --card-bg-color: var(--card-kbd-bg-color);
    --card-border-color: var(--card-kbd-border-color);
    --card-fg-color: var(--card-kbd-fg-color);

    box-shadow: inset 0 0 0 1px var(--card-border-color);
    background: var(--card-bg-color);
    font: inherit;

    vertical-align: top;

    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
var StyledKBD = dt.kbd.withConfig({
  displayName: "StyledKBD",
  componentId: "sc-1w7yd8w-0"
})(responsiveRadiusStyle, kbdStyle);
var KBD = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(19);
  let children, restProps, t0, t1, t22;
  $3[0] !== props ? ({
    children,
    fontSize: t0,
    padding: t1,
    radius: t22,
    ...restProps
  } = props, $3[0] = props, $3[1] = children, $3[2] = restProps, $3[3] = t0, $3[4] = t1, $3[5] = t22) : (children = $3[1], restProps = $3[2], t0 = $3[3], t1 = $3[4], t22 = $3[5]);
  const fontSize2 = t0 === void 0 ? 0 : t0, padding = t1 === void 0 ? 1 : t1, radius = t22 === void 0 ? 2 : t22;
  let t3;
  $3[6] !== radius ? (t3 = _getArrayProp(radius), $3[6] = radius, $3[7] = t3) : t3 = $3[7];
  let t4;
  $3[8] !== children || $3[9] !== fontSize2 ? (t4 = (0, import_jsx_runtime.jsx)(Text, { as: "span", size: fontSize2, weight: "semibold", children }), $3[8] = children, $3[9] = fontSize2, $3[10] = t4) : t4 = $3[10];
  let t5;
  $3[11] !== padding || $3[12] !== t4 ? (t5 = (0, import_jsx_runtime.jsx)(Box, { as: "span", padding, children: t4 }), $3[11] = padding, $3[12] = t4, $3[13] = t5) : t5 = $3[13];
  let t6;
  return $3[14] !== ref || $3[15] !== restProps || $3[16] !== t3 || $3[17] !== t5 ? (t6 = (0, import_jsx_runtime.jsx)(StyledKBD, { "data-ui": "KBD", ...restProps, $radius: t3, ref, children: t5 }), $3[14] = ref, $3[15] = restProps, $3[16] = t3, $3[17] = t5, $3[18] = t6) : t6 = $3[18], t6;
});
KBD.displayName = "ForwardRef(KBD)";
var origin = {
  name: "@sanity/ui/origin",
  fn({
    middlewareData,
    placement,
    rects
  }) {
    const [side] = placement.split("-"), floatingWidth = rects.floating.width, floatingHeight = rects.floating.height, shiftX = middlewareData.shift?.x || 0, shiftY = middlewareData.shift?.y || 0;
    if (floatingWidth <= 0 || floatingHeight <= 0)
      return {};
    const isVerticalPlacement = ["bottom", "top"].includes(side), {
      originX,
      originY
    } = isVerticalPlacement ? {
      originX: clamp2(0.5 - shiftX / floatingWidth, 0, 1),
      originY: side === "bottom" ? 0 : 1
    } : {
      originX: side === "left" ? 1 : 0,
      originY: clamp2(0.5 - shiftY / floatingHeight, 0, 1)
    };
    return {
      data: {
        originX,
        originY
      }
    };
  }
};
function clamp2(num, min, max) {
  return Math.min(Math.max(num, min), max);
}
function moveTowardsLength(movingPoint, targetPoint, amount) {
  const width = targetPoint.x - movingPoint.x, height = targetPoint.y - movingPoint.y, distance = Math.sqrt(width * width + height * height);
  return moveTowardsFractional(movingPoint, targetPoint, Math.min(1, amount / distance));
}
function moveTowardsFractional(movingPoint, targetPoint, fraction) {
  return {
    x: movingPoint.x + (targetPoint.x - movingPoint.x) * fraction,
    y: movingPoint.y + (targetPoint.y - movingPoint.y) * fraction
  };
}
function getRoundedCommands(points) {
  const len = points.length, cmds = [];
  for (let i3 = 0; i3 < len; i3 += 1) {
    const point = points[i3], prevPoint = points[i3 - 1], nextPoint = points[i3 + 1];
    if (prevPoint && point.radius) {
      const curveStart = moveTowardsLength(point, prevPoint, point.radius), curveEnd = moveTowardsLength(point, nextPoint, point.radius), startControl = moveTowardsFractional(curveStart, point, 0.5), endControl = moveTowardsFractional(point, curveEnd, 0.5);
      cmds.push({
        type: "point",
        ...curveStart
      }), cmds.push({
        type: "curve",
        curveEnd,
        startControl,
        endControl
      });
    } else
      cmds.push({
        type: "point",
        ...point
      });
  }
  return cmds;
}
function compileCommands(cmds) {
  return cmds.map((n3, idx) => n3.type === "point" ? `${idx === 0 ? "M" : "L"} ${n3.x} ${n3.y}` : n3.type === "curve" ? `C ${n3.startControl.x} ${n3.startControl.y} ${n3.endControl.x} ${n3.endControl.y} ${n3.curveEnd.x} ${n3.curveEnd.y}` : "").join(" ");
}
var StyledArrow = dt.div.withConfig({
  displayName: "StyledArrow",
  componentId: "sc-12vzy6c-0"
})(({
  $w: w3
}) => lt`
    position: absolute;
    width: ${w3}px;
    height: ${w3}px;

    :empty + & {
      display: none;
    }

    & > svg {
      display: block;
      line-height: 0;
      transform-origin: ${w3 / 2}px ${w3 / 2}px;
    }

    [data-placement^='top'] > & {
      bottom: -${w3}px;

      & > svg {
        transform: rotate(0);
      }
    }

    [data-placement^='right'] > & {
      left: -${w3}px;

      & > svg {
        transform: rotate(90deg);
      }
    }

    [data-placement^='left'] > & {
      right: -${w3}px;

      & > svg {
        transform: rotate(-90deg);
      }
    }

    [data-placement^='bottom'] > & {
      top: -${w3}px;

      & > svg {
        transform: rotate(180deg);
      }
    }
  `);
var StrokePath = dt.path.withConfig({
  displayName: "StrokePath",
  componentId: "sc-12vzy6c-1"
})`stroke:var(--card-shadow-outline-color);`;
var ShapePath = dt.path.withConfig({
  displayName: "ShapePath",
  componentId: "sc-12vzy6c-2"
})`fill:var(--card-bg-color);`;
var Arrow = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(24);
  let h2, restProps, t0, w3;
  $3[0] !== props ? ({
    width: w3,
    height: h2,
    radius: t0,
    ...restProps
  } = props, $3[0] = props, $3[1] = h2, $3[2] = restProps, $3[3] = t0, $3[4] = w3) : (h2 = $3[1], restProps = $3[2], t0 = $3[3], w3 = $3[4]);
  const radius = t0 === void 0 ? 0 : t0, {
    card
  } = useTheme_v2(), strokeWidth = card.shadow.outline, center = w3 / 2, points = [{
    x: 0,
    y: 0
  }, {
    x: radius,
    y: 0,
    radius
  }, {
    x: center,
    y: h2 - 1,
    radius
  }, {
    x: w3 - radius,
    y: 0,
    radius
  }, {
    x: w3,
    y: 0
  }], cmds = getRoundedCommands(points), path = compileCommands(cmds), strokePath = `${path}`, fillPath = `${path} M ${w3} -1 M 0 -1 Z`, t1 = `0 0 ${w3} ${w3}`;
  let t22;
  $3[5] !== strokeWidth || $3[6] !== w3 ? (t22 = (0, import_jsx_runtime.jsx)("mask", { id: "stroke-mask", children: (0, import_jsx_runtime.jsx)("rect", { x: 0, y: strokeWidth, width: w3, height: w3, fill: "white" }) }), $3[5] = strokeWidth, $3[6] = w3, $3[7] = t22) : t22 = $3[7];
  const t3 = strokeWidth * 2;
  let t4;
  $3[8] !== strokePath || $3[9] !== t3 ? (t4 = (0, import_jsx_runtime.jsx)(StrokePath, { d: strokePath, mask: "url(#stroke-mask)", strokeWidth: t3 }), $3[8] = strokePath, $3[9] = t3, $3[10] = t4) : t4 = $3[10];
  let t5;
  $3[11] !== fillPath ? (t5 = (0, import_jsx_runtime.jsx)(ShapePath, { d: fillPath }), $3[11] = fillPath, $3[12] = t5) : t5 = $3[12];
  let t6;
  $3[13] !== t1 || $3[14] !== t22 || $3[15] !== t4 || $3[16] !== t5 || $3[17] !== w3 ? (t6 = (0, import_jsx_runtime.jsxs)("svg", { width: w3, height: w3, viewBox: t1, children: [
    t22,
    t4,
    t5
  ] }), $3[13] = t1, $3[14] = t22, $3[15] = t4, $3[16] = t5, $3[17] = w3, $3[18] = t6) : t6 = $3[18];
  let t7;
  return $3[19] !== ref || $3[20] !== restProps || $3[21] !== t6 || $3[22] !== w3 ? (t7 = (0, import_jsx_runtime.jsx)(StyledArrow, { ...restProps, $w: w3, ref, children: t6 }), $3[19] = ref, $3[20] = restProps, $3[21] = t6, $3[22] = w3, $3[23] = t7) : t7 = $3[23], t7;
});
Arrow.displayName = "ForwardRef(Arrow)";
var BoundaryElementContext = createGlobalScopedContext("@sanity/ui/context/boundaryElement", null);
function BoundaryElementProvider(props) {
  const $3 = (0, import_react_compiler_runtime.c)(5), {
    children,
    element
  } = props;
  let t0;
  $3[0] !== element ? (t0 = {
    version: 0,
    element
  }, $3[0] = element, $3[1] = t0) : t0 = $3[1];
  const value = t0;
  let t1;
  return $3[2] !== children || $3[3] !== value ? (t1 = (0, import_jsx_runtime.jsx)(BoundaryElementContext.Provider, { value, children }), $3[2] = children, $3[3] = value, $3[4] = t1) : t1 = $3[4], t1;
}
BoundaryElementProvider.displayName = "BoundaryElementProvider";
function isRecord2(value) {
  return !!(value && typeof value == "object" && !Array.isArray(value));
}
var DEFAULT_VALUE = {
  version: 0,
  element: null
};
function useBoundaryElement() {
  const value = (0, import_react.useContext)(BoundaryElementContext);
  if (value && (!isRecord2(value) || value.version !== 0))
    throw new Error("useBoundaryElement(): the context value is not compatible");
  return value || DEFAULT_VALUE;
}
function ConditionalWrapper({
  children,
  condition,
  wrapper
}) {
  return condition ? wrapper(children) : children;
}
ConditionalWrapper.displayName = "ConditionalWrapper";
function findMaxBreakpoints(media2, width) {
  const ret = [];
  for (let i3 = 0; i3 < media2.length; i3 += 1)
    media2[i3] > width && ret.push(i3);
  return ret;
}
function findMinBreakpoints(media2, width) {
  const ret = [];
  for (let i3 = 0; i3 < media2.length; i3 += 1)
    media2[i3] <= width && ret.push(i3);
  return ret;
}
var ElementQuery = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(18), theme = useTheme_v2();
  let _media, children, restProps;
  $3[0] !== props ? ({
    children,
    media: _media,
    ...restProps
  } = props, $3[0] = props, $3[1] = _media, $3[2] = children, $3[3] = restProps) : (_media = $3[1], children = $3[2], restProps = $3[3]);
  const media2 = _media ?? theme.media, [element, setElement] = (0, import_react.useState)(null), width = useElementSize(element)?.border.width ?? window.innerWidth;
  let t0;
  if ($3[4] !== media2 || $3[5] !== width) {
    const eq = findMaxBreakpoints(media2, width);
    t0 = eq.length ? eq.join(" ") : void 0, $3[4] = media2, $3[5] = width, $3[6] = t0;
  } else
    t0 = $3[6];
  const max = t0;
  let t1;
  if ($3[7] !== media2 || $3[8] !== width) {
    const eq_0 = findMinBreakpoints(media2, width);
    t1 = eq_0.length ? eq_0.join(" ") : void 0, $3[7] = media2, $3[8] = width, $3[9] = t1;
  } else
    t1 = $3[9];
  const min = t1;
  let t22, t3;
  $3[10] !== element ? (t22 = () => element, t3 = [element], $3[10] = element, $3[11] = t22, $3[12] = t3) : (t22 = $3[11], t3 = $3[12]), (0, import_react.useImperativeHandle)(forwardedRef, t22, t3);
  let t4;
  return $3[13] !== children || $3[14] !== max || $3[15] !== min || $3[16] !== restProps ? (t4 = (0, import_jsx_runtime.jsx)("div", { "data-ui": "ElementQuery", ...restProps, "data-eq-max": max, "data-eq-min": min, ref: setElement, children }), $3[13] = children, $3[14] = max, $3[15] = min, $3[16] = restProps, $3[17] = t4) : t4 = $3[17], t4;
});
ElementQuery.displayName = "ForwardRef(ElementQuery)";
function getLayerContext(contextValue) {
  if (!isRecord2(contextValue) || contextValue.version !== 0)
    throw new Error("the context value is not compatible");
  if (!contextValue)
    throw new Error("components using `useLayer()` should be wrapped in a <LayerProvider>.");
  if (contextValue.version === 0)
    return contextValue;
  throw new Error("could not get layer context");
}
var LayerContext = createGlobalScopedContext("@sanity/ui/context/layer", null);
function LayerProvider(props) {
  const $3 = (0, import_react_compiler_runtime.c)(21), {
    children,
    zOffset: t0
  } = props, zOffsetProp = t0 === void 0 ? 0 : t0, parentContextValue = (0, import_react.useContext)(LayerContext);
  let t1;
  $3[0] !== parentContextValue ? (t1 = parentContextValue && getLayerContext(parentContextValue), $3[0] = parentContextValue, $3[1] = t1) : t1 = $3[1];
  const parent = t1, parentRegisterChild = parent?.registerChild, level = (parent?.level ?? 0) + 1;
  let t22;
  $3[2] !== zOffsetProp ? (t22 = _getArrayProp(zOffsetProp), $3[2] = zOffsetProp, $3[3] = t22) : t22 = $3[3];
  const zOffset = t22, maxMediaIndex = zOffset.length - 1, mediaIndex = Math.min(useMediaIndex(), maxMediaIndex), zIndex = parent ? parent.zIndex + zOffset[mediaIndex] : zOffset[mediaIndex];
  let t3;
  $3[4] === Symbol.for("react.memo_cache_sentinel") ? (t3 = {}, $3[4] = t3) : t3 = $3[4];
  const [, setChildLayers] = (0, import_react.useState)(t3), [size2, setSize] = (0, import_react.useState)(0), isTopLayer = size2 === 0;
  let t4;
  $3[5] !== parentRegisterChild || $3[6] !== setChildLayers ? (t4 = (childLevel) => {
    const parentDispose = parentRegisterChild?.(childLevel);
    return childLevel !== void 0 ? setChildLayers((state) => {
      const prevLen = state[childLevel] ?? 0, nextState = {
        ...state,
        [childLevel]: prevLen + 1
      };
      return setSize(Object.keys(nextState).length), nextState;
    }) : setSize(_temp$4), () => {
      childLevel !== void 0 ? setChildLayers((state_0) => {
        const nextState_0 = {
          ...state_0
        };
        return nextState_0[childLevel] === 1 ? (delete nextState_0[childLevel], setSize(Object.keys(nextState_0).length)) : nextState_0[childLevel] = nextState_0[childLevel] - 1, nextState_0;
      }) : setSize(_temp2$2), parentDispose?.();
    };
  }, $3[5] = parentRegisterChild, $3[6] = setChildLayers, $3[7] = t4) : t4 = $3[7];
  const registerChild = t4;
  let t5, t6;
  $3[8] !== level || $3[9] !== parentRegisterChild ? (t5 = () => parentRegisterChild?.(level), t6 = [level, parentRegisterChild], $3[8] = level, $3[9] = parentRegisterChild, $3[10] = t5, $3[11] = t6) : (t5 = $3[10], t6 = $3[11]), (0, import_react.useEffect)(t5, t6);
  let t7;
  $3[12] !== isTopLayer || $3[13] !== level || $3[14] !== registerChild || $3[15] !== size2 || $3[16] !== zIndex ? (t7 = {
    version: 0,
    isTopLayer,
    level,
    registerChild,
    size: size2,
    zIndex
  }, $3[12] = isTopLayer, $3[13] = level, $3[14] = registerChild, $3[15] = size2, $3[16] = zIndex, $3[17] = t7) : t7 = $3[17];
  const value = t7;
  let t8;
  return $3[18] !== children || $3[19] !== value ? (t8 = (0, import_jsx_runtime.jsx)(LayerContext.Provider, { value, children }), $3[18] = children, $3[19] = value, $3[20] = t8) : t8 = $3[20], t8;
}
function _temp2$2(v_0) {
  return v_0 - 1;
}
function _temp$4(v2) {
  return v2 + 1;
}
LayerProvider.displayName = "LayerProvider";
function useLayer() {
  const $3 = (0, import_react_compiler_runtime.c)(2), value = (0, import_react.useContext)(LayerContext);
  if (!value)
    throw new Error("useLayer(): missing context value");
  try {
    let t1;
    return $3[0] !== value ? (t1 = getLayerContext(value), $3[0] = value, $3[1] = t1) : t1 = $3[1], t1;
  } catch (t0) {
    const err = t0;
    throw err instanceof Error ? new Error(`useLayer(): ${err.message}`) : new Error(`useLayer(): ${err}`);
  }
}
var StyledLayer = dt.div.withConfig({
  displayName: "StyledLayer",
  componentId: "sc-16kojrv-0"
})({
  position: "relative"
});
var LayerChildren = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(22);
  let children, onActivate, onFocus2, restProps, t0;
  $3[0] !== props ? ({
    children,
    onActivate,
    onFocus: onFocus2,
    style: t0,
    ...restProps
  } = props, $3[0] = props, $3[1] = children, $3[2] = onActivate, $3[3] = onFocus2, $3[4] = restProps, $3[5] = t0) : (children = $3[1], onActivate = $3[2], onFocus2 = $3[3], restProps = $3[4], t0 = $3[5]);
  const style = t0 === void 0 ? EMPTY_RECORD : t0, {
    zIndex,
    isTopLayer
  } = useLayer(), lastFocusedRef = (0, import_react.useRef)(null), ref = (0, import_react.useRef)(null), isTopLayerRef = (0, import_react.useRef)(isTopLayer);
  let t1;
  $3[6] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => ref.current, $3[6] = t1) : t1 = $3[6], (0, import_react.useImperativeHandle)(forwardedRef, t1);
  let t22, t3;
  $3[7] !== isTopLayer || $3[8] !== onActivate ? (t22 = () => {
    isTopLayerRef.current !== isTopLayer && isTopLayer && onActivate?.({
      activeElement: lastFocusedRef.current
    }), isTopLayerRef.current = isTopLayer;
  }, t3 = [isTopLayer, onActivate], $3[7] = isTopLayer, $3[8] = onActivate, $3[9] = t22, $3[10] = t3) : (t22 = $3[9], t3 = $3[10]), (0, import_react.useEffect)(t22, t3);
  let t4;
  $3[11] !== isTopLayer || $3[12] !== onFocus2 ? (t4 = (event) => {
    onFocus2?.(event);
    const rootElement = ref.current, target = document.activeElement;
    !isTopLayer || !rootElement || !target || isHTMLElement(target) && containsOrEqualsElement(rootElement, target) && (lastFocusedRef.current = target);
  }, $3[11] = isTopLayer, $3[12] = onFocus2, $3[13] = t4) : t4 = $3[13];
  const handleFocus = t4;
  let t5;
  $3[14] !== style || $3[15] !== zIndex ? (t5 = {
    ...style,
    zIndex
  }, $3[14] = style, $3[15] = zIndex, $3[16] = t5) : t5 = $3[16];
  let t6;
  return $3[17] !== children || $3[18] !== handleFocus || $3[19] !== restProps || $3[20] !== t5 ? (t6 = (0, import_jsx_runtime.jsx)(StyledLayer, { ...restProps, "data-ui": "Layer", onFocus: handleFocus, ref, style: t5, children }), $3[17] = children, $3[18] = handleFocus, $3[19] = restProps, $3[20] = t5, $3[21] = t6) : t6 = $3[21], t6;
});
var Layer = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(11);
  let children, restProps, t0;
  $3[0] !== props ? ({
    children,
    zOffset: t0,
    ...restProps
  } = props, $3[0] = props, $3[1] = children, $3[2] = restProps, $3[3] = t0) : (children = $3[1], restProps = $3[2], t0 = $3[3]);
  const zOffset = t0 === void 0 ? 1 : t0;
  let t1;
  $3[4] !== children || $3[5] !== ref || $3[6] !== restProps ? (t1 = (0, import_jsx_runtime.jsx)(LayerChildren, { ...restProps, ref, children }), $3[4] = children, $3[5] = ref, $3[6] = restProps, $3[7] = t1) : t1 = $3[7];
  let t22;
  return $3[8] !== t1 || $3[9] !== zOffset ? (t22 = (0, import_jsx_runtime.jsx)(LayerProvider, { zOffset, children: t1 }), $3[8] = t1, $3[9] = zOffset, $3[10] = t22) : t22 = $3[10], t22;
});
Layer.displayName = "ForwardRef(Layer)";
var key = "@sanity/ui/context/portal";
var elementKey = Symbol.for(`${key}/element`);
globalScope[elementKey] = null;
var defaultContextValue = {
  version: 0,
  boundaryElement: null,
  get element() {
    return typeof document > "u" ? null : (globalScope[elementKey] || (globalScope[elementKey] = document.createElement("div"), globalScope[elementKey].setAttribute("data-portal", ""), document.body.appendChild(globalScope[elementKey])), globalScope[elementKey]);
  }
};
var PortalContext = createGlobalScopedContext(key, defaultContextValue);
function usePortal() {
  const value = (0, import_react.useContext)(PortalContext);
  if (!value)
    throw new Error("usePortal(): missing context value");
  if (!isRecord2(value) || value.version !== 0)
    throw new Error("usePortal(): the context value is not compatible");
  return value;
}
function Portal(props) {
  const $3 = (0, import_react_compiler_runtime.c)(3), {
    children,
    __unstable_name: name
  } = props, portal = usePortal(), portalElement = (name ? portal.elements && portal.elements[name] : portal.element) || portal.elements?.default;
  if (!portalElement)
    return null;
  let t0;
  return $3[0] !== children || $3[1] !== portalElement ? (t0 = (0, import_react_dom2.createPortal)(children, portalElement), $3[0] = children, $3[1] = portalElement, $3[2] = t0) : t0 = $3[2], t0;
}
Portal.displayName = "Portal";
function PortalProvider(props) {
  const $3 = (0, import_react_compiler_runtime.c)(7), {
    boundaryElement,
    children,
    element,
    __unstable_elements: elements
  } = props, fallbackElement = (0, import_react.useSyncExternalStore)(emptySubscribe, _temp$3, _temp2$1), t0 = boundaryElement || null, t1 = element || fallbackElement;
  let t22;
  $3[0] !== elements || $3[1] !== t0 || $3[2] !== t1 ? (t22 = {
    version: 0,
    boundaryElement: t0,
    element: t1,
    elements
  }, $3[0] = elements, $3[1] = t0, $3[2] = t1, $3[3] = t22) : t22 = $3[3];
  const value = t22;
  let t3;
  return $3[4] !== children || $3[5] !== value ? (t3 = (0, import_jsx_runtime.jsx)(PortalContext.Provider, { value, children }), $3[4] = children, $3[5] = value, $3[6] = t3) : t3 = $3[6], t3;
}
function _temp2$1() {
  return null;
}
function _temp$3() {
  return document.body;
}
PortalProvider.displayName = "PortalProvider";
var emptySubscribe = () => () => {
};
var StyledSrOnly = dt.div.withConfig({
  displayName: "StyledSrOnly",
  componentId: "sc-mubr0c-0"
})`display:block;width:0;height:0;position:absolute;overflow:hidden;overflow:clip;`;
var SrOnly = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(4), {
    as,
    children
  } = props;
  let t0;
  return $3[0] !== as || $3[1] !== children || $3[2] !== ref ? (t0 = (0, import_jsx_runtime.jsx)(StyledSrOnly, { "aria-hidden": true, as, "data-ui": "SrOnly", ref, children }), $3[0] = as, $3[1] = children, $3[2] = ref, $3[3] = t0) : t0 = $3[3], t0;
});
SrOnly.displayName = "ForwardRef(SrOnly)";
var StyledVirtualList = dt.div.withConfig({
  displayName: "StyledVirtualList",
  componentId: "sc-dlqsj4-0"
})`position:relative;`;
var ItemWrapper = dt.div.withConfig({
  displayName: "ItemWrapper",
  componentId: "sc-dlqsj4-1"
})`position:absolute;left:0;right:0;`;
var VirtualList = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(44);
  let getItemKey, onChange2, renderItem, restProps, t0, t1, t22;
  $3[0] !== props ? ({
    as: t0,
    gap: t1,
    getItemKey,
    items: t22,
    onChange: onChange2,
    renderItem,
    ...restProps
  } = props, $3[0] = props, $3[1] = getItemKey, $3[2] = onChange2, $3[3] = renderItem, $3[4] = restProps, $3[5] = t0, $3[6] = t1, $3[7] = t22) : (getItemKey = $3[1], onChange2 = $3[2], renderItem = $3[3], restProps = $3[4], t0 = $3[5], t1 = $3[6], t22 = $3[7]);
  const as = t0 === void 0 ? "div" : t0, gap = t1 === void 0 ? 0 : t1;
  let t3;
  $3[8] !== t22 ? (t3 = t22 === void 0 ? [] : t22, $3[8] = t22, $3[9] = t3) : t3 = $3[9];
  const items = t3, {
    space
  } = useTheme_v2(), ref = (0, import_react.useRef)(null), wrapperRef = (0, import_react.useRef)(null), [scrollTop, setScrollTop] = (0, import_react.useState)(0), [scrollHeight, setScrollHeight] = (0, import_react.useState)(0), [itemHeight, setItemHeight] = (0, import_react.useState)(-1);
  let t4;
  $3[10] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => ref.current, $3[10] = t4) : t4 = $3[10], (0, import_react.useImperativeHandle)(forwardedRef, t4);
  let t5;
  $3[11] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => {
    if (!wrapperRef.current)
      return;
    const firstElement = wrapperRef.current.firstChild;
    firstElement instanceof HTMLElement && setItemHeight(firstElement.offsetHeight);
  }, $3[11] = t5) : t5 = $3[11];
  let t6;
  $3[12] !== renderItem ? (t6 = [renderItem], $3[12] = renderItem, $3[13] = t6) : t6 = $3[13], (0, import_react.useEffect)(t5, t6);
  let t7, t8;
  $3[14] === Symbol.for("react.memo_cache_sentinel") ? (t7 = () => {
    if (!ref.current)
      return;
    const scrollEl = findScrollable(ref.current.parentNode);
    if (scrollEl) {
      if (!(scrollEl instanceof HTMLElement))
        return;
      const handleScroll = () => {
        setScrollTop(scrollEl.scrollTop);
      };
      scrollEl.addEventListener("scroll", handleScroll, {
        passive: true
      });
      const ro2 = new _ResizeObserver((entries) => {
        setScrollHeight(entries[0].contentRect.height);
      });
      return ro2.observe(scrollEl), handleScroll(), () => {
        scrollEl.removeEventListener("scroll", handleScroll), ro2.unobserve(scrollEl), ro2.disconnect();
      };
    }
    const handleScroll_0 = () => {
      setScrollTop(window.scrollY);
    }, handleResize = () => {
      setScrollHeight(window.innerHeight);
    };
    return window.addEventListener("scroll", handleScroll_0, {
      passive: true
    }), window.addEventListener("resize", handleResize), setScrollHeight(window.innerHeight), handleScroll_0(), () => {
      window.removeEventListener("scroll", handleScroll_0), window.removeEventListener("resize", handleResize);
    };
  }, t8 = [], $3[14] = t7, $3[15] = t8) : (t7 = $3[14], t8 = $3[15]), (0, import_react.useEffect)(t7, t8);
  const len = items.length, height = itemHeight ? len * (itemHeight + space[gap]) - space[gap] : 0, fromIndex = height ? Math.max(Math.floor(scrollTop / height * len) - 2, 0) : 0, toIndex = height ? Math.ceil((scrollTop + scrollHeight) / height * len) + 1 : 0;
  let t10, t9;
  $3[16] !== fromIndex || $3[17] !== gap || $3[18] !== itemHeight || $3[19] !== onChange2 || $3[20] !== scrollHeight || $3[21] !== scrollTop || $3[22] !== space || $3[23] !== toIndex ? (t9 = () => {
    onChange2 && onChange2({
      fromIndex,
      gap: space[gap],
      itemHeight,
      scrollHeight,
      scrollTop,
      toIndex
    });
  }, t10 = [fromIndex, gap, itemHeight, onChange2, scrollHeight, scrollTop, space, toIndex], $3[16] = fromIndex, $3[17] = gap, $3[18] = itemHeight, $3[19] = onChange2, $3[20] = scrollHeight, $3[21] = scrollTop, $3[22] = space, $3[23] = toIndex, $3[24] = t10, $3[25] = t9) : (t10 = $3[24], t9 = $3[25]), (0, import_react.useEffect)(t9, t10);
  let t11;
  $3[26] !== fromIndex || $3[27] !== gap || $3[28] !== getItemKey || $3[29] !== itemHeight || $3[30] !== items || $3[31] !== renderItem || $3[32] !== space || $3[33] !== toIndex ? (t11 = {
    fromIndex,
    gap,
    itemHeight,
    space,
    toIndex,
    getItemKey,
    items,
    renderItem
  }, $3[26] = fromIndex, $3[27] = gap, $3[28] = getItemKey, $3[29] = itemHeight, $3[30] = items, $3[31] = renderItem, $3[32] = space, $3[33] = toIndex, $3[34] = t11) : t11 = $3[34];
  const children = useChildren(t11);
  let t12;
  $3[35] !== height ? (t12 = {
    height
  }, $3[35] = height, $3[36] = t12) : t12 = $3[36];
  let t13;
  $3[37] !== children || $3[38] !== t12 ? (t13 = (0, import_jsx_runtime.jsx)("div", { ref: wrapperRef, style: t12, children }), $3[37] = children, $3[38] = t12, $3[39] = t13) : t13 = $3[39];
  let t14;
  return $3[40] !== as || $3[41] !== restProps || $3[42] !== t13 ? (t14 = (0, import_jsx_runtime.jsx)(StyledVirtualList, { as, "data-ui": "VirtualList", ...restProps, ref, children: t13 }), $3[40] = as, $3[41] = restProps, $3[42] = t13, $3[43] = t14) : t14 = $3[43], t14;
});
VirtualList.displayName = "ForwardRef(VirtualList)";
function useChildren(t0) {
  const $3 = (0, import_react_compiler_runtime.c)(21), {
    fromIndex,
    gap,
    getItemKey,
    itemHeight,
    items,
    renderItem,
    space,
    toIndex
  } = t0;
  if (!renderItem || items.length === 0)
    return null;
  if (itemHeight === -1) {
    let t12;
    $3[0] !== items[0] || $3[1] !== renderItem ? (t12 = renderItem(items[0]), $3[0] = items[0], $3[1] = renderItem, $3[2] = t12) : t12 = $3[2];
    let t22;
    return $3[3] !== t12 ? (t22 = [(0, import_jsx_runtime.jsx)(ItemWrapper, { children: t12 }, 0)], $3[3] = t12, $3[4] = t22) : t22 = $3[4], t22;
  }
  let t1;
  if ($3[5] !== fromIndex || $3[6] !== gap || $3[7] !== getItemKey || $3[8] !== itemHeight || $3[9] !== items || $3[10] !== renderItem || $3[11] !== space || $3[12] !== toIndex) {
    let t22;
    $3[14] !== fromIndex || $3[15] !== gap || $3[16] !== getItemKey || $3[17] !== itemHeight || $3[18] !== renderItem || $3[19] !== space ? (t22 = (item, _itemIndex) => {
      const itemIndex = fromIndex + _itemIndex, node2 = renderItem(item), key2 = getItemKey ? getItemKey(item, itemIndex) : itemIndex;
      return (0, import_jsx_runtime.jsx)(ItemWrapper, { style: {
        top: itemIndex * (itemHeight + space[gap])
      }, children: node2 }, key2);
    }, $3[14] = fromIndex, $3[15] = gap, $3[16] = getItemKey, $3[17] = itemHeight, $3[18] = renderItem, $3[19] = space, $3[20] = t22) : t22 = $3[20], t1 = items.slice(fromIndex, toIndex).map(t22), $3[5] = fromIndex, $3[6] = gap, $3[7] = getItemKey, $3[8] = itemHeight, $3[9] = items, $3[10] = renderItem, $3[11] = space, $3[12] = toIndex, $3[13] = t1;
  } else
    t1 = $3[13];
  return t1;
}
function findScrollable(parentNode) {
  let _scrollEl = parentNode;
  for (; _scrollEl && !_isScrollable(_scrollEl); )
    _scrollEl = _scrollEl.parentNode;
  return _scrollEl;
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  return mayWarn ? element.ref : (getter = Object.getOwnPropertyDescriptor(element, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning, mayWarn ? element.props.ref : element.props.ref || element.ref);
}
var DEFAULT_POPOVER_DISTANCE = 4;
var DEFAULT_POPOVER_PADDING = 4;
var DEFAULT_POPOVER_ARROW_WIDTH = 19;
var DEFAULT_POPOVER_ARROW_HEIGHT = 8;
var DEFAULT_POPOVER_ARROW_RADIUS = 2;
var DEFAULT_POPOVER_MARGINS = [0, 0, 0, 0];
var DEFAULT_FALLBACK_PLACEMENTS$1 = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
function size(options2) {
  const {
    constrainSize,
    margins,
    matchReferenceWidth,
    maxWidthRef,
    padding = 0,
    referenceWidthRef,
    setReferenceWidth,
    widthRef
  } = options2;
  return {
    name: "@sanity/ui/size",
    async fn(args) {
      const {
        elements,
        placement,
        platform,
        rects
      } = args, {
        floating,
        reference
      } = rects, overflow = await detectOverflow(args, {
        altBoundary: true,
        boundary: options2.boundaryElement || void 0,
        elementContext: "floating",
        padding,
        rootBoundary: "viewport"
      });
      let maxWidth = 1 / 0, maxHeight = 1 / 0;
      const floatingW = floating.width, floatingH = floating.height;
      placement.includes("top") && (maxWidth = floatingW - (overflow.left + overflow.right), maxHeight = floatingH - overflow.top), placement.includes("right") && (maxWidth = floatingW - overflow.right, maxHeight = floatingH - (overflow.top + overflow.bottom)), placement.includes("bottom") && (maxWidth = floatingW - (overflow.left + overflow.right), maxHeight = floatingH - overflow.bottom), placement.includes("left") && (maxWidth = floatingW - overflow.left, maxHeight = floatingH - (overflow.top + overflow.bottom));
      const availableWidth = maxWidth - margins[1] - margins[3], availableHeight = maxHeight - margins[0] - margins[2], referenceWidth = reference.width - margins[1] - margins[3];
      referenceWidthRef.current = referenceWidth, setReferenceWidth(referenceWidth), matchReferenceWidth ? elements.floating.style.width = `${referenceWidth}px` : widthRef.current !== void 0 && (elements.floating.style.width = `${widthRef.current}px`), constrainSize && (elements.floating.style.maxWidth = `${Math.min(availableWidth, maxWidthRef.current ?? 1 / 0)}px`, elements.floating.style.maxHeight = `${availableHeight}px`);
      const nextDimensions = await platform.getDimensions(elements.floating), targetH = nextDimensions.height, targetW = nextDimensions.width;
      return floatingW !== targetW || floatingH !== targetH ? {
        reset: {
          rects: true
        }
      } : {};
    }
  };
}
function calcCurrentWidth(params) {
  const {
    container: container2,
    mediaIndex,
    width
  } = params, w3 = width[mediaIndex], currentWidth = w3 === void 0 ? width[width.length - 1] : w3;
  return typeof currentWidth == "number" ? container2[currentWidth] : void 0;
}
function calcMaxWidth(params) {
  const {
    boundaryWidth,
    currentWidth
  } = params;
  if (!(currentWidth === void 0 && boundaryWidth === void 0))
    return Math.min(currentWidth ?? 1 / 0, (boundaryWidth || 1 / 0) - DEFAULT_POPOVER_PADDING * 2);
}
var MotionCard$1 = dt(motion.create(Card)).withConfig({
  displayName: "MotionCard",
  componentId: "sc-ihg31s-0"
})`&:not([hidden]){display:flex;}flex-direction:column;width:max-content;min-width:min-content;will-change:transform;`;
var MotionFlex = dt(motion.create(Flex)).withConfig({
  displayName: "MotionFlex",
  componentId: "sc-ihg31s-1"
})`will-change:opacity;`;
var PopoverCard = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(66);
  let animate, arrow2, arrowRef, arrowX, arrowY, children, marginsProp, originX, originY, overflow, padding, placement, radius, restProps, scheme, shadow, strategy, style, tone, width, xProp, yProp;
  $3[0] !== props ? ({
    __unstable_margins: marginsProp,
    animate,
    arrow: arrow2,
    arrowRef,
    arrowX,
    arrowY,
    children,
    padding,
    placement,
    originX,
    originY,
    overflow,
    radius,
    scheme,
    shadow,
    strategy,
    style,
    tone,
    width,
    x: xProp,
    y: yProp,
    ...restProps
  } = props, $3[0] = props, $3[1] = animate, $3[2] = arrow2, $3[3] = arrowRef, $3[4] = arrowX, $3[5] = arrowY, $3[6] = children, $3[7] = marginsProp, $3[8] = originX, $3[9] = originY, $3[10] = overflow, $3[11] = padding, $3[12] = placement, $3[13] = radius, $3[14] = restProps, $3[15] = scheme, $3[16] = shadow, $3[17] = strategy, $3[18] = style, $3[19] = tone, $3[20] = width, $3[21] = xProp, $3[22] = yProp) : (animate = $3[1], arrow2 = $3[2], arrowRef = $3[3], arrowX = $3[4], arrowY = $3[5], children = $3[6], marginsProp = $3[7], originX = $3[8], originY = $3[9], overflow = $3[10], padding = $3[11], placement = $3[12], radius = $3[13], restProps = $3[14], scheme = $3[15], shadow = $3[16], strategy = $3[17], style = $3[18], tone = $3[19], width = $3[20], xProp = $3[21], yProp = $3[22]);
  const {
    zIndex
  } = useLayer(), margins = marginsProp || DEFAULT_POPOVER_MARGINS, x3 = (xProp ?? 0) + margins[3], y2 = (yProp ?? 0) + margins[0], t0 = animate ? "transform" : void 0;
  let t1;
  $3[23] !== originX || $3[24] !== originY || $3[25] !== strategy || $3[26] !== style || $3[27] !== t0 || $3[28] !== width || $3[29] !== x3 || $3[30] !== y2 || $3[31] !== zIndex ? (t1 = {
    left: x3,
    originX,
    originY,
    position: strategy,
    top: y2,
    width,
    zIndex,
    willChange: t0,
    ...style
  }, $3[23] = originX, $3[24] = originY, $3[25] = strategy, $3[26] = style, $3[27] = t0, $3[28] = width, $3[29] = x3, $3[30] = y2, $3[31] = zIndex, $3[32] = t1) : t1 = $3[32];
  const rootStyle2 = t1, t22 = arrowX !== null ? arrowX : void 0, t3 = arrowY !== null ? arrowY : void 0;
  let t4;
  $3[33] !== t22 || $3[34] !== t3 ? (t4 = {
    left: t22,
    top: t3,
    right: void 0,
    bottom: void 0
  }, $3[33] = t22, $3[34] = t3, $3[35] = t4) : t4 = $3[35];
  const arrowStyle = t4, t5 = restProps;
  let t6;
  $3[36] !== animate ? (t6 = animate ? ["hidden", "initial"] : void 0, $3[36] = animate, $3[37] = t6) : t6 = $3[37];
  let t7;
  $3[38] !== animate ? (t7 = animate ? ["visible", "scaleIn"] : void 0, $3[38] = animate, $3[39] = t7) : t7 = $3[39];
  let t8;
  $3[40] !== animate ? (t8 = animate ? ["hidden", "scaleOut"] : void 0, $3[40] = animate, $3[41] = t8) : t8 = $3[41];
  let t9;
  $3[42] !== children || $3[43] !== padding ? (t9 = (0, import_jsx_runtime.jsx)(Flex, { direction: "column", flex: 1, padding, children }), $3[42] = children, $3[43] = padding, $3[44] = t9) : t9 = $3[44];
  let t10;
  $3[45] !== overflow || $3[46] !== t9 ? (t10 = (0, import_jsx_runtime.jsx)(MotionFlex, { "data-ui": "Popover__wrapper", direction: "column", flex: 1, overflow, variants: POPOVER_MOTION_PROPS.children, transition: POPOVER_MOTION_PROPS.transition, children: t9 }), $3[45] = overflow, $3[46] = t9, $3[47] = t10) : t10 = $3[47];
  let t11;
  $3[48] !== arrow2 || $3[49] !== arrowRef || $3[50] !== arrowStyle ? (t11 = arrow2 && (0, import_jsx_runtime.jsx)(Arrow, { ref: arrowRef, style: arrowStyle, width: DEFAULT_POPOVER_ARROW_WIDTH, height: DEFAULT_POPOVER_ARROW_HEIGHT, radius: DEFAULT_POPOVER_ARROW_RADIUS }), $3[48] = arrow2, $3[49] = arrowRef, $3[50] = arrowStyle, $3[51] = t11) : t11 = $3[51];
  let t12;
  return $3[52] !== placement || $3[53] !== radius || $3[54] !== ref || $3[55] !== rootStyle2 || $3[56] !== scheme || $3[57] !== shadow || $3[58] !== t10 || $3[59] !== t11 || $3[60] !== t5 || $3[61] !== t6 || $3[62] !== t7 || $3[63] !== t8 || $3[64] !== tone ? (t12 = (0, import_jsx_runtime.jsxs)(MotionCard$1, { "data-ui": "Popover", ...t5, "data-placement": placement, radius, ref, scheme, shadow, sizing: "border", style: rootStyle2, tone, variants: POPOVER_MOTION_PROPS.card, transition: POPOVER_MOTION_PROPS.transition, initial: t6, animate: t7, exit: t8, children: [
    t10,
    t11
  ] }), $3[52] = placement, $3[53] = radius, $3[54] = ref, $3[55] = rootStyle2, $3[56] = scheme, $3[57] = shadow, $3[58] = t10, $3[59] = t11, $3[60] = t5, $3[61] = t6, $3[62] = t7, $3[63] = t8, $3[64] = tone, $3[65] = t12) : t12 = $3[65], t12;
});
PopoverCard.displayName = "ForwardRef(PopoverCard)";
var ViewportOverlay = () => {
  const $3 = (0, import_react_compiler_runtime.c)(2), {
    zIndex
  } = useLayer();
  let t0;
  return $3[0] !== zIndex ? (t0 = (0, import_jsx_runtime.jsx)("div", { style: {
    height: "100vh",
    inset: 0,
    position: "fixed",
    width: "100vw",
    zIndex
  } }), $3[0] = zIndex, $3[1] = t0) : t0 = $3[1], t0;
};
var Popover = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(126), {
    container: container2,
    layer
  } = useTheme_v2(), boundaryElementContext = useBoundaryElement();
  let _boundaryElement, _fallbackPlacements, _floatingBoundary, _referenceBoundary, _zOffsetProp, childProp, content2, disabled, matchReferenceWidth, modal, open, paddingProp, portal, referenceElement, restProps, scheme, t0, t1, t10, t11, t22, t3, t4, t5, t6, t7, t8, t9, updateRef;
  if ($3[0] !== props) {
    const {
      __unstable_margins: t122,
      animate: t132,
      arrow: t142,
      boundaryElement: t152,
      children: t162,
      constrainSize: t172,
      content: t182,
      disabled: t192,
      fallbackPlacements: t202,
      matchReferenceWidth: t212,
      floatingBoundary: t2222,
      modal: t232,
      onActivate,
      open: t242,
      overflow: t252,
      padding: t262,
      placement: t272,
      placementStrategy: t282,
      portal: t292,
      preventOverflow: t302,
      radius: t312,
      referenceBoundary: t322,
      referenceElement: t332,
      scheme: t342,
      shadow: t352,
      tone: t362,
      width: t372,
      zOffset: t382,
      updateRef: t392,
      ...t402
    } = props;
    t0 = t122, t1 = t132, t22 = t142, _boundaryElement = t152, childProp = t162, t3 = t172, content2 = t182, disabled = t192, _fallbackPlacements = t202, matchReferenceWidth = t212, _floatingBoundary = t2222, modal = t232, open = t242, t4 = t252, paddingProp = t262, t5 = t272, t6 = t282, portal = t292, t7 = t302, t8 = t312, _referenceBoundary = t322, referenceElement = t332, scheme = t342, t9 = t352, t10 = t362, t11 = t372, _zOffsetProp = t382, updateRef = t392, restProps = t402, $3[0] = props, $3[1] = _boundaryElement, $3[2] = _fallbackPlacements, $3[3] = _floatingBoundary, $3[4] = _referenceBoundary, $3[5] = _zOffsetProp, $3[6] = childProp, $3[7] = content2, $3[8] = disabled, $3[9] = matchReferenceWidth, $3[10] = modal, $3[11] = open, $3[12] = paddingProp, $3[13] = portal, $3[14] = referenceElement, $3[15] = restProps, $3[16] = scheme, $3[17] = t0, $3[18] = t1, $3[19] = t10, $3[20] = t11, $3[21] = t22, $3[22] = t3, $3[23] = t4, $3[24] = t5, $3[25] = t6, $3[26] = t7, $3[27] = t8, $3[28] = t9, $3[29] = updateRef;
  } else
    _boundaryElement = $3[1], _fallbackPlacements = $3[2], _floatingBoundary = $3[3], _referenceBoundary = $3[4], _zOffsetProp = $3[5], childProp = $3[6], content2 = $3[7], disabled = $3[8], matchReferenceWidth = $3[9], modal = $3[10], open = $3[11], paddingProp = $3[12], portal = $3[13], referenceElement = $3[14], restProps = $3[15], scheme = $3[16], t0 = $3[17], t1 = $3[18], t10 = $3[19], t11 = $3[20], t22 = $3[21], t3 = $3[22], t4 = $3[23], t5 = $3[24], t6 = $3[25], t7 = $3[26], t8 = $3[27], t9 = $3[28], updateRef = $3[29];
  const margins = t0 === void 0 ? DEFAULT_POPOVER_MARGINS : t0, _animate = t1 === void 0 ? false : t1, arrowProp = t22 === void 0 ? false : t22, constrainSize = t3 === void 0 ? false : t3, overflow = t4 === void 0 ? "hidden" : t4, placementProp = t5 === void 0 ? "bottom" : t5, placementStrategy = t6 === void 0 ? "flip" : t6, preventOverflow = t7 === void 0 ? true : t7, radiusProp = t8 === void 0 ? 3 : t8, shadowProp = t9 === void 0 ? 3 : t9, tone = t10 === void 0 ? "inherit" : t10, widthProp = t11 === void 0 ? "auto" : t11, boundaryElement = _boundaryElement ?? boundaryElementContext?.element, fallbackPlacements = _fallbackPlacements ?? DEFAULT_FALLBACK_PLACEMENTS$1[props.placement ?? "bottom"], floatingBoundary = _floatingBoundary ?? props.boundaryElement ?? boundaryElementContext.element, referenceBoundary = _referenceBoundary ?? props.boundaryElement ?? boundaryElementContext.element, zOffsetProp = _zOffsetProp ?? layer.popover.zOffset, animate = usePrefersReducedMotion() ? false : _animate, boundarySize = useElementSize(boundaryElement)?.border;
  let t12;
  $3[30] !== paddingProp ? (t12 = _getArrayProp(paddingProp), $3[30] = paddingProp, $3[31] = t12) : t12 = $3[31];
  const padding = t12;
  let t13;
  $3[32] !== radiusProp ? (t13 = _getArrayProp(radiusProp), $3[32] = radiusProp, $3[33] = t13) : t13 = $3[33];
  const radius = t13;
  let t14;
  $3[34] !== shadowProp ? (t14 = _getArrayProp(shadowProp), $3[34] = shadowProp, $3[35] = t14) : t14 = $3[35];
  const shadow = t14, widthArrayProp = _getArrayProp(widthProp);
  let t15;
  $3[36] !== zOffsetProp ? (t15 = _getArrayProp(zOffsetProp), $3[36] = zOffsetProp, $3[37] = t15) : t15 = $3[37];
  const zOffset = t15, ref = (0, import_react.useRef)(null), arrowRef = (0, import_react.useRef)(null);
  let t16;
  $3[38] === Symbol.for("react.memo_cache_sentinel") ? (t16 = () => ref.current, $3[38] = t16) : t16 = $3[38], (0, import_react.useImperativeHandle)(forwardedRef, t16);
  const mediaIndex = useMediaIndex(), boundaryWidth = constrainSize || preventOverflow ? boundarySize?.width : void 0, width = calcCurrentWidth({
    container: container2,
    mediaIndex,
    width: widthArrayProp
  }), widthRef = (0, import_react.useRef)(width);
  let t17, t18;
  $3[39] !== width ? (t17 = () => {
    widthRef.current = width;
  }, t18 = [width], $3[39] = width, $3[40] = t17, $3[41] = t18) : (t17 = $3[40], t18 = $3[41]), (0, import_react.useEffect)(t17, t18);
  let t19;
  $3[42] !== boundaryWidth || $3[43] !== width ? (t19 = calcMaxWidth({
    boundaryWidth,
    currentWidth: width
  }), $3[42] = boundaryWidth, $3[43] = width, $3[44] = t19) : t19 = $3[44];
  const maxWidth = t19, maxWidthRef = (0, import_react.useRef)(maxWidth);
  let t20, t21;
  $3[45] !== maxWidth ? (t20 = () => {
    maxWidthRef.current = maxWidth;
  }, t21 = [maxWidth], $3[45] = maxWidth, $3[46] = t20, $3[47] = t21) : (t20 = $3[46], t21 = $3[47]), (0, import_react.useEffect)(t20, t21);
  const referenceWidthRef = (0, import_react.useRef)(void 0);
  let t222, t23;
  $3[48] !== matchReferenceWidth || $3[49] !== maxWidth || $3[50] !== open || $3[51] !== width ? (t222 = () => {
    const floatingElement = ref.current;
    if (!open || !floatingElement)
      return;
    const referenceWidth = referenceWidthRef.current;
    matchReferenceWidth ? referenceWidth !== void 0 && (floatingElement.style.width = `${referenceWidth}px`) : width !== void 0 && (floatingElement.style.width = `${width}px`), typeof maxWidth == "number" && (floatingElement.style.maxWidth = `${maxWidth}px`);
  }, t23 = [width, matchReferenceWidth, maxWidth, open], $3[48] = matchReferenceWidth, $3[49] = maxWidth, $3[50] = open, $3[51] = width, $3[52] = t222, $3[53] = t23) : (t222 = $3[52], t23 = $3[53]), (0, import_react.useEffect)(t222, t23);
  const [referenceWidth_0, setReferenceWidth] = (0, import_react.useState)(void 0);
  let t24;
  $3[54] !== animate || $3[55] !== arrowProp || $3[56] !== constrainSize || $3[57] !== fallbackPlacements || $3[58] !== floatingBoundary || $3[59] !== margins || $3[60] !== matchReferenceWidth || $3[61] !== placementProp || $3[62] !== placementStrategy || $3[63] !== preventOverflow || $3[64] !== referenceBoundary ? (t24 = {
    animate,
    arrowProp,
    arrowRef,
    constrainSize,
    fallbackPlacements,
    floatingBoundary,
    margins,
    matchReferenceWidth,
    maxWidthRef,
    placementProp,
    placementStrategy,
    preventOverflow,
    referenceBoundary,
    referenceWidthRef,
    rootBoundary: "viewport",
    setReferenceWidth,
    widthRef
  }, $3[54] = animate, $3[55] = arrowProp, $3[56] = constrainSize, $3[57] = fallbackPlacements, $3[58] = floatingBoundary, $3[59] = margins, $3[60] = matchReferenceWidth, $3[61] = placementProp, $3[62] = placementStrategy, $3[63] = preventOverflow, $3[64] = referenceBoundary, $3[65] = t24) : t24 = $3[65];
  const middleware2 = useMiddleware$1(t24);
  let t25;
  $3[66] !== referenceElement ? (t25 = referenceElement ? {
    reference: referenceElement
  } : void 0, $3[66] = referenceElement, $3[67] = t25) : t25 = $3[67];
  let t26;
  $3[68] !== middleware2 || $3[69] !== placementProp || $3[70] !== t25 ? (t26 = {
    middleware: middleware2,
    placement: placementProp,
    whileElementsMounted: autoUpdate,
    elements: t25
  }, $3[68] = middleware2, $3[69] = placementProp, $3[70] = t25, $3[71] = t26) : t26 = $3[71];
  const {
    x: x3,
    y: y2,
    middlewareData,
    placement,
    refs,
    strategy,
    update
  } = useFloating(t26), referenceHidden = middlewareData.hide?.referenceHidden, arrowX = middlewareData.arrow?.x, arrowY = middlewareData.arrow?.y, originX = middlewareData["@sanity/ui/origin"]?.originX, originY = middlewareData["@sanity/ui/origin"]?.originY;
  let t27;
  $3[72] === Symbol.for("react.memo_cache_sentinel") ? (t27 = (arrowEl) => {
    arrowRef.current = arrowEl;
  }, $3[72] = t27) : t27 = $3[72];
  const setArrow = t27;
  let t28;
  $3[73] !== refs ? (t28 = (node2) => {
    ref.current = node2, refs.setFloating(node2);
  }, $3[73] = refs, $3[74] = t28) : t28 = $3[74];
  const setFloating = t28;
  let t29;
  $3[75] !== childProp ? (t29 = childProp ? getElementRef(childProp) : null, $3[75] = childProp, $3[76] = t29) : t29 = $3[76];
  let t30;
  $3[77] !== refs.reference.current ? (t30 = () => refs.reference.current, $3[77] = refs.reference.current, $3[78] = t30) : t30 = $3[78], (0, import_react.useImperativeHandle)(t29, t30);
  let t31;
  bb0: {
    if (referenceElement) {
      t31 = childProp;
      break bb0;
    }
    if (!childProp) {
      t31 = null;
      break bb0;
    }
    let t322;
    $3[79] !== childProp || $3[80] !== refs.setReference ? (t322 = (0, import_react.cloneElement)(childProp, {
      ref: refs.setReference
    }), $3[79] = childProp, $3[80] = refs.setReference, $3[81] = t322) : t322 = $3[81], t31 = t322;
  }
  const child = t31;
  let t32, t33;
  if ($3[82] !== update ? (t32 = () => update, t33 = [update], $3[82] = update, $3[83] = t32, $3[84] = t33) : (t32 = $3[83], t33 = $3[84]), (0, import_react.useImperativeHandle)(updateRef, t32, t33), disabled) {
    let t342;
    return $3[85] !== childProp ? (t342 = childProp || (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {}), $3[85] = childProp, $3[86] = t342) : t342 = $3[86], t342;
  }
  let t34;
  $3[87] !== modal ? (t34 = modal && (0, import_jsx_runtime.jsx)(ViewportOverlay, {}), $3[87] = modal, $3[88] = t34) : t34 = $3[88];
  const t35 = matchReferenceWidth ? referenceWidth_0 : width;
  let t36;
  $3[89] !== animate || $3[90] !== arrowProp || $3[91] !== arrowX || $3[92] !== arrowY || $3[93] !== content2 || $3[94] !== margins || $3[95] !== originX || $3[96] !== originY || $3[97] !== overflow || $3[98] !== padding || $3[99] !== placement || $3[100] !== radius || $3[101] !== referenceHidden || $3[102] !== restProps || $3[103] !== scheme || $3[104] !== setFloating || $3[105] !== shadow || $3[106] !== strategy || $3[107] !== t35 || $3[108] !== tone || $3[109] !== x3 || $3[110] !== y2 ? (t36 = (0, import_jsx_runtime.jsx)(PopoverCard, { ...restProps, __unstable_margins: margins, animate, arrow: arrowProp, arrowRef: setArrow, arrowX, arrowY, hidden: referenceHidden, overflow, padding, placement, radius, ref: setFloating, scheme, shadow, originX, originY, strategy, tone, width: t35, x: x3, y: y2, children: content2 }), $3[89] = animate, $3[90] = arrowProp, $3[91] = arrowX, $3[92] = arrowY, $3[93] = content2, $3[94] = margins, $3[95] = originX, $3[96] = originY, $3[97] = overflow, $3[98] = padding, $3[99] = placement, $3[100] = radius, $3[101] = referenceHidden, $3[102] = restProps, $3[103] = scheme, $3[104] = setFloating, $3[105] = shadow, $3[106] = strategy, $3[107] = t35, $3[108] = tone, $3[109] = x3, $3[110] = y2, $3[111] = t36) : t36 = $3[111];
  let t37;
  $3[112] !== t34 || $3[113] !== t36 || $3[114] !== zOffset ? (t37 = (0, import_jsx_runtime.jsxs)(LayerProvider, { zOffset, children: [
    t34,
    t36
  ] }), $3[112] = t34, $3[113] = t36, $3[114] = zOffset, $3[115] = t37) : t37 = $3[115];
  const popover = t37;
  let t38;
  $3[116] !== open || $3[117] !== popover || $3[118] !== portal ? (t38 = open && (portal ? (0, import_jsx_runtime.jsx)(Portal, { __unstable_name: typeof portal == "string" ? portal : void 0, children: popover }) : popover), $3[116] = open, $3[117] = popover, $3[118] = portal, $3[119] = t38) : t38 = $3[119];
  const children = t38;
  let t39;
  $3[120] !== animate || $3[121] !== children ? (t39 = animate ? (0, import_jsx_runtime.jsx)(AnimatePresence, { children }) : children, $3[120] = animate, $3[121] = children, $3[122] = t39) : t39 = $3[122];
  let t40;
  return $3[123] !== child || $3[124] !== t39 ? (t40 = (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    t39,
    child
  ] }), $3[123] = child, $3[124] = t39, $3[125] = t40) : t40 = $3[125], t40;
});
Popover.displayName = "ForwardRef(Popover)";
function useMiddleware$1(t0) {
  const $3 = (0, import_react_compiler_runtime.c)(42), {
    animate,
    arrowProp,
    arrowRef,
    constrainSize,
    fallbackPlacements,
    floatingBoundary,
    margins,
    matchReferenceWidth,
    maxWidthRef,
    placementProp,
    placementStrategy,
    preventOverflow,
    referenceBoundary,
    referenceWidthRef,
    rootBoundary,
    setReferenceWidth,
    widthRef
  } = t0;
  let ret;
  if ($3[0] !== animate || $3[1] !== arrowProp || $3[2] !== arrowRef || $3[3] !== constrainSize || $3[4] !== fallbackPlacements || $3[5] !== floatingBoundary || $3[6] !== margins || $3[7] !== matchReferenceWidth || $3[8] !== maxWidthRef || $3[9] !== placementProp || $3[10] !== placementStrategy || $3[11] !== preventOverflow || $3[12] !== referenceBoundary || $3[13] !== referenceWidthRef || $3[14] !== rootBoundary || $3[15] !== setReferenceWidth || $3[16] !== widthRef) {
    if (ret = [], constrainSize || preventOverflow)
      if (placementStrategy === "autoPlacement") {
        let t12;
        $3[18] !== fallbackPlacements || $3[19] !== placementProp ? (t12 = autoPlacement({
          allowedPlacements: [placementProp].concat(fallbackPlacements)
        }), $3[18] = fallbackPlacements, $3[19] = placementProp, $3[20] = t12) : t12 = $3[20], ret.push(t12);
      } else {
        const t12 = floatingBoundary || void 0;
        let t222;
        $3[21] !== fallbackPlacements || $3[22] !== rootBoundary || $3[23] !== t12 ? (t222 = flip({
          boundary: t12,
          fallbackPlacements,
          padding: DEFAULT_POPOVER_PADDING,
          rootBoundary
        }), $3[21] = fallbackPlacements, $3[22] = rootBoundary, $3[23] = t12, $3[24] = t222) : t222 = $3[24], ret.push(t222);
      }
    let t1;
    if ($3[25] === Symbol.for("react.memo_cache_sentinel") ? (t1 = offset({
      mainAxis: DEFAULT_POPOVER_DISTANCE
    }), $3[25] = t1) : t1 = $3[25], ret.push(t1), constrainSize || matchReferenceWidth) {
      const t222 = floatingBoundary || void 0;
      let t32;
      $3[26] !== constrainSize || $3[27] !== margins || $3[28] !== matchReferenceWidth || $3[29] !== maxWidthRef || $3[30] !== referenceWidthRef || $3[31] !== setReferenceWidth || $3[32] !== t222 || $3[33] !== widthRef ? (t32 = size({
        boundaryElement: t222,
        constrainSize,
        margins,
        matchReferenceWidth,
        maxWidthRef,
        padding: DEFAULT_POPOVER_PADDING,
        referenceWidthRef,
        setReferenceWidth,
        widthRef
      }), $3[26] = constrainSize, $3[27] = margins, $3[28] = matchReferenceWidth, $3[29] = maxWidthRef, $3[30] = referenceWidthRef, $3[31] = setReferenceWidth, $3[32] = t222, $3[33] = widthRef, $3[34] = t32) : t32 = $3[34], ret.push(t32);
    }
    if (preventOverflow) {
      const t222 = floatingBoundary || void 0;
      let t32;
      $3[35] !== rootBoundary || $3[36] !== t222 ? (t32 = shift({
        boundary: t222,
        rootBoundary,
        padding: DEFAULT_POPOVER_PADDING
      }), $3[35] = rootBoundary, $3[36] = t222, $3[37] = t32) : t32 = $3[37], ret.push(t32);
    }
    if (arrowProp) {
      let t222;
      $3[38] !== arrowRef ? (t222 = arrow({
        element: arrowRef,
        padding: DEFAULT_POPOVER_PADDING
      }), $3[38] = arrowRef, $3[39] = t222) : t222 = $3[39], ret.push(t222);
    }
    animate && ret.push(origin);
    const t22 = referenceBoundary || void 0;
    let t3;
    $3[40] !== t22 ? (t3 = hide({
      boundary: t22,
      padding: DEFAULT_POPOVER_PADDING,
      strategy: "referenceHidden"
    }), $3[40] = t22, $3[41] = t3) : t3 = $3[41], ret.push(t3), $3[0] = animate, $3[1] = arrowProp, $3[2] = arrowRef, $3[3] = constrainSize, $3[4] = fallbackPlacements, $3[5] = floatingBoundary, $3[6] = margins, $3[7] = matchReferenceWidth, $3[8] = maxWidthRef, $3[9] = placementProp, $3[10] = placementStrategy, $3[11] = preventOverflow, $3[12] = referenceBoundary, $3[13] = referenceWidthRef, $3[14] = rootBoundary, $3[15] = setReferenceWidth, $3[16] = widthRef, $3[17] = ret;
  } else
    ret = $3[17];
  return ret;
}
function radioBaseStyle() {
  return lt`
    position: relative;

    &:not([hidden]) {
      display: inline-block;
    }

    &[data-read-only] {
      outline: 1px solid red;
    }
  `;
}
function inputElementStyle(props) {
  const {
    color: color2,
    input
  } = getTheme_v2(props.theme), dist = (input.radio.size - input.radio.markSize) / 2;
  return lt`
    appearance: none;
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
    height: 100%;
    width: 100%;
    outline: none;
    z-index: 1;
    padding: 0;
    margin: 0;
    border-radius: ${rem(input.radio.size / 2)};
    border: none;

    /* enabled */
    & + span {
      display: block;
      position: relative;
      height: ${rem(input.radio.size)};
      width: ${rem(input.radio.size)};
      border-radius: ${rem(input.radio.size / 2)};
      background: ${color2.input.default.enabled.bg};
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};

      &::after {
        content: '';
        position: absolute;
        top: ${rem(dist)};
        left: ${rem(dist)};
        height: ${rem(input.radio.markSize)};
        width: ${rem(input.radio.markSize)};
        border-radius: ${rem(input.radio.markSize / 2)};
        background: ${color2.input.default.enabled.fg};
        opacity: 0;
      }
    }

    /* focused */
    &:not(:disabled):focus + span {
      box-shadow: ${focusRingStyle({
    border: {
      width: input.border.width,
      color: color2.input.default.enabled.border
    },
    focusRing: input.radio.focusRing
  })};
    }

    &:not(:disabled):focus:not(:focus-visible) + span {
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};
    }

    &:checked + span::after {
      opacity: 1;
    }

    /* customValidity */
    &[data-error] + span {
      background-color: ${color2.input.invalid.enabled.border};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color2.input.invalid.enabled.muted.bg
  })};
      &::after {
        background: ${color2.input.invalid.enabled.muted.bg};
      }
    }

    /* read only */
    &[data-read-only] + span {
      box-shadow: 0 0 0 1px ${color2.input.default.readOnly.border};
      background: ${color2.input.default.readOnly.bg};

      &::after {
        background: ${color2.input.default.readOnly.border};
      }
    }

    /* disabled */
    &:not([data-read-only]):disabled + span {
      box-shadow: 0 0 0 1px ${color2.input.default.disabled.border};
      background: ${color2.input.default.disabled.bg};

      &::after {
        background: ${color2.input.default.disabled.border};
      }
    }
  `;
}
var StyledRadio = dt.div.withConfig({
  displayName: "StyledRadio",
  componentId: "sc-ccrwkf-0"
})(radioBaseStyle);
var Input$4 = dt.input.withConfig({
  displayName: "Input",
  componentId: "sc-ccrwkf-1"
})(inputElementStyle);
var Radio = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(19);
  let className, customValidity, disabled, readOnly, restProps, style;
  $3[0] !== props ? ({
    className,
    disabled,
    style,
    customValidity,
    readOnly,
    ...restProps
  } = props, $3[0] = props, $3[1] = className, $3[2] = customValidity, $3[3] = disabled, $3[4] = readOnly, $3[5] = restProps, $3[6] = style) : (className = $3[1], customValidity = $3[2], disabled = $3[3], readOnly = $3[4], restProps = $3[5], style = $3[6]);
  const ref = (0, import_react.useRef)(null);
  let t0;
  $3[7] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $3[7] = t0) : t0 = $3[7], (0, import_react.useImperativeHandle)(forwardedRef, t0), useCustomValidity(ref, customValidity);
  const t1 = !disabled && readOnly ? "" : void 0, t22 = customValidity ? "" : void 0, t3 = disabled || readOnly;
  let t4;
  $3[8] !== readOnly || $3[9] !== restProps || $3[10] !== t1 || $3[11] !== t22 || $3[12] !== t3 ? (t4 = (0, import_jsx_runtime.jsx)(Input$4, { "data-read-only": t1, "data-error": t22, ...restProps, disabled: t3, readOnly, ref, type: "radio" }), $3[8] = readOnly, $3[9] = restProps, $3[10] = t1, $3[11] = t22, $3[12] = t3, $3[13] = t4) : t4 = $3[13];
  let t5;
  $3[14] === Symbol.for("react.memo_cache_sentinel") ? (t5 = (0, import_jsx_runtime.jsx)("span", {}), $3[14] = t5) : t5 = $3[14];
  let t6;
  return $3[15] !== className || $3[16] !== style || $3[17] !== t4 ? (t6 = (0, import_jsx_runtime.jsxs)(StyledRadio, { className, "data-ui": "Radio", style, children: [
    t4,
    t5
  ] }), $3[15] = className, $3[16] = style, $3[17] = t4, $3[18] = t6) : t6 = $3[18], t6;
});
Radio.displayName = "ForwardRef(Radio)";
function rootStyle() {
  return lt`
    position: relative;
    width: -moz-available;
    width: -webkit-fill-available;
    width: stretch;

    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
function inputBaseStyle(props) {
  const {
    font
  } = getTheme_v2(props.theme);
  return lt`
    -webkit-font-smoothing: antialiased;
    appearance: none;
    border: 0;
    font-family: ${font.text.family};
    color: inherit;
    width: 100%;
    outline: none;
    margin: 0;

    &:disabled {
      opacity: 1;
    }
  `;
}
function inputColorStyle(props) {
  const {
    color: color2,
    input
  } = getTheme_v2(props.theme);
  return lt`
    /* enabled */
    background-color: ${color2.input.default.enabled.bg};
    color: ${color2.input.default.enabled.fg};
    box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};

    /* hovered */
    @media (hover: hover) {
      &:not(:disabled):hover {
        background-color: ${color2.input.default.hovered.bg};
        color: ${color2.input.default.hovered.fg};
        box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.hovered.border,
    width: input.border.width
  })};
      }
    }

    /* focused */
    &:not(:disabled):focus {
      box-shadow: ${focusRingStyle({
    border: {
      width: input.border.width,
      color: color2.input.default.enabled.border
    },
    focusRing: input.select.focusRing
  })};
    }

    /* read-only */
    &[data-read-only] {
      background-color: ${color2.input.default.readOnly.bg};
      color: ${color2.input.default.readOnly.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.readOnly.border,
    width: input.border.width
  })};
    }

    /* disabled */
    &:not([data-read-only]):disabled {
      background-color: ${color2.input.default.disabled.bg};
      color: ${color2.input.default.disabled.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.disabled.border,
    width: input.border.width
  })};
    }
  `;
}
function textSize(size2) {
  return {
    fontSize: rem(size2.fontSize),
    lineHeight: `${rem(size2.lineHeight)}`
  };
}
function inputTextSizeStyle(props) {
  const {
    $fontSize
  } = props, {
    font,
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, $fontSize, (sizeIndex) => textSize(font.text.sizes[sizeIndex] || font.text.sizes[2]));
}
function inputStyle() {
  return [responsiveRadiusStyle, inputBaseStyle, inputColorStyle, inputTextSizeStyle, responsiveInputPaddingIconRightStyle];
}
function iconBoxStyle(props) {
  const {
    color: color2
  } = getTheme_v2(props.theme);
  return lt`
    pointer-events: none;
    position: absolute;
    top: 0;
    right: 0;

    /* enabled */
    --card-fg-color: ${color2.input.default.enabled.fg};

    /* hover */
    @media (hover: hover) {
      select:not(disabled):not(:read-only):hover + && {
        --card-fg-color: ${color2.input.default.hovered.fg};
      }
    }

    /* disabled */
    select:disabled + && {
      --card-fg-color: ${color2.input.default.disabled.fg};
    }

    /* read-only */
    select[data-read-only] + && {
      --card-fg-color: ${color2.input.default.readOnly.fg};
    }
  `;
}
var selectStyle = {
  root: rootStyle,
  input: inputStyle,
  iconBox: iconBoxStyle
};
var StyledSelect = dt.div.withConfig({
  displayName: "StyledSelect",
  componentId: "sc-5mxno7-0"
})(selectStyle.root);
var Input$3 = dt.select.withConfig({
  displayName: "Input",
  componentId: "sc-5mxno7-1"
})(selectStyle.input);
var IconBox = dt(Box).withConfig({
  displayName: "IconBox",
  componentId: "sc-5mxno7-2"
})(selectStyle.iconBox);
var Select = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(37);
  let children, customValidity, disabled, readOnly, restProps, t0, t1, t22, t3;
  $3[0] !== props ? ({
    children,
    customValidity,
    disabled,
    fontSize: t0,
    padding: t1,
    radius: t22,
    readOnly,
    space: t3,
    ...restProps
  } = props, $3[0] = props, $3[1] = children, $3[2] = customValidity, $3[3] = disabled, $3[4] = readOnly, $3[5] = restProps, $3[6] = t0, $3[7] = t1, $3[8] = t22, $3[9] = t3) : (children = $3[1], customValidity = $3[2], disabled = $3[3], readOnly = $3[4], restProps = $3[5], t0 = $3[6], t1 = $3[7], t22 = $3[8], t3 = $3[9]);
  const fontSize2 = t0 === void 0 ? 2 : t0, padding = t1 === void 0 ? 3 : t1, radius = t22 === void 0 ? 2 : t22, space = t3 === void 0 ? 3 : t3, ref = (0, import_react.useRef)(null);
  let t4;
  $3[10] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => ref.current, $3[10] = t4) : t4 = $3[10], (0, import_react.useImperativeHandle)(forwardedRef, t4), useCustomValidity(ref, customValidity);
  const t5 = !disabled && readOnly ? "" : void 0;
  let t6;
  $3[11] !== fontSize2 ? (t6 = _getArrayProp(fontSize2), $3[11] = fontSize2, $3[12] = t6) : t6 = $3[12];
  let t7;
  $3[13] !== padding ? (t7 = _getArrayProp(padding), $3[13] = padding, $3[14] = t7) : t7 = $3[14];
  let t8;
  $3[15] !== radius ? (t8 = _getArrayProp(radius), $3[15] = radius, $3[16] = t8) : t8 = $3[16];
  let t9;
  $3[17] !== space ? (t9 = _getArrayProp(space), $3[17] = space, $3[18] = t9) : t9 = $3[18];
  const t10 = disabled || readOnly;
  let t11;
  $3[19] !== children || $3[20] !== restProps || $3[21] !== t10 || $3[22] !== t5 || $3[23] !== t6 || $3[24] !== t7 || $3[25] !== t8 || $3[26] !== t9 ? (t11 = (0, import_jsx_runtime.jsx)(Input$3, { "data-read-only": t5, "data-ui": "Select", ...restProps, $fontSize: t6, $padding: t7, $radius: t8, $space: t9, disabled: t10, ref, children }), $3[19] = children, $3[20] = restProps, $3[21] = t10, $3[22] = t5, $3[23] = t6, $3[24] = t7, $3[25] = t8, $3[26] = t9, $3[27] = t11) : t11 = $3[27];
  let t12;
  $3[28] === Symbol.for("react.memo_cache_sentinel") ? (t12 = (0, import_jsx_runtime.jsx)(ChevronDownIcon, {}), $3[28] = t12) : t12 = $3[28];
  let t13;
  $3[29] !== fontSize2 ? (t13 = (0, import_jsx_runtime.jsx)(Text, { size: fontSize2, children: t12 }), $3[29] = fontSize2, $3[30] = t13) : t13 = $3[30];
  let t14;
  $3[31] !== padding || $3[32] !== t13 ? (t14 = (0, import_jsx_runtime.jsx)(IconBox, { padding, children: t13 }), $3[31] = padding, $3[32] = t13, $3[33] = t14) : t14 = $3[33];
  let t15;
  return $3[34] !== t11 || $3[35] !== t14 ? (t15 = (0, import_jsx_runtime.jsxs)(StyledSelect, { "data-ui": "Select", children: [
    t11,
    t14
  ] }), $3[34] = t11, $3[35] = t14, $3[36] = t15) : t15 = $3[36], t15;
});
Select.displayName = "ForwardRef(Select)";
var BASE_STYLE = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  },
  gridTemplateColumns: "minmax(0, 1fr)",
  gridAutoRows: "min-content"
};
function stackBaseStyle() {
  return BASE_STYLE;
}
function responsiveStackSpaceStyle(props) {
  const {
    media: media2,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$space, (spaceIndex) => ({
    gridGap: rem(space[spaceIndex])
  }));
}
var StyledStack = dt(Box).withConfig({
  displayName: "StyledStack",
  componentId: "sc-8dpfq2-0"
})(stackBaseStyle, responsiveStackSpaceStyle);
var Stack = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(12);
  let as, restProps, space;
  $3[0] !== props ? ({
    as,
    space,
    ...restProps
  } = props, $3[0] = props, $3[1] = as, $3[2] = restProps, $3[3] = space) : (as = $3[1], restProps = $3[2], space = $3[3]);
  const t0 = typeof as == "string" ? as : void 0;
  let t1;
  $3[4] !== space ? (t1 = _getArrayProp(space), $3[4] = space, $3[5] = t1) : t1 = $3[5];
  let t22;
  return $3[6] !== as || $3[7] !== ref || $3[8] !== restProps || $3[9] !== t0 || $3[10] !== t1 ? (t22 = (0, import_jsx_runtime.jsx)(StyledStack, { "data-as": t0, "data-ui": "Stack", ...restProps, $space: t1, forwardedAs: as, ref }), $3[6] = as, $3[7] = ref, $3[8] = restProps, $3[9] = t0, $3[10] = t1, $3[11] = t22) : t22 = $3[11], t22;
});
Stack.displayName = "ForwardRef(Stack)";
function switchBaseStyles() {
  return lt`
    position: relative;
    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
function switchInputStyles() {
  return lt`
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    opacity: 0;
    height: 100%;
    width: 100%;
    outline: none;
    padding: 0;
    margin: 0;

    /* Place the input element above the representation element */
    z-index: 1;
  `;
}
function switchRepresentationStyles(props) {
  const {
    color: color2,
    input
  } = getTheme_v2(props.theme);
  return lt`
    --switch-bg-color: ${color2.input.default.enabled.border};
    --switch-fg-color: ${color2.input.default.enabled.bg};
    --switch-box-shadow: none;

    &:not([hidden]) {
      display: block;
    }
    position: relative;
    width: ${rem(input.switch.width)};
    height: ${rem(input.switch.height)};
    border-radius: ${rem(input.switch.height / 2)};

    /* Make sure it’s not possible to interact with the wrapper element */
    pointer-events: none;

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1;
      box-shadow: var(--switch-box-shadow);
      border-radius: inherit;
    }

    /* Focus styles */
    input:focus + && {
      --switch-box-shadow: ${focusRingStyle({
    focusRing: input.switch.focusRing
  })};
    }

    input:focus:not(:focus-visible) + && {
      --switch-box-shadow: none;
    }

    input:checked + && {
      --switch-bg-color: ${color2.input.default.enabled.fg};
      --switch-fg-color: ${color2.input.default.enabled.bg};
    }

    @media (hover: hover) {
      input:not(:disabled):hover + && {
        --switch-bg-color: ${color2.input.default.hovered.border};
        --switch-fg-color: ${color2.input.default.hovered.bg};
      }

      input:not(:disabled):checked:hover + && {
        --switch-bg-color: ${color2.input.default.enabled.fg};
        --switch-fg-color: ${color2.input.default.enabled.bg};
      }
    }

    input:not([data-read-only]):disabled + && {
      --switch-bg-color: ${color2.input.default.disabled.border};
      --switch-fg-color: ${color2.input.default.disabled.bg};
    }

    input[data-read-only]:disabled + && {
      --switch-bg-color: ${color2.input.default.readOnly.border};
      --switch-fg-color: ${color2.input.default.readOnly.bg};
    }

    input:checked[data-read-only]:disabled + && {
      --switch-bg-color: ${color2.input.default.readOnly.fg};
      --switch-fg-color: ${color2.input.default.readOnly.bg};
    }
  `;
}
function switchTrackStyles(props) {
  const {
    input
  } = getTheme_v2(props.theme);
  return lt`
    &:not([hidden]) {
      display: block;
    }
    background-color: var(--switch-bg-color);
    position: absolute;
    left: 0;
    top: 0;
    width: ${rem(input.switch.width)};
    height: ${rem(input.switch.height)};
    border-radius: ${rem(input.switch.height / 2)};
  `;
}
function switchThumbStyles(props) {
  const {
    $indeterminate
  } = props, {
    input
  } = getTheme_v2(props.theme), trackWidth = input.switch.width, trackHeight = input.switch.height, trackPadding = input.switch.padding, size2 = trackHeight - input.switch.padding * 2, checkedOffset = trackWidth - trackPadding * 2 - size2, indeterminateOffset = trackWidth / 2 - size2 / 2 - trackPadding, checked = $indeterminate !== true && props.$checked === true;
  return lt`
    &:not([hidden]) {
      display: block;
    }
    position: absolute;
    left: ${rem(trackPadding)};
    top: ${rem(trackPadding)};
    height: ${rem(size2)};
    width: ${rem(size2)};
    border-radius: ${rem(size2 / 2)};
    transition-property: transform;
    transition-duration: ${input.switch.transitionDurationMs}ms;
    transition-timing-function: ${input.switch.transitionTimingFunction};
    background: var(--switch-fg-color);
    transform: translate3d(0, 0, 0);
    box-shadow: 0px 1px 0px 0px rgba(0, 0, 0, 0.05);

    ${checked && lt`
      transform: translate3d(${checkedOffset}px, 0, 0);
    `}

    ${$indeterminate && lt`
      transform: translate3d(${indeterminateOffset}px, 0, 0);
    `}
  `;
}
var StyledSwitch = dt.span.withConfig({
  displayName: "StyledSwitch",
  componentId: "sc-dw1foe-0"
})(switchBaseStyles);
var Input$2 = dt.input.withConfig({
  displayName: "Input",
  componentId: "sc-dw1foe-1"
})(switchInputStyles);
var Representation = dt.span.withConfig({
  displayName: "Representation",
  componentId: "sc-dw1foe-2"
})(switchRepresentationStyles);
var Track = dt.span.withConfig({
  displayName: "Track",
  componentId: "sc-dw1foe-3"
})(switchTrackStyles);
var Thumb = dt.span.withConfig({
  displayName: "Thumb",
  componentId: "sc-dw1foe-4"
})(switchThumbStyles);
var Switch = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(26);
  let checked, className, disabled, indeterminate, readOnly, restProps, style;
  $3[0] !== props ? ({
    checked,
    className,
    disabled,
    indeterminate,
    readOnly,
    style,
    ...restProps
  } = props, $3[0] = props, $3[1] = checked, $3[2] = className, $3[3] = disabled, $3[4] = indeterminate, $3[5] = readOnly, $3[6] = restProps, $3[7] = style) : (checked = $3[1], className = $3[2], disabled = $3[3], indeterminate = $3[4], readOnly = $3[5], restProps = $3[6], style = $3[7]);
  const ref = (0, import_react.useRef)(null);
  let t0;
  $3[8] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $3[8] = t0) : t0 = $3[8], (0, import_react.useImperativeHandle)(forwardedRef, t0);
  let t1, t22;
  $3[9] !== indeterminate ? (t1 = () => {
    ref.current && (ref.current.indeterminate = indeterminate || false);
  }, t22 = [indeterminate], $3[9] = indeterminate, $3[10] = t1, $3[11] = t22) : (t1 = $3[10], t22 = $3[11]), (0, import_react.useEffect)(t1, t22);
  const t3 = !disabled && readOnly ? "" : void 0, t4 = indeterminate !== true && checked, t5 = disabled || readOnly;
  let t6;
  $3[12] !== restProps || $3[13] !== t3 || $3[14] !== t4 || $3[15] !== t5 ? (t6 = (0, import_jsx_runtime.jsx)(Input$2, { "data-read-only": t3, ...restProps, checked: t4, disabled: t5, type: "checkbox", ref }), $3[12] = restProps, $3[13] = t3, $3[14] = t4, $3[15] = t5, $3[16] = t6) : t6 = $3[16];
  let t7;
  $3[17] === Symbol.for("react.memo_cache_sentinel") ? (t7 = (0, import_jsx_runtime.jsx)(Track, {}), $3[17] = t7) : t7 = $3[17];
  let t8;
  $3[18] !== checked || $3[19] !== indeterminate ? (t8 = (0, import_jsx_runtime.jsxs)(Representation, { "aria-hidden": true, "data-name": "representation", children: [
    t7,
    (0, import_jsx_runtime.jsx)(Thumb, { $checked: checked, $indeterminate: indeterminate })
  ] }), $3[18] = checked, $3[19] = indeterminate, $3[20] = t8) : t8 = $3[20];
  let t9;
  return $3[21] !== className || $3[22] !== style || $3[23] !== t6 || $3[24] !== t8 ? (t9 = (0, import_jsx_runtime.jsxs)(StyledSwitch, { className, "data-ui": "Switch", style, children: [
    t6,
    t8
  ] }), $3[21] = className, $3[22] = style, $3[23] = t6, $3[24] = t8, $3[25] = t9) : t9 = $3[25], t9;
});
Switch.displayName = "ForwardRef(Switch)";
var StyledTextArea = dt.span.withConfig({
  displayName: "StyledTextArea",
  componentId: "sc-1d6h1o8-0"
})(textInputRootStyle);
var InputRoot$1 = dt.span.withConfig({
  displayName: "InputRoot",
  componentId: "sc-1d6h1o8-1"
})`flex:1;min-width:0;display:block;position:relative;`;
var Input$1 = dt.textarea.withConfig({
  displayName: "Input",
  componentId: "sc-1d6h1o8-2"
})(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
var Presentation$1 = dt.div.withConfig({
  displayName: "Presentation",
  componentId: "sc-1d6h1o8-3"
})(responsiveRadiusStyle, textInputRepresentationStyle);
var TextArea = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(35);
  let __unstable_disableFocusRing, customValidity, restProps, t0, t1, t22, t3, t4, weight;
  $3[0] !== props ? ({
    border: t0,
    customValidity,
    disabled: t1,
    fontSize: t22,
    padding: t3,
    radius: t4,
    weight,
    __unstable_disableFocusRing,
    ...restProps
  } = props, $3[0] = props, $3[1] = __unstable_disableFocusRing, $3[2] = customValidity, $3[3] = restProps, $3[4] = t0, $3[5] = t1, $3[6] = t22, $3[7] = t3, $3[8] = t4, $3[9] = weight) : (__unstable_disableFocusRing = $3[1], customValidity = $3[2], restProps = $3[3], t0 = $3[4], t1 = $3[5], t22 = $3[6], t3 = $3[7], t4 = $3[8], weight = $3[9]);
  const border2 = t0 === void 0 ? true : t0, disabled = t1 === void 0 ? false : t1, fontSize2 = t22 === void 0 ? 2 : t22, padding = t3 === void 0 ? 3 : t3, radius = t4 === void 0 ? 2 : t4, ref = (0, import_react.useRef)(null), rootTheme = useRootTheme();
  let t5;
  $3[10] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => ref.current, $3[10] = t5) : t5 = $3[10], (0, import_react.useImperativeHandle)(forwardedRef, t5), useCustomValidity(ref, customValidity);
  const t6 = rootTheme.scheme, t7 = rootTheme.tone;
  let t8;
  $3[11] !== fontSize2 ? (t8 = _getArrayProp(fontSize2), $3[11] = fontSize2, $3[12] = t8) : t8 = $3[12];
  let t9;
  $3[13] !== padding ? (t9 = _getArrayProp(padding), $3[13] = padding, $3[14] = t9) : t9 = $3[14];
  const t10 = rootTheme.scheme;
  let t11;
  $3[15] === Symbol.for("react.memo_cache_sentinel") ? (t11 = _getArrayProp(0), $3[15] = t11) : t11 = $3[15];
  let t12;
  $3[16] !== disabled || $3[17] !== restProps || $3[18] !== rootTheme.scheme || $3[19] !== rootTheme.tone || $3[20] !== t8 || $3[21] !== t9 || $3[22] !== weight ? (t12 = (0, import_jsx_runtime.jsx)(Input$1, { "data-as": "textarea", "data-scheme": t6, "data-tone": t7, ...restProps, $fontSize: t8, $padding: t9, $scheme: t10, $space: t11, $tone: rootTheme.tone, $weight: weight, disabled, ref }), $3[16] = disabled, $3[17] = restProps, $3[18] = rootTheme.scheme, $3[19] = rootTheme.tone, $3[20] = t8, $3[21] = t9, $3[22] = weight, $3[23] = t12) : t12 = $3[23];
  let t13;
  $3[24] !== radius ? (t13 = _getArrayProp(radius), $3[24] = radius, $3[25] = t13) : t13 = $3[25];
  const t14 = border2 ? "" : void 0;
  let t15;
  $3[26] !== __unstable_disableFocusRing || $3[27] !== rootTheme.scheme || $3[28] !== rootTheme.tone || $3[29] !== t13 || $3[30] !== t14 ? (t15 = (0, import_jsx_runtime.jsx)(Presentation$1, { $radius: t13, $unstableDisableFocusRing: __unstable_disableFocusRing, $scheme: rootTheme.scheme, $tone: rootTheme.tone, "data-border": t14, "data-scheme": rootTheme.scheme, "data-tone": rootTheme.tone }), $3[26] = __unstable_disableFocusRing, $3[27] = rootTheme.scheme, $3[28] = rootTheme.tone, $3[29] = t13, $3[30] = t14, $3[31] = t15) : t15 = $3[31];
  let t16;
  return $3[32] !== t12 || $3[33] !== t15 ? (t16 = (0, import_jsx_runtime.jsx)(StyledTextArea, { "data-ui": "TextArea", children: (0, import_jsx_runtime.jsxs)(InputRoot$1, { children: [
    t12,
    t15
  ] }) }), $3[32] = t12, $3[33] = t15, $3[34] = t16) : t16 = $3[34], t16;
});
TextArea.displayName = "ForwardRef(TextArea)";
var CLEAR_BUTTON_BOX_STYLE = {
  zIndex: 2
};
var StyledTextInput = dt(Card).attrs({
  forwardedAs: "span"
}).withConfig({
  displayName: "StyledTextInput",
  componentId: "sc-h62wco-0"
})(textInputRootStyle);
var InputRoot = dt.span.withConfig({
  displayName: "InputRoot",
  componentId: "sc-h62wco-1"
})`flex:1;min-width:0;display:block;position:relative;`;
var Prefix = dt(Card).attrs({
  forwardedAs: "span"
}).withConfig({
  displayName: "Prefix",
  componentId: "sc-h62wco-2"
})`border-top-right-radius:0;border-bottom-right-radius:0;& > span{display:block;margin:-1px;}`;
var Suffix = dt(Card).attrs({
  forwardedAs: "span"
}).withConfig({
  displayName: "Suffix",
  componentId: "sc-h62wco-3"
})`border-top-left-radius:0;border-bottom-left-radius:0;& > span{display:block;margin:-1px;}`;
var Input = dt.input.withConfig({
  displayName: "Input",
  componentId: "sc-h62wco-4"
})(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
var Presentation = dt.span.withConfig({
  displayName: "Presentation",
  componentId: "sc-h62wco-5"
})(responsiveRadiusStyle, textInputRepresentationStyle);
var LeftBox = dt(Box).withConfig({
  displayName: "LeftBox",
  componentId: "sc-h62wco-6"
})`position:absolute;top:0;left:0;`;
var RightBox = dt(Box).withConfig({
  displayName: "RightBox",
  componentId: "sc-h62wco-7"
})`position:absolute;top:0;right:0;`;
var RightCard = dt(Card).withConfig({
  displayName: "RightCard",
  componentId: "sc-h62wco-8"
})`background-color:transparent;position:absolute;top:0;right:0;`;
var TextInputClearButton = dt(Button).withConfig({
  displayName: "TextInputClearButton",
  componentId: "sc-h62wco-9"
})({
  "&:not([hidden])": {
    display: "block"
  }
});
var TextInput = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(92);
  let IconComponent, IconRightComponent, __unstable_disableFocusRing, clearButton, customValidity, onClear, prefix3, readOnly, restProps, suffix, t0, t1, t22, t3, t4, t5, t6, weight;
  $3[0] !== props ? ({
    __unstable_disableFocusRing,
    border: t0,
    clearButton,
    disabled: t1,
    fontSize: t22,
    icon: IconComponent,
    iconRight: IconRightComponent,
    onClear,
    padding: t3,
    prefix: prefix3,
    radius: t4,
    readOnly,
    space: t5,
    suffix,
    customValidity,
    type: t6,
    weight,
    ...restProps
  } = props, $3[0] = props, $3[1] = IconComponent, $3[2] = IconRightComponent, $3[3] = __unstable_disableFocusRing, $3[4] = clearButton, $3[5] = customValidity, $3[6] = onClear, $3[7] = prefix3, $3[8] = readOnly, $3[9] = restProps, $3[10] = suffix, $3[11] = t0, $3[12] = t1, $3[13] = t22, $3[14] = t3, $3[15] = t4, $3[16] = t5, $3[17] = t6, $3[18] = weight) : (IconComponent = $3[1], IconRightComponent = $3[2], __unstable_disableFocusRing = $3[3], clearButton = $3[4], customValidity = $3[5], onClear = $3[6], prefix3 = $3[7], readOnly = $3[8], restProps = $3[9], suffix = $3[10], t0 = $3[11], t1 = $3[12], t22 = $3[13], t3 = $3[14], t4 = $3[15], t5 = $3[16], t6 = $3[17], weight = $3[18]);
  const border2 = t0 === void 0 ? true : t0, disabled = t1 === void 0 ? false : t1, fontSizeProp = t22 === void 0 ? 2 : t22, paddingProp = t3 === void 0 ? 3 : t3, radiusProp = t4 === void 0 ? 2 : t4, spaceProp = t5 === void 0 ? 3 : t5, type = t6 === void 0 ? "text" : t6, ref = (0, import_react.useRef)(null), rootTheme = useRootTheme();
  let t7;
  $3[19] !== fontSizeProp ? (t7 = _getArrayProp(fontSizeProp), $3[19] = fontSizeProp, $3[20] = t7) : t7 = $3[20];
  const fontSize2 = t7;
  let t8;
  $3[21] !== paddingProp ? (t8 = _getArrayProp(paddingProp), $3[21] = paddingProp, $3[22] = t8) : t8 = $3[22];
  const padding = t8;
  let t9;
  $3[23] !== radiusProp ? (t9 = _getArrayProp(radiusProp), $3[23] = radiusProp, $3[24] = t9) : t9 = $3[24];
  const radius = t9;
  let t10;
  $3[25] !== spaceProp ? (t10 = _getArrayProp(spaceProp), $3[25] = spaceProp, $3[26] = t10) : t10 = $3[26];
  const space = t10, $hasClearButton = !!clearButton, $hasIcon = !!IconComponent, $hasIconRight = !!IconRightComponent, $hasSuffix = !!suffix, $hasPrefix = !!prefix3;
  let t11;
  $3[27] === Symbol.for("react.memo_cache_sentinel") ? (t11 = () => ref.current, $3[27] = t11) : t11 = $3[27], (0, import_react.useImperativeHandle)(forwardedRef, t11), useCustomValidity(ref, customValidity);
  const handleClearMouseDown = _temp$2;
  let t12;
  $3[28] !== onClear ? (t12 = (event_0) => {
    event_0.preventDefault(), event_0.stopPropagation(), onClear && onClear(), ref.current?.focus();
  }, $3[28] = onClear, $3[29] = t12) : t12 = $3[29];
  const handleClearClick = t12;
  let t13;
  $3[30] !== prefix3 || $3[31] !== radius ? (t13 = prefix3 && (0, import_jsx_runtime.jsx)(Prefix, { borderTop: true, borderLeft: true, borderBottom: true, radius, sizing: "border", tone: "inherit", children: (0, import_jsx_runtime.jsx)("span", { children: prefix3 }) }), $3[30] = prefix3, $3[31] = radius, $3[32] = t13) : t13 = $3[32];
  const prefixNode = t13, t14 = border2 ? "" : void 0;
  let t15;
  $3[33] !== IconComponent || $3[34] !== fontSize2 || $3[35] !== padding ? (t15 = IconComponent && (0, import_jsx_runtime.jsx)(LeftBox, { padding, children: (0, import_jsx_runtime.jsxs)(Text, { size: fontSize2, children: [
    (0, import_react.isValidElement)(IconComponent) && IconComponent,
    (0, import_react_is.isValidElementType)(IconComponent) && (0, import_jsx_runtime.jsx)(IconComponent, {})
  ] }) }), $3[33] = IconComponent, $3[34] = fontSize2, $3[35] = padding, $3[36] = t15) : t15 = $3[36];
  let t16;
  $3[37] !== $hasClearButton || $3[38] !== IconRightComponent || $3[39] !== fontSize2 || $3[40] !== padding ? (t16 = !$hasClearButton && IconRightComponent && (0, import_jsx_runtime.jsx)(RightBox, { padding, children: (0, import_jsx_runtime.jsxs)(Text, { size: fontSize2, children: [
    (0, import_react.isValidElement)(IconRightComponent) && IconRightComponent,
    (0, import_react_is.isValidElementType)(IconRightComponent) && (0, import_jsx_runtime.jsx)(IconRightComponent, {})
  ] }) }), $3[37] = $hasClearButton, $3[38] = IconRightComponent, $3[39] = fontSize2, $3[40] = padding, $3[41] = t16) : t16 = $3[41];
  let t17;
  $3[42] !== $hasPrefix || $3[43] !== $hasSuffix || $3[44] !== __unstable_disableFocusRing || $3[45] !== radius || $3[46] !== rootTheme.scheme || $3[47] !== rootTheme.tone || $3[48] !== t14 || $3[49] !== t15 || $3[50] !== t16 ? (t17 = (0, import_jsx_runtime.jsxs)(Presentation, { $hasPrefix, $unstableDisableFocusRing: __unstable_disableFocusRing, $hasSuffix, $radius: radius, $scheme: rootTheme.scheme, $tone: rootTheme.tone, "data-border": t14, "data-scheme": rootTheme.scheme, "data-tone": rootTheme.tone, children: [
    t15,
    t16
  ] }), $3[42] = $hasPrefix, $3[43] = $hasSuffix, $3[44] = __unstable_disableFocusRing, $3[45] = radius, $3[46] = rootTheme.scheme, $3[47] = rootTheme.tone, $3[48] = t14, $3[49] = t15, $3[50] = t16, $3[51] = t17) : t17 = $3[51];
  const presentationNode = t17;
  let t18;
  $3[52] !== padding ? (t18 = padding.map(_temp2), $3[52] = padding, $3[53] = t18) : t18 = $3[53];
  const clearButtonBoxPadding = t18;
  let t19;
  $3[54] !== padding ? (t19 = padding.map(_temp3), $3[54] = padding, $3[55] = t19) : t19 = $3[55];
  const clearButtonPadding = t19, clearButtonProps = typeof clearButton == "object" ? clearButton : EMPTY_RECORD;
  let t20;
  $3[56] !== clearButton || $3[57] !== clearButtonBoxPadding || $3[58] !== clearButtonPadding || $3[59] !== clearButtonProps || $3[60] !== customValidity || $3[61] !== disabled || $3[62] !== fontSize2 || $3[63] !== handleClearClick || $3[64] !== radius || $3[65] !== readOnly ? (t20 = !disabled && !readOnly && clearButton && (0, import_jsx_runtime.jsx)(RightCard, { forwardedAs: "span", padding: clearButtonBoxPadding, style: CLEAR_BUTTON_BOX_STYLE, tone: customValidity ? "critical" : "inherit", children: (0, import_jsx_runtime.jsx)(TextInputClearButton, { "aria-label": "Clear", "data-qa": "clear-button", fontSize: fontSize2, icon: CloseIcon, mode: "bleed", padding: clearButtonPadding, radius, ...clearButtonProps, onClick: handleClearClick, onMouseDown: handleClearMouseDown }) }), $3[56] = clearButton, $3[57] = clearButtonBoxPadding, $3[58] = clearButtonPadding, $3[59] = clearButtonProps, $3[60] = customValidity, $3[61] = disabled, $3[62] = fontSize2, $3[63] = handleClearClick, $3[64] = radius, $3[65] = readOnly, $3[66] = t20) : t20 = $3[66];
  const clearButtonNode = t20;
  let t21;
  $3[67] !== radius || $3[68] !== suffix ? (t21 = suffix && (0, import_jsx_runtime.jsx)(Suffix, { borderTop: true, borderRight: true, borderBottom: true, radius, sizing: "border", tone: "inherit", children: (0, import_jsx_runtime.jsx)("span", { children: suffix }) }), $3[67] = radius, $3[68] = suffix, $3[69] = t21) : t21 = $3[69];
  const suffixNode = t21, t222 = $hasIconRight || $hasClearButton;
  let t23;
  $3[70] !== $hasIcon || $3[71] !== disabled || $3[72] !== fontSize2 || $3[73] !== padding || $3[74] !== readOnly || $3[75] !== restProps || $3[76] !== rootTheme.scheme || $3[77] !== rootTheme.tone || $3[78] !== space || $3[79] !== t222 || $3[80] !== type || $3[81] !== weight ? (t23 = (0, import_jsx_runtime.jsx)(Input, { "data-as": "input", "data-scheme": rootTheme.scheme, "data-tone": rootTheme.tone, ...restProps, $fontSize: fontSize2, $iconLeft: $hasIcon, $iconRight: t222, $padding: padding, $scheme: rootTheme.scheme, $space: space, $tone: rootTheme.tone, $weight: weight, disabled, readOnly, ref, type }), $3[70] = $hasIcon, $3[71] = disabled, $3[72] = fontSize2, $3[73] = padding, $3[74] = readOnly, $3[75] = restProps, $3[76] = rootTheme.scheme, $3[77] = rootTheme.tone, $3[78] = space, $3[79] = t222, $3[80] = type, $3[81] = weight, $3[82] = t23) : t23 = $3[82];
  let t24;
  $3[83] !== clearButtonNode || $3[84] !== presentationNode || $3[85] !== t23 ? (t24 = (0, import_jsx_runtime.jsxs)(InputRoot, { children: [
    t23,
    presentationNode,
    clearButtonNode
  ] }), $3[83] = clearButtonNode, $3[84] = presentationNode, $3[85] = t23, $3[86] = t24) : t24 = $3[86];
  let t25;
  return $3[87] !== prefixNode || $3[88] !== rootTheme.tone || $3[89] !== suffixNode || $3[90] !== t24 ? (t25 = (0, import_jsx_runtime.jsxs)(StyledTextInput, { "data-ui": "TextInput", tone: rootTheme.tone, children: [
    prefixNode,
    t24,
    suffixNode
  ] }), $3[87] = prefixNode, $3[88] = rootTheme.tone, $3[89] = suffixNode, $3[90] = t24, $3[91] = t25) : t25 = $3[91], t25;
});
TextInput.displayName = "ForwardRef(TextInput)";
function _temp$2(event) {
  event.preventDefault(), event.stopPropagation();
}
function _temp2(v2) {
  return v2 === 0 ? 0 : v2 === 1 || v2 === 2 ? 1 : v2 - 2;
}
function _temp3(v_0) {
  return v_0 === 0 || v_0 === 1 ? 0 : v_0 === 2 ? 1 : v_0 - 1;
}
function useDelayedState(initialState4) {
  const $3 = (0, import_react_compiler_runtime.c)(3), [state, setState] = (0, import_react.useState)(initialState4), delayedAction = (0, import_react.useRef)(void 0);
  let t0;
  $3[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = (nextState, delay2) => {
    const action = () => {
      setState(nextState);
    };
    if (delayedAction.current && (clearTimeout(delayedAction.current), delayedAction.current = void 0), !delay2)
      return action();
    delayedAction.current = setTimeout(action, delay2);
  }, $3[0] = t0) : t0 = $3[0];
  const onStateChange = t0;
  let t1;
  return $3[1] !== state ? (t1 = [state, onStateChange], $3[1] = state, $3[2] = t1) : t1 = $3[2], t1;
}
var DEFAULT_TOOLTIP_ARROW_WIDTH = 15;
var DEFAULT_TOOLTIP_ARROW_HEIGHT = 6;
var DEFAULT_TOOLTIP_ARROW_RADIUS = 2;
var DEFAULT_TOOLTIP_DISTANCE = 4;
var DEFAULT_TOOLTIP_PADDING = 4;
var DEFAULT_FALLBACK_PLACEMENTS = {
  top: ["top-end", "top-start", "bottom", "left", "right"],
  "top-start": ["top", "top-end", "bottom-start", "left-start", "right-start"],
  "top-end": ["top", "top-start", "bottom-end", "left-end", "right-end"],
  bottom: ["bottom-end", "bottom-start", "top", "left", "right"],
  "bottom-start": ["bottom", "bottom-end", "top-start", "left-start", "right-start"],
  "bottom-end": ["bottom", "bottom-start", "top-end", "left-end", "right-end"],
  left: ["left-end", "left-start", "right", "top", "bottom"],
  "left-start": ["left", "left-end", "right-start", "top-start", "bottom-start"],
  "left-end": ["left", "left-start", "right-end", "top-end", "bottom-end"],
  right: ["right-end", "right-start", "left", "top", "bottom"],
  "right-start": ["right", "right-end", "left-start", "top-start", "bottom-start"],
  "right-end": ["right", "right-start", "left-end", "top-end", "bottom-end"]
};
var MotionCard = dt(motion.create(Card)).withConfig({
  displayName: "MotionCard",
  componentId: "sc-1xn138w-0"
})`will-change:transform;`;
var TooltipCard = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(48);
  let animate, arrow2, arrowRef, arrowX, arrowY, children, originX, originY, padding, placement, radius, restProps, scheme, shadow, style;
  $3[0] !== props ? ({
    animate,
    arrow: arrow2,
    arrowRef,
    arrowX,
    arrowY,
    children,
    originX,
    originY,
    padding,
    placement,
    radius,
    scheme,
    shadow,
    style,
    ...restProps
  } = props, $3[0] = props, $3[1] = animate, $3[2] = arrow2, $3[3] = arrowRef, $3[4] = arrowX, $3[5] = arrowY, $3[6] = children, $3[7] = originX, $3[8] = originY, $3[9] = padding, $3[10] = placement, $3[11] = radius, $3[12] = restProps, $3[13] = scheme, $3[14] = shadow, $3[15] = style) : (animate = $3[1], arrow2 = $3[2], arrowRef = $3[3], arrowX = $3[4], arrowY = $3[5], children = $3[6], originX = $3[7], originY = $3[8], padding = $3[9], placement = $3[10], radius = $3[11], restProps = $3[12], scheme = $3[13], shadow = $3[14], style = $3[15]);
  const t0 = animate ? "transform" : void 0;
  let t1;
  $3[16] !== originX || $3[17] !== originY || $3[18] !== style || $3[19] !== t0 ? (t1 = {
    originX,
    originY,
    willChange: t0,
    ...style
  }, $3[16] = originX, $3[17] = originY, $3[18] = style, $3[19] = t0, $3[20] = t1) : t1 = $3[20];
  const rootStyle2 = t1, t22 = arrowX !== null ? arrowX : void 0, t3 = arrowY !== null ? arrowY : void 0;
  let t4;
  $3[21] !== t22 || $3[22] !== t3 ? (t4 = {
    left: t22,
    top: t3,
    right: void 0,
    bottom: void 0
  }, $3[21] = t22, $3[22] = t3, $3[23] = t4) : t4 = $3[23];
  const arrowStyle = t4, t5 = restProps;
  let t6;
  $3[24] !== animate ? (t6 = animate ? ["hidden", "initial"] : void 0, $3[24] = animate, $3[25] = t6) : t6 = $3[25];
  let t7;
  $3[26] !== animate ? (t7 = animate ? ["visible", "scaleIn"] : void 0, $3[26] = animate, $3[27] = t7) : t7 = $3[27];
  let t8;
  $3[28] !== animate ? (t8 = animate ? ["hidden", "scaleOut"] : void 0, $3[28] = animate, $3[29] = t8) : t8 = $3[29];
  let t9;
  $3[30] !== arrow2 || $3[31] !== arrowRef || $3[32] !== arrowStyle ? (t9 = arrow2 && (0, import_jsx_runtime.jsx)(Arrow, { ref: arrowRef, style: arrowStyle, width: DEFAULT_TOOLTIP_ARROW_WIDTH, height: DEFAULT_TOOLTIP_ARROW_HEIGHT, radius: DEFAULT_TOOLTIP_ARROW_RADIUS }), $3[30] = arrow2, $3[31] = arrowRef, $3[32] = arrowStyle, $3[33] = t9) : t9 = $3[33];
  let t10;
  return $3[34] !== children || $3[35] !== padding || $3[36] !== placement || $3[37] !== radius || $3[38] !== ref || $3[39] !== rootStyle2 || $3[40] !== scheme || $3[41] !== shadow || $3[42] !== t5 || $3[43] !== t6 || $3[44] !== t7 || $3[45] !== t8 || $3[46] !== t9 ? (t10 = (0, import_jsx_runtime.jsxs)(MotionCard, { "data-ui": "Tooltip__card", ...t5, "data-placement": placement, padding, radius, ref, scheme, shadow, style: rootStyle2, variants: POPOVER_MOTION_PROPS.card, transition: POPOVER_MOTION_PROPS.transition, initial: t6, animate: t7, exit: t8, children: [
    children,
    t9
  ] }), $3[34] = children, $3[35] = padding, $3[36] = placement, $3[37] = radius, $3[38] = ref, $3[39] = rootStyle2, $3[40] = scheme, $3[41] = shadow, $3[42] = t5, $3[43] = t6, $3[44] = t7, $3[45] = t8, $3[46] = t9, $3[47] = t10) : t10 = $3[47], t10;
});
TooltipCard.displayName = "ForwardRef(TooltipCard)";
var TooltipDelayGroupContext = createGlobalScopedContext("@sanity/ui/context/tooltipDelayGroup", null);
function TooltipDelayGroupProvider(props) {
  const $3 = (0, import_react_compiler_runtime.c)(9), {
    children,
    delay: delay2
  } = props, [isGroupActive, setIsGroupActive] = useDelayedState(false), [openTooltipId, setOpenTooltipId] = useDelayedState(null), openDelay = typeof delay2 == "number" ? delay2 : delay2?.open || 0, closeDelay = typeof delay2 == "number" ? delay2 : delay2?.close || 0, t0 = isGroupActive ? 1 : openDelay;
  let t1;
  $3[0] !== closeDelay || $3[1] !== openTooltipId || $3[2] !== setIsGroupActive || $3[3] !== setOpenTooltipId || $3[4] !== t0 ? (t1 = {
    setIsGroupActive,
    openTooltipId,
    setOpenTooltipId,
    openDelay: t0,
    closeDelay
  }, $3[0] = closeDelay, $3[1] = openTooltipId, $3[2] = setIsGroupActive, $3[3] = setOpenTooltipId, $3[4] = t0, $3[5] = t1) : t1 = $3[5];
  const value = t1;
  let t22;
  return $3[6] !== children || $3[7] !== value ? (t22 = (0, import_jsx_runtime.jsx)(TooltipDelayGroupContext.Provider, { value, children }), $3[6] = children, $3[7] = value, $3[8] = t22) : t22 = $3[8], t22;
}
TooltipDelayGroupProvider.displayName = "TooltipDelayGroupProvider";
function useTooltipDelayGroup() {
  return (0, import_react.useContext)(TooltipDelayGroupContext);
}
var StyledTooltip = dt(Layer).withConfig({
  displayName: "StyledTooltip",
  componentId: "sc-13f2zvh-0"
})`pointer-events:none;`;
var Tooltip = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(137), boundaryElementContext = useBoundaryElement(), {
    layer
  } = useTheme_v2();
  let _boundaryElement, _fallbackPlacementsProp, _zOffset, childProp, content2, delay2, disabled, portalProp, restProps, scheme, t0, t1, t22, t3, t4, t5;
  $3[0] !== props ? ({
    animate: t0,
    arrow: t1,
    boundaryElement: _boundaryElement,
    children: childProp,
    content: content2,
    disabled,
    fallbackPlacements: _fallbackPlacementsProp,
    padding: t22,
    placement: t3,
    portal: portalProp,
    radius: t4,
    scheme,
    shadow: t5,
    zOffset: _zOffset,
    delay: delay2,
    ...restProps
  } = props, $3[0] = props, $3[1] = _boundaryElement, $3[2] = _fallbackPlacementsProp, $3[3] = _zOffset, $3[4] = childProp, $3[5] = content2, $3[6] = delay2, $3[7] = disabled, $3[8] = portalProp, $3[9] = restProps, $3[10] = scheme, $3[11] = t0, $3[12] = t1, $3[13] = t22, $3[14] = t3, $3[15] = t4, $3[16] = t5) : (_boundaryElement = $3[1], _fallbackPlacementsProp = $3[2], _zOffset = $3[3], childProp = $3[4], content2 = $3[5], delay2 = $3[6], disabled = $3[7], portalProp = $3[8], restProps = $3[9], scheme = $3[10], t0 = $3[11], t1 = $3[12], t22 = $3[13], t3 = $3[14], t4 = $3[15], t5 = $3[16]);
  const _animate = t0 === void 0 ? false : t0, arrowProp = t1 === void 0 ? false : t1, padding = t22 === void 0 ? 2 : t22, placementProp = t3 === void 0 ? "bottom" : t3, radius = t4 === void 0 ? 2 : t4, shadow = t5 === void 0 ? 2 : t5, boundaryElement = _boundaryElement ?? boundaryElementContext?.element, fallbackPlacementsProp = _fallbackPlacementsProp ?? DEFAULT_FALLBACK_PLACEMENTS[props.placement ?? "bottom"], zOffset = _zOffset ?? layer.tooltip.zOffset, animate = usePrefersReducedMotion() ? false : _animate;
  let t6;
  $3[17] !== fallbackPlacementsProp ? (t6 = _getArrayProp(fallbackPlacementsProp), $3[17] = fallbackPlacementsProp, $3[18] = t6) : t6 = $3[18];
  const fallbackPlacements = t6, ref = (0, import_react.useRef)(null), [referenceElement, setReferenceElement] = (0, import_react.useState)(null), arrowRef = (0, import_react.useRef)(null), [tooltipMaxWidth, setTooltipMaxWidth] = (0, import_react.useState)(0);
  let t7;
  $3[19] === Symbol.for("react.memo_cache_sentinel") ? (t7 = () => ref.current, $3[19] = t7) : t7 = $3[19], (0, import_react.useImperativeHandle)(forwardedRef, t7);
  const portal = usePortal(), portalElement = typeof portalProp == "string" ? portal.elements?.[portalProp] || null : portal.element;
  let t8;
  $3[20] !== animate || $3[21] !== arrowProp || $3[22] !== boundaryElement || $3[23] !== fallbackPlacements ? (t8 = {
    animate,
    arrowProp,
    arrowRef,
    boundaryElement,
    fallbackPlacements,
    rootBoundary: "viewport"
  }, $3[20] = animate, $3[21] = arrowProp, $3[22] = boundaryElement, $3[23] = fallbackPlacements, $3[24] = t8) : t8 = $3[24];
  const middleware2 = useMiddleware(t8);
  let t9;
  $3[25] !== referenceElement ? (t9 = {
    reference: referenceElement
  }, $3[25] = referenceElement, $3[26] = t9) : t9 = $3[26];
  let t10;
  $3[27] !== middleware2 || $3[28] !== placementProp || $3[29] !== t9 ? (t10 = {
    middleware: middleware2,
    placement: placementProp,
    whileElementsMounted: autoUpdate,
    elements: t9
  }, $3[27] = middleware2, $3[28] = placementProp, $3[29] = t9, $3[30] = t10) : t10 = $3[30];
  const {
    floatingStyles,
    placement,
    middlewareData,
    refs,
    update
  } = useFloating(t10), arrowX = middlewareData.arrow?.x, arrowY = middlewareData.arrow?.y, originX = middlewareData["@sanity/ui/origin"]?.originX, originY = middlewareData["@sanity/ui/origin"]?.originY, tooltipId = (0, import_react.useId)(), [isOpen, setIsOpen] = useDelayedState(false), delayGroupContext = useTooltipDelayGroup();
  let t11;
  $3[31] !== delayGroupContext ? (t11 = delayGroupContext || {}, $3[31] = delayGroupContext, $3[32] = t11) : t11 = $3[32];
  const {
    setIsGroupActive,
    setOpenTooltipId
  } = t11, showTooltip = isOpen || delayGroupContext?.openTooltipId === tooltipId, isInsideGroup = delayGroupContext !== null, openDelayProp = typeof delay2 == "number" ? delay2 : delay2?.open || 0, closeDelayProp = typeof delay2 == "number" ? delay2 : delay2?.close || 0, openDelay = isInsideGroup ? delayGroupContext.openDelay : openDelayProp, closeDelay = isInsideGroup ? delayGroupContext.closeDelay : closeDelayProp;
  let t12;
  $3[33] !== closeDelay || $3[34] !== isInsideGroup || $3[35] !== openDelay || $3[36] !== setIsGroupActive || $3[37] !== setIsOpen || $3[38] !== setOpenTooltipId || $3[39] !== tooltipId ? (t12 = (open, immediate) => {
    if (isInsideGroup)
      if (open) {
        const groupedOpenDelay = immediate ? 0 : openDelay;
        setIsGroupActive?.(open, groupedOpenDelay), setOpenTooltipId?.(tooltipId, groupedOpenDelay);
      } else {
        const groupDeactivateDelay = closeDelay > 200 ? closeDelay : 200;
        setIsGroupActive?.(open, groupDeactivateDelay), setOpenTooltipId?.(null, immediate ? 0 : closeDelay);
      }
    else
      setIsOpen(open, immediate ? 0 : open ? openDelay : closeDelay);
  }, $3[33] = closeDelay, $3[34] = isInsideGroup, $3[35] = openDelay, $3[36] = setIsGroupActive, $3[37] = setIsOpen, $3[38] = setOpenTooltipId, $3[39] = tooltipId, $3[40] = t12) : t12 = $3[40];
  const handleIsOpenChange = t12;
  let t13;
  $3[41] !== childProp?.props || $3[42] !== handleIsOpenChange ? (t13 = (e2) => {
    handleIsOpenChange(false), childProp?.props?.onBlur?.(e2);
  }, $3[41] = childProp?.props, $3[42] = handleIsOpenChange, $3[43] = t13) : t13 = $3[43];
  const handleBlur = t13;
  let t14;
  $3[44] !== childProp?.props || $3[45] !== handleIsOpenChange ? (t14 = (e_0) => {
    handleIsOpenChange(false, true), childProp?.props.onClick?.(e_0);
  }, $3[44] = childProp?.props, $3[45] = handleIsOpenChange, $3[46] = t14) : t14 = $3[46];
  const handleClick = t14;
  let t15;
  $3[47] !== childProp?.props || $3[48] !== handleIsOpenChange ? (t15 = (e_1) => {
    handleIsOpenChange(false, true), childProp?.props.onContextMenu?.(e_1);
  }, $3[47] = childProp?.props, $3[48] = handleIsOpenChange, $3[49] = t15) : t15 = $3[49];
  const handleContextMenu = t15;
  let t16;
  $3[50] !== childProp?.props || $3[51] !== handleIsOpenChange ? (t16 = (e_2) => {
    handleIsOpenChange(true), childProp?.props?.onFocus?.(e_2);
  }, $3[50] = childProp?.props, $3[51] = handleIsOpenChange, $3[52] = t16) : t16 = $3[52];
  const handleFocus = t16;
  let t17;
  $3[53] !== childProp?.props || $3[54] !== handleIsOpenChange ? (t17 = (e_3) => {
    handleIsOpenChange(true), childProp?.props?.onMouseEnter?.(e_3);
  }, $3[53] = childProp?.props, $3[54] = handleIsOpenChange, $3[55] = t17) : t17 = $3[55];
  const handleMouseEnter = t17;
  let t18;
  $3[56] !== childProp?.props || $3[57] !== handleIsOpenChange ? (t18 = (e_4) => {
    handleIsOpenChange(false), childProp?.props?.onMouseLeave?.(e_4);
  }, $3[56] = childProp?.props, $3[57] = handleIsOpenChange, $3[58] = t18) : t18 = $3[58];
  const handleMouseLeave = t18;
  let t19;
  $3[59] !== handleIsOpenChange || $3[60] !== isInsideGroup || $3[61] !== referenceElement || $3[62] !== showTooltip ? (t19 = {
    handleIsOpenChange,
    referenceElement,
    showTooltip,
    isInsideGroup
  }, $3[59] = handleIsOpenChange, $3[60] = isInsideGroup, $3[61] = referenceElement, $3[62] = showTooltip, $3[63] = t19) : t19 = $3[63], useCloseOnMouseLeave(t19);
  let t20, t21;
  $3[64] !== disabled || $3[65] !== handleIsOpenChange || $3[66] !== showTooltip ? (t20 = () => {
    disabled && showTooltip && handleIsOpenChange(false);
  }, t21 = [disabled, handleIsOpenChange, showTooltip], $3[64] = disabled, $3[65] = handleIsOpenChange, $3[66] = showTooltip, $3[67] = t20, $3[68] = t21) : (t20 = $3[67], t21 = $3[68]), (0, import_react.useEffect)(t20, t21);
  let t222, t23;
  $3[69] !== content2 || $3[70] !== handleIsOpenChange || $3[71] !== showTooltip ? (t222 = () => {
    !content2 && showTooltip && handleIsOpenChange(false);
  }, t23 = [content2, handleIsOpenChange, showTooltip], $3[69] = content2, $3[70] = handleIsOpenChange, $3[71] = showTooltip, $3[72] = t222, $3[73] = t23) : (t222 = $3[72], t23 = $3[73]), (0, import_react.useEffect)(t222, t23);
  let t24, t25;
  $3[74] !== handleIsOpenChange || $3[75] !== showTooltip ? (t24 = () => {
    if (!showTooltip)
      return;
    const handleWindowKeyDown = function(event) {
      event.key === "Escape" && handleIsOpenChange(false, true);
    };
    return window.addEventListener("keydown", handleWindowKeyDown), () => {
      window.removeEventListener("keydown", handleWindowKeyDown);
    };
  }, t25 = [handleIsOpenChange, showTooltip], $3[74] = handleIsOpenChange, $3[75] = showTooltip, $3[76] = t24, $3[77] = t25) : (t24 = $3[76], t25 = $3[77]), (0, import_react.useEffect)(t24, t25);
  let t26;
  $3[78] !== boundaryElement || $3[79] !== portalElement?.offsetWidth ? (t26 = () => {
    const availableWidths = [...boundaryElement ? [boundaryElement.offsetWidth] : [], portalElement?.offsetWidth || document.body.offsetWidth];
    setTooltipMaxWidth(Math.min(...availableWidths) - DEFAULT_TOOLTIP_PADDING * 2);
  }, $3[78] = boundaryElement, $3[79] = portalElement?.offsetWidth, $3[80] = t26) : t26 = $3[80];
  let t27;
  $3[81] !== boundaryElement || $3[82] !== portalElement ? (t27 = [boundaryElement, portalElement], $3[81] = boundaryElement, $3[82] = portalElement, $3[83] = t27) : t27 = $3[83], (0, import_react.useLayoutEffect)(t26, t27);
  let t28;
  $3[84] !== update ? (t28 = (arrowEl) => {
    arrowRef.current = arrowEl, update();
  }, $3[84] = update, $3[85] = t28) : t28 = $3[85];
  const setArrow = t28;
  let t29;
  $3[86] !== refs ? (t29 = (node2) => {
    ref.current = node2, refs.setFloating(node2);
  }, $3[86] = refs, $3[87] = t29) : t29 = $3[87];
  const setFloating = t29;
  let t30;
  bb0: {
    if (!childProp) {
      t30 = null;
      break bb0;
    }
    let t312;
    $3[88] !== childProp || $3[89] !== handleBlur || $3[90] !== handleClick || $3[91] !== handleContextMenu || $3[92] !== handleFocus || $3[93] !== handleMouseEnter || $3[94] !== handleMouseLeave ? (t312 = (0, import_react.cloneElement)(childProp, {
      onBlur: handleBlur,
      onFocus: handleFocus,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick: handleClick,
      onContextMenu: handleContextMenu,
      ref: setReferenceElement
    }), $3[88] = childProp, $3[89] = handleBlur, $3[90] = handleClick, $3[91] = handleContextMenu, $3[92] = handleFocus, $3[93] = handleMouseEnter, $3[94] = handleMouseLeave, $3[95] = t312) : t312 = $3[95], t30 = t312;
  }
  const child = t30;
  let t31;
  $3[96] !== childProp ? (t31 = childProp ? getElementRef(childProp) : null, $3[96] = childProp, $3[97] = t31) : t31 = $3[97];
  let t32, t33;
  if ($3[98] !== referenceElement ? (t32 = () => referenceElement, t33 = [referenceElement], $3[98] = referenceElement, $3[99] = t32, $3[100] = t33) : (t32 = $3[99], t33 = $3[100]), (0, import_react.useImperativeHandle)(t31, t32, t33), !child) {
    let t342;
    return $3[101] === Symbol.for("react.memo_cache_sentinel") ? (t342 = (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {}), $3[101] = t342) : t342 = $3[101], t342;
  }
  if (disabled)
    return child;
  const t34 = tooltipMaxWidth > 0 ? `${tooltipMaxWidth}px` : void 0;
  let t35;
  $3[102] !== floatingStyles || $3[103] !== t34 ? (t35 = {
    ...floatingStyles,
    maxWidth: t34
  }, $3[102] = floatingStyles, $3[103] = t34, $3[104] = t35) : t35 = $3[104];
  let t36;
  $3[105] !== animate || $3[106] !== arrowProp || $3[107] !== arrowX || $3[108] !== arrowY || $3[109] !== content2 || $3[110] !== originX || $3[111] !== originY || $3[112] !== padding || $3[113] !== placement || $3[114] !== radius || $3[115] !== restProps || $3[116] !== scheme || $3[117] !== setArrow || $3[118] !== setFloating || $3[119] !== shadow ? (t36 = (0, import_jsx_runtime.jsx)(TooltipCard, { ...restProps, animate, arrow: arrowProp, arrowRef: setArrow, arrowX, arrowY, originX, originY, padding, placement, radius, ref: setFloating, scheme, shadow, children: content2 }), $3[105] = animate, $3[106] = arrowProp, $3[107] = arrowX, $3[108] = arrowY, $3[109] = content2, $3[110] = originX, $3[111] = originY, $3[112] = padding, $3[113] = placement, $3[114] = radius, $3[115] = restProps, $3[116] = scheme, $3[117] = setArrow, $3[118] = setFloating, $3[119] = shadow, $3[120] = t36) : t36 = $3[120];
  let t37;
  $3[121] !== restProps || $3[122] !== setFloating || $3[123] !== t35 || $3[124] !== t36 || $3[125] !== zOffset ? (t37 = (0, import_jsx_runtime.jsx)(StyledTooltip, { "data-ui": "Tooltip", ...restProps, ref: setFloating, style: t35, zOffset, children: t36 }), $3[121] = restProps, $3[122] = setFloating, $3[123] = t35, $3[124] = t36, $3[125] = zOffset, $3[126] = t37) : t37 = $3[126];
  const tooltip = t37;
  let t38;
  $3[127] !== portalProp || $3[128] !== showTooltip || $3[129] !== tooltip ? (t38 = showTooltip && (portalProp ? (0, import_jsx_runtime.jsx)(Portal, { __unstable_name: typeof portalProp == "string" ? portalProp : void 0, children: tooltip }) : tooltip), $3[127] = portalProp, $3[128] = showTooltip, $3[129] = tooltip, $3[130] = t38) : t38 = $3[130];
  const children = t38;
  let t39;
  $3[131] !== animate || $3[132] !== children ? (t39 = animate ? (0, import_jsx_runtime.jsx)(AnimatePresence, { children }) : children, $3[131] = animate, $3[132] = children, $3[133] = t39) : t39 = $3[133];
  let t40;
  return $3[134] !== child || $3[135] !== t39 ? (t40 = (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    t39,
    child
  ] }), $3[134] = child, $3[135] = t39, $3[136] = t40) : t40 = $3[136], t40;
});
Tooltip.displayName = "ForwardRef(Tooltip)";
function useMiddleware(t0) {
  const $3 = (0, import_react_compiler_runtime.c)(17), {
    animate,
    arrowProp,
    arrowRef,
    boundaryElement,
    fallbackPlacements,
    rootBoundary
  } = t0;
  let ret;
  if ($3[0] !== animate || $3[1] !== arrowProp || $3[2] !== arrowRef || $3[3] !== boundaryElement || $3[4] !== fallbackPlacements || $3[5] !== rootBoundary) {
    ret = [];
    const t1 = boundaryElement || void 0;
    let t22;
    $3[7] !== fallbackPlacements || $3[8] !== rootBoundary || $3[9] !== t1 ? (t22 = flip({
      boundary: t1,
      fallbackPlacements,
      padding: DEFAULT_TOOLTIP_PADDING,
      rootBoundary
    }), $3[7] = fallbackPlacements, $3[8] = rootBoundary, $3[9] = t1, $3[10] = t22) : t22 = $3[10], ret.push(t22);
    let t3;
    $3[11] === Symbol.for("react.memo_cache_sentinel") ? (t3 = offset({
      mainAxis: DEFAULT_TOOLTIP_DISTANCE
    }), $3[11] = t3) : t3 = $3[11], ret.push(t3);
    const t4 = boundaryElement || void 0;
    let t5;
    if ($3[12] !== rootBoundary || $3[13] !== t4 ? (t5 = shift({
      boundary: t4,
      rootBoundary,
      padding: DEFAULT_TOOLTIP_PADDING
    }), $3[12] = rootBoundary, $3[13] = t4, $3[14] = t5) : t5 = $3[14], ret.push(t5), arrowProp) {
      let t6;
      $3[15] !== arrowRef ? (t6 = arrow({
        element: arrowRef,
        padding: DEFAULT_TOOLTIP_PADDING
      }), $3[15] = arrowRef, $3[16] = t6) : t6 = $3[16], ret.push(t6);
    }
    animate && ret.push(origin), $3[0] = animate, $3[1] = arrowProp, $3[2] = arrowRef, $3[3] = boundaryElement, $3[4] = fallbackPlacements, $3[5] = rootBoundary, $3[6] = ret;
  } else
    ret = $3[6];
  return ret;
}
function useCloseOnMouseLeave(t0) {
  const $3 = (0, import_react_compiler_runtime.c)(10), {
    handleIsOpenChange,
    referenceElement,
    showTooltip,
    isInsideGroup
  } = t0;
  let t1;
  $3[0] !== handleIsOpenChange || $3[1] !== referenceElement ? (t1 = (target, teardown) => {
    referenceElement && (referenceElement === target || target instanceof Node && referenceElement.contains(target) || (handleIsOpenChange(false), teardown()));
  }, $3[0] = handleIsOpenChange, $3[1] = referenceElement, $3[2] = t1) : t1 = $3[2];
  const onMouseMove = useEffectEvent(t1);
  let t22;
  $3[3] !== isInsideGroup || $3[4] !== onMouseMove || $3[5] !== showTooltip ? (t22 = () => {
    if (!showTooltip || isInsideGroup)
      return;
    const handleMouseMove = (event) => {
      onMouseMove(event.target, () => window.removeEventListener("mousemove", handleMouseMove));
    };
    return window.addEventListener("mousemove", handleMouseMove), () => window.removeEventListener("mousemove", handleMouseMove);
  }, $3[3] = isInsideGroup, $3[4] = onMouseMove, $3[5] = showTooltip, $3[6] = t22) : t22 = $3[6];
  let t3;
  $3[7] !== isInsideGroup || $3[8] !== showTooltip ? (t3 = [isInsideGroup, showTooltip], $3[7] = isInsideGroup, $3[8] = showTooltip, $3[9] = t3) : t3 = $3[9], (0, import_react.useEffect)(t22, t3);
}
var StyledHotkeys = dt.kbd.withConfig({
  displayName: "StyledHotkeys",
  componentId: "sc-b37mge-0"
})`font:inherit;padding:1px;&:not([hidden]){display:block;}`;
var Key = dt(KBD).withConfig({
  displayName: "Key",
  componentId: "sc-b37mge-1"
})`&:not([hidden]){display:block;}`;
var Hotkeys = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(26);
  let fontSize2, keys, padding, radius, restProps, t0;
  $3[0] !== props ? ({
    fontSize: fontSize2,
    keys,
    padding,
    radius,
    space: t0,
    ...restProps
  } = props, $3[0] = props, $3[1] = fontSize2, $3[2] = keys, $3[3] = padding, $3[4] = radius, $3[5] = restProps, $3[6] = t0) : (fontSize2 = $3[1], keys = $3[2], padding = $3[3], radius = $3[4], restProps = $3[5], t0 = $3[6]);
  const spaceProp = t0 === void 0 ? 0.5 : t0;
  let t1;
  $3[7] !== spaceProp ? (t1 = _getArrayProp(spaceProp), $3[7] = spaceProp, $3[8] = t1) : t1 = $3[8];
  const space = t1;
  if (!keys || keys.length === 0) {
    let t222;
    return $3[9] === Symbol.for("react.memo_cache_sentinel") ? (t222 = (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {}), $3[9] = t222) : t222 = $3[9], t222;
  }
  let t22;
  if ($3[10] !== fontSize2 || $3[11] !== keys || $3[12] !== padding || $3[13] !== radius) {
    let t32;
    $3[15] !== fontSize2 || $3[16] !== padding || $3[17] !== radius ? (t32 = (key2, i3) => (0, import_jsx_runtime.jsx)(Key, { fontSize: fontSize2, padding, radius, children: key2 }, i3), $3[15] = fontSize2, $3[16] = padding, $3[17] = radius, $3[18] = t32) : t32 = $3[18], t22 = keys.map(t32), $3[10] = fontSize2, $3[11] = keys, $3[12] = padding, $3[13] = radius, $3[14] = t22;
  } else
    t22 = $3[14];
  let t3;
  $3[19] !== space || $3[20] !== t22 ? (t3 = (0, import_jsx_runtime.jsx)(Inline, { as: "span", space, children: t22 }), $3[19] = space, $3[20] = t22, $3[21] = t3) : t3 = $3[21];
  let t4;
  return $3[22] !== ref || $3[23] !== restProps || $3[24] !== t3 ? (t4 = (0, import_jsx_runtime.jsx)(StyledHotkeys, { "data-ui": "Hotkeys", ...restProps, ref, children: t3 }), $3[22] = ref, $3[23] = restProps, $3[24] = t3, $3[25] = t4) : t4 = $3[25], t4;
});
Hotkeys.displayName = "ForwardRef(Hotkeys)";
var MenuContext = createGlobalScopedContext("@sanity/ui/context/menu", null);
function _isFocusable(element) {
  return isHTMLAnchorElement(element) && element.getAttribute("data-disabled") !== "true" || isHTMLButtonElement(element) && !element.disabled;
}
function _getFocusableElements(elements) {
  return elements.filter(_isFocusable);
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e2 = el;
  for (; e2 !== rootElement; ) {
    const parentElement = e2.parentElement;
    if (!parentElement) return path;
    const index2 = Array.from(parentElement.childNodes).indexOf(e2);
    if (path.unshift(index2), parentElement === rootElement)
      return path;
    e2 = parentElement;
  }
  return path;
}
var EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  if (!rootElement) return;
  const map2 = /* @__PURE__ */ new WeakMap();
  for (const el of elements)
    map2.set(el, _getDOMPath(rootElement, el));
  const _sort = (a2, b2) => {
    const _a = map2.get(a2) || EMPTY_PATH, _b = map2.get(b2) || EMPTY_PATH, len = Math.max(_a.length, _b.length);
    for (let i3 = 0; i3 < len; i3 += 1) {
      const aIndex = _a[i3] || -1, bIndex = _b[i3] || -1;
      if (aIndex !== bIndex)
        return aIndex - bIndex;
    }
    return 0;
  };
  elements.sort(_sort);
}
function useMenuController(props) {
  const $3 = (0, import_react_compiler_runtime.c)(21), {
    onKeyDown,
    originElement,
    shouldFocus,
    rootElementRef
  } = props;
  let t0;
  $3[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = [], $3[0] = t0) : t0 = $3[0];
  const elementsRef = (0, import_react.useRef)(t0), [activeIndex, _setActiveIndex] = (0, import_react.useState)(-1), activeIndexRef = (0, import_react.useRef)(activeIndex), [activeElement, setActiveElement] = (0, import_react.useState)(null);
  let t1;
  $3[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = (nextActiveIndex) => {
    _setActiveIndex(nextActiveIndex), activeIndexRef.current = nextActiveIndex, setActiveElement(elementsRef.current[nextActiveIndex] || null);
  }, $3[1] = t1) : t1 = $3[1];
  const setActiveIndex = t1;
  let t22;
  $3[2] !== rootElementRef ? (t22 = (element, selected) => {
    if (!element)
      return _temp$1;
    if (elementsRef.current.indexOf(element) === -1 && (elementsRef.current.push(element), _sortElements(rootElementRef.current, elementsRef.current)), selected) {
      const selectedIndex = elementsRef.current.indexOf(element);
      setActiveIndex(selectedIndex);
    }
    return () => {
      const idx = elementsRef.current.indexOf(element);
      idx > -1 && elementsRef.current.splice(idx, 1);
    };
  }, $3[2] = rootElementRef, $3[3] = t22) : t22 = $3[3];
  const mount = t22;
  let t3;
  $3[4] !== onKeyDown || $3[5] !== originElement ? (t3 = (event) => {
    if (event.key === "Tab") {
      originElement && originElement.focus();
      return;
    }
    if (event.key === "Home") {
      event.preventDefault(), event.stopPropagation();
      const el = _getFocusableElements(elementsRef.current)[0];
      if (!el)
        return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "End") {
      event.preventDefault(), event.stopPropagation();
      const focusableElements_0 = _getFocusableElements(elementsRef.current), el_0 = focusableElements_0[focusableElements_0.length - 1];
      if (!el_0)
        return;
      const currentIndex_0 = elementsRef.current.indexOf(el_0);
      setActiveIndex(currentIndex_0);
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault(), event.stopPropagation();
      const focusableElements_1 = _getFocusableElements(elementsRef.current), focusableLen = focusableElements_1.length;
      if (focusableLen === 0)
        return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements_1.indexOf(focusedElement);
      focusedIndex = (focusedIndex - 1 + focusableLen) % focusableLen;
      const el_1 = focusableElements_1[focusedIndex], currentIndex_1 = elementsRef.current.indexOf(el_1);
      setActiveIndex(currentIndex_1);
      return;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault(), event.stopPropagation();
      const focusableElements_2 = _getFocusableElements(elementsRef.current), focusableLen_0 = focusableElements_2.length;
      if (focusableLen_0 === 0)
        return;
      const focusedElement_0 = elementsRef.current[activeIndexRef.current];
      let focusedIndex_0 = focusableElements_2.indexOf(focusedElement_0);
      focusedIndex_0 = (focusedIndex_0 + 1) % focusableLen_0;
      const el_2 = focusableElements_2[focusedIndex_0], currentIndex_2 = elementsRef.current.indexOf(el_2);
      setActiveIndex(currentIndex_2);
      return;
    }
    onKeyDown && onKeyDown(event);
  }, $3[4] = onKeyDown, $3[5] = originElement, $3[6] = t3) : t3 = $3[6];
  const handleKeyDown = t3;
  let t4;
  $3[7] === Symbol.for("react.memo_cache_sentinel") ? (t4 = (event_0) => {
    const element_0 = event_0.currentTarget, currentIndex_3 = elementsRef.current.indexOf(element_0);
    setActiveIndex(currentIndex_3);
  }, $3[7] = t4) : t4 = $3[7];
  const handleItemMouseEnter = t4;
  let t5;
  $3[8] !== rootElementRef ? (t5 = () => {
    setActiveIndex(-2), rootElementRef.current?.focus();
  }, $3[8] = rootElementRef, $3[9] = t5) : t5 = $3[9];
  const handleItemMouseLeave = t5;
  let t6, t7;
  $3[10] !== activeIndex || $3[11] !== rootElementRef || $3[12] !== shouldFocus ? (t6 = () => {
    if (!rootElementRef.current)
      return;
    const rafId = requestAnimationFrame(() => {
      if (activeIndex === -1) {
        if (shouldFocus === "first") {
          const el_3 = _getFocusableElements(elementsRef.current)[0];
          if (el_3) {
            const currentIndex_4 = elementsRef.current.indexOf(el_3);
            setActiveIndex(currentIndex_4);
          }
        }
        if (shouldFocus === "last") {
          const focusableElements_4 = _getFocusableElements(elementsRef.current), el_4 = focusableElements_4[focusableElements_4.length - 1];
          if (el_4) {
            const currentIndex_5 = elementsRef.current.indexOf(el_4);
            setActiveIndex(currentIndex_5);
          }
        }
        return;
      }
      (elementsRef.current[activeIndex] || null)?.focus();
    });
    return () => cancelAnimationFrame(rafId);
  }, t7 = [activeIndex, rootElementRef, setActiveIndex, shouldFocus], $3[10] = activeIndex, $3[11] = rootElementRef, $3[12] = shouldFocus, $3[13] = t6, $3[14] = t7) : (t6 = $3[13], t7 = $3[14]), (0, import_react.useEffect)(t6, t7);
  let t8;
  return $3[15] !== activeElement || $3[16] !== activeIndex || $3[17] !== handleItemMouseLeave || $3[18] !== handleKeyDown || $3[19] !== mount ? (t8 = {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount
  }, $3[15] = activeElement, $3[16] = activeIndex, $3[17] = handleItemMouseLeave, $3[18] = handleKeyDown, $3[19] = mount, $3[20] = t8) : t8 = $3[20], t8;
}
function _temp$1() {
}
var StyledMenu = dt(Box).withConfig({
  displayName: "StyledMenu",
  componentId: "sc-xt0tnv-0"
})`outline:none;overflow:auto;`;
var Menu = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(49);
  let _shouldFocus, children, onClickOutside, onEscape, onItemClick, onItemSelect, onKeyDown, originElement, registerElement, restProps, t0, t1;
  if ($3[0] !== props) {
    const {
      children: t222,
      focusFirst,
      focusLast,
      onClickOutside: t32,
      onEscape: t42,
      onItemClick: t52,
      onItemSelect: t62,
      onKeyDown: t72,
      originElement: t82,
      padding: t92,
      registerElement: t102,
      shouldFocus: t112,
      space: t122,
      ...t13
    } = props;
    children = t222, onClickOutside = t32, onEscape = t42, onItemClick = t52, onItemSelect = t62, onKeyDown = t72, originElement = t82, t0 = t92, registerElement = t102, _shouldFocus = t112, t1 = t122, restProps = t13, $3[0] = props, $3[1] = _shouldFocus, $3[2] = children, $3[3] = onClickOutside, $3[4] = onEscape, $3[5] = onItemClick, $3[6] = onItemSelect, $3[7] = onKeyDown, $3[8] = originElement, $3[9] = registerElement, $3[10] = restProps, $3[11] = t0, $3[12] = t1;
  } else
    _shouldFocus = $3[1], children = $3[2], onClickOutside = $3[3], onEscape = $3[4], onItemClick = $3[5], onItemSelect = $3[6], onKeyDown = $3[7], originElement = $3[8], registerElement = $3[9], restProps = $3[10], t0 = $3[11], t1 = $3[12];
  const padding = t0 === void 0 ? 1 : t0, space = t1 === void 0 ? 1 : t1, shouldFocus = _shouldFocus ?? (props.focusFirst && "first" || props.focusLast && "last" || null), ref = (0, import_react.useRef)(null);
  let t22;
  $3[13] === Symbol.for("react.memo_cache_sentinel") ? (t22 = () => ref.current, $3[13] = t22) : t22 = $3[13], (0, import_react.useImperativeHandle)(forwardedRef, t22);
  const {
    isTopLayer
  } = useLayer();
  let t3;
  $3[14] !== onKeyDown || $3[15] !== originElement || $3[16] !== shouldFocus ? (t3 = {
    onKeyDown,
    originElement,
    shouldFocus,
    rootElementRef: ref
  }, $3[14] = onKeyDown, $3[15] = originElement, $3[16] = shouldFocus, $3[17] = t3) : t3 = $3[17];
  const {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount
  } = useMenuController(t3), unregisterElementRef = (0, import_react.useRef)(null);
  let t4;
  $3[18] !== registerElement ? (t4 = (el) => {
    unregisterElementRef.current && (unregisterElementRef.current(), unregisterElementRef.current = null), ref.current = el, ref.current && registerElement && (unregisterElementRef.current = registerElement(ref.current));
  }, $3[18] = registerElement, $3[19] = t4) : t4 = $3[19];
  const handleRefChange = t4;
  let t5, t6;
  $3[20] !== activeIndex || $3[21] !== onItemSelect ? (t5 = () => {
    onItemSelect && onItemSelect(activeIndex);
  }, t6 = [activeIndex, onItemSelect], $3[20] = activeIndex, $3[21] = onItemSelect, $3[22] = t5, $3[23] = t6) : (t5 = $3[22], t6 = $3[23]), (0, import_react.useEffect)(t5, t6);
  let t7;
  $3[24] === Symbol.for("react.memo_cache_sentinel") ? (t7 = () => [ref.current], $3[24] = t7) : t7 = $3[24], useClickOutsideEvent(isTopLayer && onClickOutside, t7);
  let t8;
  $3[25] !== isTopLayer || $3[26] !== onEscape ? (t8 = (event) => {
    isTopLayer && event.key === "Escape" && (event.stopPropagation(), onEscape && onEscape());
  }, $3[25] = isTopLayer, $3[26] = onEscape, $3[27] = t8) : t8 = $3[27], useGlobalKeyDown(t8);
  let t9;
  $3[28] !== activeElement || $3[29] !== handleItemMouseEnter || $3[30] !== handleItemMouseLeave || $3[31] !== mount || $3[32] !== onClickOutside || $3[33] !== onEscape || $3[34] !== onItemClick || $3[35] !== registerElement ? (t9 = {
    version: 2,
    activeElement,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter: handleItemMouseEnter,
    onItemMouseLeave: handleItemMouseLeave,
    registerElement
  }, $3[28] = activeElement, $3[29] = handleItemMouseEnter, $3[30] = handleItemMouseLeave, $3[31] = mount, $3[32] = onClickOutside, $3[33] = onEscape, $3[34] = onItemClick, $3[35] = registerElement, $3[36] = t9) : t9 = $3[36];
  const value = t9;
  let t10;
  $3[37] !== children || $3[38] !== space ? (t10 = (0, import_jsx_runtime.jsx)(Stack, { space, children }), $3[37] = children, $3[38] = space, $3[39] = t10) : t10 = $3[39];
  let t11;
  $3[40] !== handleKeyDown || $3[41] !== handleRefChange || $3[42] !== padding || $3[43] !== restProps || $3[44] !== t10 ? (t11 = (0, import_jsx_runtime.jsx)(StyledMenu, { "data-ui": "Menu", ...restProps, onKeyDown: handleKeyDown, padding, ref: handleRefChange, role: "menu", tabIndex: -1, children: t10 }), $3[40] = handleKeyDown, $3[41] = handleRefChange, $3[42] = padding, $3[43] = restProps, $3[44] = t10, $3[45] = t11) : t11 = $3[45];
  let t12;
  return $3[46] !== t11 || $3[47] !== value ? (t12 = (0, import_jsx_runtime.jsx)(MenuContext.Provider, { value, children: t11 }), $3[46] = t11, $3[47] = value, $3[48] = t12) : t12 = $3[48], t12;
});
Menu.displayName = "ForwardRef(Menu)";
var MenuDivider = dt.hr.withConfig({
  displayName: "MenuDivider",
  componentId: "sc-uhoxwu-0"
})`height:1px;border:0;background:var(--card-hairline-soft-color);margin:0;`;
MenuDivider.displayName = "MenuDivider";
function selectableBaseStyle() {
  return lt`
    background-color: inherit;
    color: inherit;

    &[data-as='button'] {
      -webkit-font-smoothing: inherit;
      appearance: none;
      outline: none;
      font: inherit;
      text-align: inherit;
      border: 0;
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    }

    /* &:is(a) */
    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function selectableColorStyle(props) {
  const {
    $tone
  } = props, {
    color: color2,
    style
  } = getTheme_v2(props.theme), tone = color2.selectable[$tone];
  return lt`
    ${_cardColorStyle(color2, tone.enabled)}

    background-color: var(--card-bg-color);
    color: var(--card-fg-color);
    outline: none;

    /* &:is(button) */
    &[data-as='button'] {
      &:disabled {
        ${_cardColorStyle(color2, tone.disabled)}
      }

      &:not(:disabled) {
        &[aria-pressed='true'] {
          ${_cardColorStyle(color2, tone.pressed)}
        }

        &[data-selected],
        &[aria-selected='true'] > & {
          ${_cardColorStyle(color2, tone.selected)}
        }

        @media (hover: hover) {
          &:not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color2, tone.hovered)}
            }

            &:active {
              ${_cardColorStyle(color2, tone.pressed)}
            }
          }
        }
      }
    }

    /* &:is(a) */
    &[data-as='a'] {
      &[data-disabled] {
        ${_cardColorStyle(color2, tone.disabled)}
      }

      &:not([data-disabled]) {
        &[data-pressed] {
          ${_cardColorStyle(color2, tone.pressed)}
        }

        &[data-selected] {
          ${_cardColorStyle(color2, tone.selected)}
        }

        @media (hover: hover) {
          &:not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color2, tone.hovered)}
            }
            &:active {
              ${_cardColorStyle(color2, tone.pressed)}
            }
          }
        }
      }
    }

    ${style?.card?.root}
  `;
}
var Selectable = dt(Box).withConfig({
  displayName: "Selectable",
  componentId: "sc-1w01ang-0"
})(responsiveRadiusStyle, selectableBaseStyle, selectableColorStyle);
Selectable.displayName = "Selectable";
function useMenu() {
  const value = (0, import_react.useContext)(MenuContext);
  if (!value)
    throw new Error("useMenu(): missing context value");
  if (!isRecord2(value) || value.version !== 2)
    throw new Error("useMenu(): the context value is not compatible");
  return value;
}
function MenuGroup(props) {
  const $3 = (0, import_react_compiler_runtime.c)(81);
  let IconComponent, children, menuProps, onClick, popover, restProps, t0, t1, t22, t3, t4, t5, text;
  $3[0] !== props ? ({
    as: t0,
    children,
    fontSize: t1,
    icon: IconComponent,
    menu: menuProps,
    onClick,
    padding: t22,
    popover,
    radius: t3,
    space: t4,
    text,
    tone: t5,
    ...restProps
  } = props, $3[0] = props, $3[1] = IconComponent, $3[2] = children, $3[3] = menuProps, $3[4] = onClick, $3[5] = popover, $3[6] = restProps, $3[7] = t0, $3[8] = t1, $3[9] = t22, $3[10] = t3, $3[11] = t4, $3[12] = t5, $3[13] = text) : (IconComponent = $3[1], children = $3[2], menuProps = $3[3], onClick = $3[4], popover = $3[5], restProps = $3[6], t0 = $3[7], t1 = $3[8], t22 = $3[9], t3 = $3[10], t4 = $3[11], t5 = $3[12], text = $3[13]);
  const as = t0 === void 0 ? "button" : t0, fontSize2 = t1 === void 0 ? 1 : t1, padding = t22 === void 0 ? 3 : t22, radius = t3 === void 0 ? 2 : t3, space = t4 === void 0 ? 3 : t4, tone = t5 === void 0 ? "default" : t5, menu = useMenu(), {
    scheme
  } = useRootTheme(), {
    activeElement,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter: _onItemMouseEnter,
    registerElement
  } = menu, onItemMouseEnter = _onItemMouseEnter ?? menu.onItemMouseEnter, [rootElement, setRootElement] = (0, import_react.useState)(null), [open, setOpen] = (0, import_react.useState)(false), [shouldFocus, setShouldFocus] = (0, import_react.useState)(null), active = !!activeElement && activeElement === rootElement, [withinMenu, setWithinMenu] = (0, import_react.useState)(false);
  let t6;
  $3[14] !== onItemMouseEnter ? (t6 = (event) => {
    setWithinMenu(false), onItemMouseEnter(event), setOpen(true);
  }, $3[14] = onItemMouseEnter, $3[15] = t6) : t6 = $3[15];
  const handleMouseEnter = t6;
  let t7;
  $3[16] !== rootElement ? (t7 = (event_0) => {
    event_0.key === "ArrowLeft" && (event_0.stopPropagation(), setOpen(false), requestAnimationFrame(() => {
      rootElement?.focus();
    }));
  }, $3[16] = rootElement, $3[17] = t7) : t7 = $3[17];
  const handleMenuKeyDown = t7;
  let t8;
  $3[18] !== onClick ? (t8 = (event_1) => {
    onClick?.(event_1), setShouldFocus("first"), setOpen(true);
  }, $3[18] = onClick, $3[19] = t8) : t8 = $3[19];
  const handleClick = t8;
  let t9;
  $3[20] !== onItemClick ? (t9 = () => {
    setOpen(false), onItemClick?.();
  }, $3[20] = onItemClick, $3[21] = t9) : t9 = $3[21];
  const handleChildItemClick = t9;
  let t10;
  $3[22] === Symbol.for("react.memo_cache_sentinel") ? (t10 = () => setWithinMenu(true), $3[22] = t10) : t10 = $3[22];
  const handleMenuMouseEnter = t10;
  let t11, t12;
  $3[23] !== mount || $3[24] !== rootElement ? (t11 = () => mount(rootElement), t12 = [mount, rootElement], $3[23] = mount, $3[24] = rootElement, $3[25] = t11, $3[26] = t12) : (t11 = $3[25], t12 = $3[26]), (0, import_react.useEffect)(t11, t12);
  let t13, t14;
  $3[27] !== active ? (t13 = () => {
    active || setOpen(false);
  }, t14 = [active], $3[27] = active, $3[28] = t13, $3[29] = t14) : (t13 = $3[28], t14 = $3[29]), (0, import_react.useEffect)(t13, t14);
  let t15, t16;
  $3[30] !== open ? (t15 = () => {
    open || setWithinMenu(false);
  }, t16 = [open], $3[30] = open, $3[31] = t15, $3[32] = t16) : (t15 = $3[31], t16 = $3[32]), (0, import_react.useEffect)(t15, t16);
  let t17, t18;
  $3[33] !== shouldFocus ? (t17 = () => {
    if (!shouldFocus)
      return;
    const rafId = requestAnimationFrame(() => setShouldFocus(null));
    return () => cancelAnimationFrame(rafId);
  }, t18 = [shouldFocus], $3[33] = shouldFocus, $3[34] = t17, $3[35] = t18) : (t17 = $3[34], t18 = $3[35]), (0, import_react.useEffect)(t17, t18);
  let t19;
  $3[36] !== children || $3[37] !== handleChildItemClick || $3[38] !== handleMenuKeyDown || $3[39] !== menuProps || $3[40] !== onClickOutside || $3[41] !== onEscape || $3[42] !== registerElement || $3[43] !== shouldFocus ? (t19 = (0, import_jsx_runtime.jsx)(Menu, { ...menuProps, onClickOutside, onEscape, onItemClick: handleChildItemClick, onKeyDown: handleMenuKeyDown, onMouseEnter: handleMenuMouseEnter, registerElement, shouldFocus, children }), $3[36] = children, $3[37] = handleChildItemClick, $3[38] = handleMenuKeyDown, $3[39] = menuProps, $3[40] = onClickOutside, $3[41] = onEscape, $3[42] = registerElement, $3[43] = shouldFocus, $3[44] = t19) : t19 = $3[44];
  const childMenu = t19;
  let t20;
  $3[45] === Symbol.for("react.memo_cache_sentinel") ? (t20 = (event_2) => {
    const target = event_2.currentTarget;
    if (document.activeElement === target && event_2.key === "ArrowRight") {
      setShouldFocus("first"), setOpen(true), setWithinMenu(true);
      return;
    }
  }, $3[45] = t20) : t20 = $3[45];
  const handleKeyDown = t20, t21 = as === "button" ? withinMenu : void 0, t222 = as !== "button" ? withinMenu : void 0, t23 = !withinMenu && active ? "" : void 0;
  let t24;
  $3[46] !== radius ? (t24 = _getArrayProp(radius), $3[46] = radius, $3[47] = t24) : t24 = $3[47];
  const t25 = as === "button" ? "button" : void 0;
  let t26;
  $3[48] !== IconComponent || $3[49] !== fontSize2 ? (t26 = IconComponent && (0, import_jsx_runtime.jsxs)(Text, { size: fontSize2, children: [
    (0, import_react.isValidElement)(IconComponent) && IconComponent,
    (0, import_react_is.isValidElementType)(IconComponent) && (0, import_jsx_runtime.jsx)(IconComponent, {})
  ] }), $3[48] = IconComponent, $3[49] = fontSize2, $3[50] = t26) : t26 = $3[50];
  let t27;
  $3[51] !== fontSize2 || $3[52] !== text ? (t27 = (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsx)(Text, { size: fontSize2, textOverflow: "ellipsis", weight: "medium", children: text }) }), $3[51] = fontSize2, $3[52] = text, $3[53] = t27) : t27 = $3[53];
  let t28;
  $3[54] === Symbol.for("react.memo_cache_sentinel") ? (t28 = (0, import_jsx_runtime.jsx)(ChevronRightIcon, {}), $3[54] = t28) : t28 = $3[54];
  let t29;
  $3[55] !== fontSize2 ? (t29 = (0, import_jsx_runtime.jsx)(Text, { size: fontSize2, children: t28 }), $3[55] = fontSize2, $3[56] = t29) : t29 = $3[56];
  let t30;
  $3[57] !== padding || $3[58] !== space || $3[59] !== t26 || $3[60] !== t27 || $3[61] !== t29 ? (t30 = (0, import_jsx_runtime.jsxs)(Flex, { gap: space, padding, children: [
    t26,
    t27,
    t29
  ] }), $3[57] = padding, $3[58] = space, $3[59] = t26, $3[60] = t27, $3[61] = t29, $3[62] = t30) : t30 = $3[62];
  let t31;
  $3[63] !== as || $3[64] !== handleClick || $3[65] !== handleMouseEnter || $3[66] !== restProps || $3[67] !== scheme || $3[68] !== t21 || $3[69] !== t222 || $3[70] !== t23 || $3[71] !== t24 || $3[72] !== t25 || $3[73] !== t30 || $3[74] !== tone ? (t31 = (0, import_jsx_runtime.jsx)(Selectable, { "data-as": as, "data-ui": "MenuGroup", forwardedAs: as, ...restProps, "aria-pressed": t21, "data-pressed": t222, "data-selected": t23, $radius: t24, $tone: tone, $scheme: scheme, onClick: handleClick, onKeyDown: handleKeyDown, onMouseEnter: handleMouseEnter, ref: setRootElement, tabIndex: -1, type: t25, children: t30 }), $3[63] = as, $3[64] = handleClick, $3[65] = handleMouseEnter, $3[66] = restProps, $3[67] = scheme, $3[68] = t21, $3[69] = t222, $3[70] = t23, $3[71] = t24, $3[72] = t25, $3[73] = t30, $3[74] = tone, $3[75] = t31) : t31 = $3[75];
  let t32;
  return $3[76] !== childMenu || $3[77] !== open || $3[78] !== popover || $3[79] !== t31 ? (t32 = (0, import_jsx_runtime.jsx)(Popover, { ...popover, content: childMenu, "data-ui": "MenuGroup__popover", open, children: t31 }), $3[76] = childMenu, $3[77] = open, $3[78] = popover, $3[79] = t31, $3[80] = t32) : t32 = $3[80], t32;
}
MenuGroup.displayName = "MenuGroup";
var MenuItem = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(75);
  let IconComponent, IconRightComponent, children, disabled, hotkeys, onClick, paddingBottom, paddingLeft, paddingRight, paddingTop, paddingX, paddingY, pressed, restProps, selectedProp, t0, t1, t22, t3, t4, t5, text;
  $3[0] !== props ? ({
    as: t0,
    children,
    disabled,
    fontSize: t1,
    hotkeys,
    icon: IconComponent,
    iconRight: IconRightComponent,
    onClick,
    padding: t22,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    pressed,
    radius: t3,
    selected: selectedProp,
    space: t4,
    text,
    tone: t5,
    ...restProps
  } = props, $3[0] = props, $3[1] = IconComponent, $3[2] = IconRightComponent, $3[3] = children, $3[4] = disabled, $3[5] = hotkeys, $3[6] = onClick, $3[7] = paddingBottom, $3[8] = paddingLeft, $3[9] = paddingRight, $3[10] = paddingTop, $3[11] = paddingX, $3[12] = paddingY, $3[13] = pressed, $3[14] = restProps, $3[15] = selectedProp, $3[16] = t0, $3[17] = t1, $3[18] = t22, $3[19] = t3, $3[20] = t4, $3[21] = t5, $3[22] = text) : (IconComponent = $3[1], IconRightComponent = $3[2], children = $3[3], disabled = $3[4], hotkeys = $3[5], onClick = $3[6], paddingBottom = $3[7], paddingLeft = $3[8], paddingRight = $3[9], paddingTop = $3[10], paddingX = $3[11], paddingY = $3[12], pressed = $3[13], restProps = $3[14], selectedProp = $3[15], t0 = $3[16], t1 = $3[17], t22 = $3[18], t3 = $3[19], t4 = $3[20], t5 = $3[21], text = $3[22]);
  const as = t0 === void 0 ? "button" : t0, fontSize2 = t1 === void 0 ? 1 : t1, padding = t22 === void 0 ? 3 : t22, radius = t3 === void 0 ? 2 : t3, space = t4 === void 0 ? 3 : t4, tone = t5 === void 0 ? "default" : t5, {
    scheme
  } = useRootTheme(), menu = useMenu(), {
    activeElement,
    mount,
    onItemClick,
    onItemMouseEnter: _onItemMouseEnter,
    onItemMouseLeave: _onItemMouseLeave
  } = menu, onItemMouseEnter = _onItemMouseEnter ?? menu.onItemMouseEnter, onItemMouseLeave = _onItemMouseLeave ?? menu.onItemMouseLeave, [rootElement, setRootElement] = (0, import_react.useState)(null), active = !!activeElement && activeElement === rootElement, ref = (0, import_react.useRef)(null);
  let t6;
  $3[23] === Symbol.for("react.memo_cache_sentinel") ? (t6 = () => ref.current, $3[23] = t6) : t6 = $3[23], (0, import_react.useImperativeHandle)(forwardedRef, t6);
  let t7, t8;
  $3[24] !== mount || $3[25] !== rootElement || $3[26] !== selectedProp ? (t7 = () => mount(rootElement, selectedProp), t8 = [mount, rootElement, selectedProp], $3[24] = mount, $3[25] = rootElement, $3[26] = selectedProp, $3[27] = t7, $3[28] = t8) : (t7 = $3[27], t8 = $3[28]), (0, import_react.useEffect)(t7, t8);
  let t9;
  $3[29] !== disabled || $3[30] !== onClick || $3[31] !== onItemClick ? (t9 = (event) => {
    disabled || (onClick && onClick(event), onItemClick && onItemClick());
  }, $3[29] = disabled, $3[30] = onClick, $3[31] = onItemClick, $3[32] = t9) : t9 = $3[32];
  const handleClick = t9;
  let t10;
  $3[33] !== padding || $3[34] !== paddingBottom || $3[35] !== paddingLeft || $3[36] !== paddingRight || $3[37] !== paddingTop || $3[38] !== paddingX || $3[39] !== paddingY ? (t10 = {
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft
  }, $3[33] = padding, $3[34] = paddingBottom, $3[35] = paddingLeft, $3[36] = paddingRight, $3[37] = paddingTop, $3[38] = paddingX, $3[39] = paddingY, $3[40] = t10) : t10 = $3[40];
  const paddingProps = t10;
  let t11;
  $3[41] !== fontSize2 ? (t11 = _getArrayProp(fontSize2).map(_temp), $3[41] = fontSize2, $3[42] = t11) : t11 = $3[42];
  const hotkeysFontSize = t11;
  let t12;
  $3[43] === Symbol.for("react.memo_cache_sentinel") ? (t12 = (el) => {
    ref.current = el, setRootElement(el);
  }, $3[43] = t12) : t12 = $3[43];
  const setRef = t12, t13 = as !== "button" && pressed ? "" : void 0, t14 = active ? "" : void 0, t15 = disabled ? "" : void 0;
  let t16;
  $3[44] !== radius ? (t16 = _getArrayProp(radius), $3[44] = radius, $3[45] = t16) : t16 = $3[45];
  let t17;
  $3[46] === Symbol.for("react.memo_cache_sentinel") ? (t17 = _getArrayProp(0), $3[46] = t17) : t17 = $3[46];
  const t18 = disabled ? "default" : tone, t19 = as === "button" ? "button" : void 0;
  let t20;
  $3[47] !== IconComponent || $3[48] !== IconRightComponent || $3[49] !== fontSize2 || $3[50] !== hotkeys || $3[51] !== hotkeysFontSize || $3[52] !== paddingProps || $3[53] !== space || $3[54] !== text ? (t20 = (IconComponent || text || IconRightComponent) && (0, import_jsx_runtime.jsxs)(Flex, { as: "span", gap: space, align: "center", ...paddingProps, children: [
    IconComponent && (0, import_jsx_runtime.jsxs)(Text, { size: fontSize2, children: [
      (0, import_react.isValidElement)(IconComponent) && IconComponent,
      (0, import_react_is.isValidElementType)(IconComponent) && (0, import_jsx_runtime.jsx)(IconComponent, {})
    ] }),
    text && (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsx)(Text, { size: fontSize2, textOverflow: "ellipsis", weight: "medium", children: text }) }),
    hotkeys && (0, import_jsx_runtime.jsx)(Hotkeys, { fontSize: hotkeysFontSize, keys: hotkeys, style: {
      marginTop: -4,
      marginBottom: -4
    } }),
    IconRightComponent && (0, import_jsx_runtime.jsxs)(Text, { size: fontSize2, children: [
      (0, import_react.isValidElement)(IconRightComponent) && IconRightComponent,
      (0, import_react_is.isValidElementType)(IconRightComponent) && (0, import_jsx_runtime.jsx)(IconRightComponent, {})
    ] })
  ] }), $3[47] = IconComponent, $3[48] = IconRightComponent, $3[49] = fontSize2, $3[50] = hotkeys, $3[51] = hotkeysFontSize, $3[52] = paddingProps, $3[53] = space, $3[54] = text, $3[55] = t20) : t20 = $3[55];
  let t21;
  $3[56] !== children || $3[57] !== paddingProps ? (t21 = children && (0, import_jsx_runtime.jsx)(Box, { as: "span", ...paddingProps, children }), $3[56] = children, $3[57] = paddingProps, $3[58] = t21) : t21 = $3[58];
  let t222;
  return $3[59] !== as || $3[60] !== disabled || $3[61] !== handleClick || $3[62] !== onItemMouseEnter || $3[63] !== onItemMouseLeave || $3[64] !== restProps || $3[65] !== scheme || $3[66] !== t13 || $3[67] !== t14 || $3[68] !== t15 || $3[69] !== t16 || $3[70] !== t18 || $3[71] !== t19 || $3[72] !== t20 || $3[73] !== t21 ? (t222 = (0, import_jsx_runtime.jsxs)(Selectable, { "data-ui": "MenuItem", role: "menuitem", ...restProps, "data-pressed": t13, "data-selected": t14, "data-disabled": t15, forwardedAs: as, $radius: t16, $padding: t17, $tone: t18, $scheme: scheme, disabled, onClick: handleClick, onMouseEnter: onItemMouseEnter, onMouseLeave: onItemMouseLeave, ref: setRef, tabIndex: -1, type: t19, children: [
    t20,
    t21
  ] }), $3[59] = as, $3[60] = disabled, $3[61] = handleClick, $3[62] = onItemMouseEnter, $3[63] = onItemMouseLeave, $3[64] = restProps, $3[65] = scheme, $3[66] = t13, $3[67] = t14, $3[68] = t15, $3[69] = t16, $3[70] = t18, $3[71] = t19, $3[72] = t20, $3[73] = t21, $3[74] = t222) : t222 = $3[74], t222;
});
MenuItem.displayName = "ForwardRef(MenuItem)";
function _temp(s3) {
  return s3 - 1;
}
var CustomButton = dt(Button).withConfig({
  displayName: "CustomButton",
  componentId: "sc-1kns779-0"
})`max-width:100%;`;
var Tab = (0, import_react.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime.c)(30);
  let focused, icon, id, label, onClick, onFocus2, restProps, selected, t0, t1;
  $3[0] !== props ? ({
    icon,
    id,
    focused,
    fontSize: t0,
    label,
    onClick,
    onFocus: onFocus2,
    padding: t1,
    selected,
    ...restProps
  } = props, $3[0] = props, $3[1] = focused, $3[2] = icon, $3[3] = id, $3[4] = label, $3[5] = onClick, $3[6] = onFocus2, $3[7] = restProps, $3[8] = selected, $3[9] = t0, $3[10] = t1) : (focused = $3[1], icon = $3[2], id = $3[3], label = $3[4], onClick = $3[5], onFocus2 = $3[6], restProps = $3[7], selected = $3[8], t0 = $3[9], t1 = $3[10]);
  const fontSize2 = t0 === void 0 ? 1 : t0, padding = t1 === void 0 ? 2 : t1, ref = (0, import_react.useRef)(null), focusedRef = (0, import_react.useRef)(false);
  let t22;
  $3[11] === Symbol.for("react.memo_cache_sentinel") ? (t22 = () => ref.current, $3[11] = t22) : t22 = $3[11], (0, import_react.useImperativeHandle)(forwardedRef, t22);
  let t3;
  $3[12] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => {
    focusedRef.current = false;
  }, $3[12] = t3) : t3 = $3[12];
  const handleBlur = t3;
  let t4;
  $3[13] !== onFocus2 ? (t4 = (event) => {
    focusedRef.current = true, onFocus2 && onFocus2(event);
  }, $3[13] = onFocus2, $3[14] = t4) : t4 = $3[14];
  const handleFocus = t4;
  let t5, t6;
  $3[15] !== focused ? (t5 = () => {
    focused && !focusedRef.current && (ref.current && ref.current.focus(), focusedRef.current = true);
  }, t6 = [focused], $3[15] = focused, $3[16] = t5, $3[17] = t6) : (t5 = $3[16], t6 = $3[17]), (0, import_react.useEffect)(t5, t6);
  const t7 = selected ? "true" : "false", t8 = selected ? 0 : -1;
  let t9;
  return $3[18] !== fontSize2 || $3[19] !== handleFocus || $3[20] !== icon || $3[21] !== id || $3[22] !== label || $3[23] !== onClick || $3[24] !== padding || $3[25] !== restProps || $3[26] !== selected || $3[27] !== t7 || $3[28] !== t8 ? (t9 = (0, import_jsx_runtime.jsx)(CustomButton, { "data-ui": "Tab", ...restProps, "aria-selected": t7, fontSize: fontSize2, icon, id, mode: "bleed", onClick, onBlur: handleBlur, onFocus: handleFocus, padding, ref, role: "tab", selected, tabIndex: t8, text: label, type: "button" }), $3[18] = fontSize2, $3[19] = handleFocus, $3[20] = icon, $3[21] = id, $3[22] = label, $3[23] = onClick, $3[24] = padding, $3[25] = restProps, $3[26] = selected, $3[27] = t7, $3[28] = t8, $3[29] = t9) : t9 = $3[29], t9;
});
Tab.displayName = "ForwardRef(Tab)";
var CustomInline = dt(Inline).withConfig({
  displayName: "CustomInline",
  componentId: "sc-5cm04m-0"
})`& > div{display:inline-block;vertical-align:middle;max-width:100%;box-sizing:border-box;}`;
var TabList = (0, import_react.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime.c)(15);
  let childrenProp, restProps;
  $3[0] !== props ? ({
    children: childrenProp,
    ...restProps
  } = props, $3[0] = props, $3[1] = childrenProp, $3[2] = restProps) : (childrenProp = $3[1], restProps = $3[2]);
  const [focusedIndex, setFocusedIndex] = (0, import_react.useState)(-1);
  let t0;
  if ($3[3] !== childrenProp || $3[4] !== focusedIndex) {
    const children = import_react.Children.toArray(childrenProp).filter(import_react.isValidElement);
    let t12;
    $3[6] !== focusedIndex ? (t12 = (child, childIndex) => (0, import_react.cloneElement)(child, {
      focused: focusedIndex === childIndex,
      key: childIndex,
      onFocus: () => setFocusedIndex(childIndex)
    }), $3[6] = focusedIndex, $3[7] = t12) : t12 = $3[7], t0 = children.map(t12), $3[3] = childrenProp, $3[4] = focusedIndex, $3[5] = t0;
  } else
    t0 = $3[5];
  const tabs = t0, numTabs = tabs.length;
  let t1;
  $3[8] !== numTabs ? (t1 = (event) => {
    event.key === "ArrowLeft" && setFocusedIndex((prevIndex) => (prevIndex + numTabs - 1) % numTabs), event.key === "ArrowRight" && setFocusedIndex((prevIndex_0) => (prevIndex_0 + 1) % numTabs);
  }, $3[8] = numTabs, $3[9] = t1) : t1 = $3[9];
  const handleKeyDown = t1;
  let t22;
  return $3[10] !== handleKeyDown || $3[11] !== ref || $3[12] !== restProps || $3[13] !== tabs ? (t22 = (0, import_jsx_runtime.jsx)(CustomInline, { "data-ui": "TabList", ...restProps, onKeyDown: handleKeyDown, ref, role: "tablist", children: tabs }), $3[10] = handleKeyDown, $3[11] = ref, $3[12] = restProps, $3[13] = tabs, $3[14] = t22) : t22 = $3[14], t22;
});
TabList.displayName = "ForwardRef(TabList)";

// node_modules/sanity-plugin-media/node_modules/@sanity/ui/dist/index.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react_compiler_runtime2 = __toESM(require_dist(), 1);
var import_react2 = __toESM(require_react(), 1);
function _raf(fn2) {
  const frameId = requestAnimationFrame(fn2);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _hasFocus(element) {
  return !!document.activeElement && element.contains(document.activeElement);
}
function isFocusable(element) {
  return element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null ? true : isHTMLAnchorElement(element) ? !!element.href && element.rel !== "ignore" : isHTMLInputElement(element) ? element.type !== "hidden" && element.type !== "file" && !element.disabled : isHTMLButtonElement(element) || isHTMLSelectElement(element) || isHTMLTextAreaElement(element) ? !element.disabled : false;
}
function attemptFocus(element) {
  if (!isFocusable(element))
    return false;
  try {
    element.focus();
  } catch {
  }
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i3 = 0; i3 < element.childNodes.length; i3++) {
    const child = element.childNodes[i3];
    if (isHTMLElement(child) && (attemptFocus(child) || focusFirstDescendant(child)))
      return true;
  }
  return false;
}
function focusLastDescendant(element) {
  for (let i3 = element.childNodes.length - 1; i3 >= 0; i3--) {
    const child = element.childNodes[i3];
    if (isHTMLElement(child) && (attemptFocus(child) || focusLastDescendant(child)))
      return true;
  }
  return false;
}
var StyledAutocomplete = dt.div.withConfig({
  displayName: "StyledAutocomplete",
  componentId: "sc-1igauft-0"
})`line-height:0;`;
var ListBox = dt(Box).withConfig({
  displayName: "ListBox",
  componentId: "sc-1igauft-1"
})`& > ul{list-style:none;padding:0;margin:0;}`;
var rotate2 = mt`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`;
var AnimatedSpinnerIcon = dt(SpinnerIcon).withConfig({
  displayName: "AnimatedSpinnerIcon",
  componentId: "sc-1igauft-2"
})`animation:${rotate2} 500ms linear infinite;`;
function AutocompleteOption(props) {
  const $3 = (0, import_react_compiler_runtime2.c)(11), {
    children,
    id,
    onSelect,
    selected,
    value
  } = props;
  let t0;
  $3[0] !== onSelect || $3[1] !== value ? (t0 = () => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, $3[0] = onSelect, $3[1] = value, $3[2] = t0) : t0 = $3[2];
  const handleClick = t0;
  let t1;
  $3[3] !== handleClick ? (t1 = (event) => {
    event.key === "Enter" && !_isEnterToClickElement(event.currentTarget) && handleClick();
  }, $3[3] = handleClick, $3[4] = t1) : t1 = $3[4];
  const handleKeyDown = t1;
  let t22;
  return $3[5] !== children || $3[6] !== handleClick || $3[7] !== handleKeyDown || $3[8] !== id || $3[9] !== selected ? (t22 = (0, import_jsx_runtime2.jsx)("li", { "aria-selected": selected, "data-ui": "AutocompleteOption", id, role: "option", onClick: handleClick, onKeyDown: handleKeyDown, children }), $3[5] = children, $3[6] = handleClick, $3[7] = handleKeyDown, $3[8] = id, $3[9] = selected, $3[10] = t22) : t22 = $3[10], t22;
}
function autocompleteReducer(state, msg) {
  return msg.type === "input/change" ? {
    ...state,
    activeValue: null,
    focused: true,
    query: msg.query
  } : msg.type === "input/focus" ? {
    ...state,
    focused: true
  } : msg.type === "root/blur" ? {
    ...state,
    focused: false,
    query: null
  } : msg.type === "root/clear" ? {
    ...state,
    activeValue: null,
    query: null,
    value: null
  } : msg.type === "root/escape" ? {
    ...state,
    focused: false,
    query: null
  } : msg.type === "root/open" ? {
    ...state,
    query: state.query || msg.query
  } : msg.type === "root/setActiveValue" ? {
    ...state,
    activeValue: msg.value,
    listFocused: msg.listFocused || state.listFocused
  } : msg.type === "root/setListFocused" ? {
    ...state,
    listFocused: msg.listFocused
  } : msg.type === "value/change" ? {
    ...state,
    activeValue: msg.value,
    query: null,
    value: msg.value
  } : state;
}
var AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = ["Control", "Shift", "Alt", "Enter", "Home", "End", "PageUp", "PageDown", "Meta", "Tab", "CapsLock"];
var AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start";
var AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"];
var DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value;
var DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1;
var InnerAutocomplete = (0, import_react2.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime2.c)(181);
  let customValidity, disabled, filterOptionProp, icon, id, loading, onBlur, onChange2, onFocus2, onQueryChange, onSelect, openButton, openOnFocus, optionsProp, prefix3, readOnly, relatedElements, renderOptionProp, renderPopover, restProps, suffix, t0, t1, t22, t3, t4, t5, t6, valueProp;
  $3[0] !== props ? ({
    border: t0,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize: t1,
    icon,
    id,
    listBox: t22,
    loading,
    onBlur,
    onChange: onChange2,
    onFocus: onFocus2,
    onQueryChange,
    onSelect,
    openButton,
    openOnFocus,
    options: optionsProp,
    padding: t3,
    popover: t4,
    prefix: prefix3,
    radius: t5,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue: t6,
    suffix,
    value: valueProp,
    ...restProps
  } = props, $3[0] = props, $3[1] = customValidity, $3[2] = disabled, $3[3] = filterOptionProp, $3[4] = icon, $3[5] = id, $3[6] = loading, $3[7] = onBlur, $3[8] = onChange2, $3[9] = onFocus2, $3[10] = onQueryChange, $3[11] = onSelect, $3[12] = openButton, $3[13] = openOnFocus, $3[14] = optionsProp, $3[15] = prefix3, $3[16] = readOnly, $3[17] = relatedElements, $3[18] = renderOptionProp, $3[19] = renderPopover, $3[20] = restProps, $3[21] = suffix, $3[22] = t0, $3[23] = t1, $3[24] = t22, $3[25] = t3, $3[26] = t4, $3[27] = t5, $3[28] = t6, $3[29] = valueProp) : (customValidity = $3[1], disabled = $3[2], filterOptionProp = $3[3], icon = $3[4], id = $3[5], loading = $3[6], onBlur = $3[7], onChange2 = $3[8], onFocus2 = $3[9], onQueryChange = $3[10], onSelect = $3[11], openButton = $3[12], openOnFocus = $3[13], optionsProp = $3[14], prefix3 = $3[15], readOnly = $3[16], relatedElements = $3[17], renderOptionProp = $3[18], renderPopover = $3[19], restProps = $3[20], suffix = $3[21], t0 = $3[22], t1 = $3[23], t22 = $3[24], t3 = $3[25], t4 = $3[26], t5 = $3[27], t6 = $3[28], valueProp = $3[29]);
  const border2 = t0 === void 0 ? true : t0, fontSize2 = t1 === void 0 ? 2 : t1, listBox = t22 === void 0 ? EMPTY_RECORD : t22, paddingProp = t3 === void 0 ? 3 : t3, popover = t4 === void 0 ? EMPTY_RECORD : t4, radius = t5 === void 0 ? 2 : t5, renderValue = t6 === void 0 ? DEFAULT_RENDER_VALUE : t6, t7 = valueProp || null, t8 = valueProp || null;
  let t9;
  $3[30] !== t7 || $3[31] !== t8 ? (t9 = {
    activeValue: t7,
    focused: false,
    listFocused: false,
    query: null,
    value: t8
  }, $3[30] = t7, $3[31] = t8, $3[32] = t9) : t9 = $3[32];
  const [state, dispatch] = (0, import_react2.useReducer)(autocompleteReducer, t9), {
    activeValue,
    focused,
    listFocused,
    query,
    value
  } = state;
  let t10;
  $3[33] !== fontSize2 || $3[34] !== paddingProp ? (t10 = (t112) => {
    const {
      value: value_0
    } = t112;
    return (0, import_jsx_runtime2.jsx)(Card, { "data-as": "button", padding: paddingProp, radius: 2, tone: "inherit", children: (0, import_jsx_runtime2.jsx)(Text, { size: fontSize2, textOverflow: "ellipsis", children: value_0 }) });
  }, $3[33] = fontSize2, $3[34] = paddingProp, $3[35] = t10) : t10 = $3[35];
  const renderOption = typeof renderOptionProp == "function" ? renderOptionProp : t10, filterOption = typeof filterOptionProp == "function" ? filterOptionProp : DEFAULT_FILTER_OPTION, rootElementRef = (0, import_react2.useRef)(null), resultsPopoverElementRef = (0, import_react2.useRef)(null), inputElementRef = (0, import_react2.useRef)(null), listBoxElementRef = (0, import_react2.useRef)(null), [inputElement, _setInputElement] = (0, import_react2.useState)(null);
  let t11;
  $3[36] === Symbol.for("react.memo_cache_sentinel") ? (t11 = (node2) => {
    (0, import_react2.startTransition)(() => _setInputElement(node2));
  }, $3[36] = t11) : t11 = $3[36];
  const setInputElement = t11, listFocusedRef = (0, import_react2.useRef)(false), valueRef = (0, import_react2.useRef)(value), valuePropRef = (0, import_react2.useRef)(valueProp), popoverMouseWithinRef = (0, import_react2.useRef)(false);
  let t12, t13;
  $3[37] !== inputElement ? (t12 = () => inputElement, t13 = [inputElement], $3[37] = inputElement, $3[38] = t12, $3[39] = t13) : (t12 = $3[38], t13 = $3[39]), (0, import_react2.useImperativeHandle)(inputElementRef, t12, t13);
  let t14, t15;
  $3[40] !== inputElement ? (t14 = () => inputElement, t15 = [inputElement], $3[40] = inputElement, $3[41] = t14, $3[42] = t15) : (t14 = $3[41], t15 = $3[42]), (0, import_react2.useImperativeHandle)(forwardedRef, t14, t15);
  const listBoxId = `${id}-listbox`, options2 = Array.isArray(optionsProp) ? optionsProp : EMPTY_ARRAY, padding = _getArrayProp(paddingProp);
  let t16;
  $3[43] !== options2 || $3[44] !== value ? (t16 = value !== null ? options2.find((o3) => o3.value === value) : void 0, $3[43] = options2, $3[44] = value, $3[45] = t16) : t16 = $3[45];
  const currentOption = t16;
  let t17;
  if ($3[46] !== filterOption || $3[47] !== options2 || $3[48] !== query) {
    let t182;
    $3[50] !== filterOption || $3[51] !== query ? (t182 = (option) => query ? filterOption(query, option) : true, $3[50] = filterOption, $3[51] = query, $3[52] = t182) : t182 = $3[52], t17 = options2.filter(t182), $3[46] = filterOption, $3[47] = options2, $3[48] = query, $3[49] = t17;
  } else
    t17 = $3[49];
  const filteredOptions = t17, filteredOptionsLen = filteredOptions.length, activeItemId = activeValue ? `${id}-option-${activeValue}` : void 0, expanded = query !== null && loading || focused && query !== null;
  let t18;
  $3[53] !== onBlur || $3[54] !== onQueryChange || $3[55] !== relatedElements ? (t18 = (event) => {
    setTimeout(() => {
      if (popoverMouseWithinRef.current)
        return;
      const elements = (relatedElements || []).concat(rootElementRef.current ? [rootElementRef.current] : [], resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []);
      let focusInside = false;
      if (document.activeElement) {
        for (const e2 of elements)
          if (e2 === document.activeElement || e2.contains(document.activeElement)) {
            focusInside = true;
            break;
          }
      }
      focusInside === false && (dispatch({
        type: "root/blur"
      }), popoverMouseWithinRef.current = false, onQueryChange && onQueryChange(null), onBlur && onBlur(event));
    }, 0);
  }, $3[53] = onBlur, $3[54] = onQueryChange, $3[55] = relatedElements, $3[56] = t18) : t18 = $3[56];
  const handleRootBlur = t18;
  let t19;
  $3[57] === Symbol.for("react.memo_cache_sentinel") ? (t19 = (event_0) => {
    const listBoxElement = listBoxElementRef.current, focusedElement = event_0.target instanceof HTMLElement ? event_0.target : null, listFocused_0 = listBoxElement?.contains(focusedElement) || false;
    listFocused_0 !== listFocusedRef.current && (listFocusedRef.current = listFocused_0, dispatch({
      type: "root/setListFocused",
      listFocused: listFocused_0
    }));
  }, $3[57] = t19) : t19 = $3[57];
  const handleRootFocus = t19;
  let t20;
  $3[58] !== onChange2 || $3[59] !== onQueryChange || $3[60] !== onSelect ? (t20 = (v2) => {
    dispatch({
      type: "value/change",
      value: v2
    }), popoverMouseWithinRef.current = false, onSelect && onSelect(v2), valueRef.current = v2, onChange2 && onChange2(v2), onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
  }, $3[58] = onChange2, $3[59] = onQueryChange, $3[60] = onSelect, $3[61] = t20) : t20 = $3[61];
  const handleOptionSelect = t20;
  let t21;
  $3[62] !== activeValue || $3[63] !== filteredOptions || $3[64] !== filteredOptionsLen || $3[65] !== onQueryChange ? (t21 = (event_1) => {
    if (event_1.key === "ArrowDown") {
      if (event_1.preventDefault(), !filteredOptionsLen)
        return;
      const activeOption = filteredOptions.find((o_0) => o_0.value === activeValue), activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1, nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
      nextActiveOption && dispatch({
        type: "root/setActiveValue",
        value: nextActiveOption.value,
        listFocused: true
      });
      return;
    }
    if (event_1.key === "ArrowUp") {
      if (event_1.preventDefault(), !filteredOptionsLen)
        return;
      const activeOption_0 = filteredOptions.find((o_1) => o_1.value === activeValue), activeIndex_0 = activeOption_0 ? filteredOptions.indexOf(activeOption_0) : -1, nextActiveOption_0 = filteredOptions[activeIndex_0 === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex_0 - 1) % filteredOptionsLen];
      nextActiveOption_0 && dispatch({
        type: "root/setActiveValue",
        value: nextActiveOption_0.value,
        listFocused: true
      });
      return;
    }
    if (event_1.key === "Escape") {
      dispatch({
        type: "root/escape"
      }), popoverMouseWithinRef.current = false, onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
      return;
    }
    const target = event_1.target, listEl = listBoxElementRef.current;
    if ((listEl === target || listEl?.contains(target)) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event_1.key)) {
      inputElementRef.current?.focus();
      return;
    }
  }, $3[62] = activeValue, $3[63] = filteredOptions, $3[64] = filteredOptionsLen, $3[65] = onQueryChange, $3[66] = t21) : t21 = $3[66];
  const handleRootKeyDown = t21;
  let t222;
  $3[67] !== onQueryChange ? (t222 = (event_2) => {
    const nextQuery = event_2.currentTarget.value;
    dispatch({
      type: "input/change",
      query: nextQuery
    }), onQueryChange && onQueryChange(nextQuery);
  }, $3[67] = onQueryChange, $3[68] = t222) : t222 = $3[68];
  const handleInputChange = t222;
  let t23;
  $3[69] !== currentOption || $3[70] !== renderValue || $3[71] !== value ? (t23 = () => {
    dispatch({
      type: "root/open",
      query: value ? renderValue(value, currentOption) : ""
    });
  }, $3[69] = currentOption, $3[70] = renderValue, $3[71] = value, $3[72] = t23) : t23 = $3[72];
  const dispatchOpen = t23;
  let t24;
  $3[73] !== dispatchOpen || $3[74] !== focused || $3[75] !== onFocus2 || $3[76] !== openOnFocus ? (t24 = (event_3) => {
    focused || (dispatch({
      type: "input/focus"
    }), onFocus2 && onFocus2(event_3), openOnFocus && dispatchOpen());
  }, $3[73] = dispatchOpen, $3[74] = focused, $3[75] = onFocus2, $3[76] = openOnFocus, $3[77] = t24) : t24 = $3[77];
  const handleInputFocus = t24;
  let t25;
  $3[78] === Symbol.for("react.memo_cache_sentinel") ? (t25 = () => {
    popoverMouseWithinRef.current = true;
  }, $3[78] = t25) : t25 = $3[78];
  const handlePopoverMouseEnter = t25;
  let t26;
  $3[79] === Symbol.for("react.memo_cache_sentinel") ? (t26 = () => {
    popoverMouseWithinRef.current = false;
  }, $3[79] = t26) : t26 = $3[79];
  const handlePopoverMouseLeave = t26;
  let t27;
  $3[80] !== onChange2 || $3[81] !== onQueryChange ? (t27 = () => {
    dispatch({
      type: "root/clear"
    }), valueRef.current = "", onChange2 && onChange2(""), onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
  }, $3[80] = onChange2, $3[81] = onQueryChange, $3[82] = t27) : t27 = $3[82];
  const handleClearButtonClick = t27;
  let t28;
  $3[83] === Symbol.for("react.memo_cache_sentinel") ? (t28 = () => {
    dispatch({
      type: "input/focus"
    });
  }, $3[83] = t28) : t28 = $3[83];
  const handleClearButtonFocus = t28;
  let t29, t30;
  $3[84] !== valueProp ? (t29 = () => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp, valueProp !== void 0 && (dispatch({
        type: "value/change",
        value: valueProp
      }), valueRef.current = valueProp);
      return;
    }
    valueProp !== valueRef.current && (valueRef.current = valueProp || null, dispatch({
      type: "value/change",
      value: valueProp || null
    }));
  }, t30 = [valueProp], $3[84] = valueProp, $3[85] = t29, $3[86] = t30) : (t29 = $3[85], t30 = $3[86]), (0, import_react2.useEffect)(t29, t30);
  let t31, t32;
  $3[87] !== focused ? (t31 = () => {
    !focused && valueRef.current && dispatch({
      type: "root/setActiveValue",
      value: valueRef.current
    });
  }, t32 = [focused], $3[87] = focused, $3[88] = t31, $3[89] = t32) : (t31 = $3[88], t32 = $3[89]), (0, import_react2.useEffect)(t31, t32);
  let t33, t34;
  $3[90] !== activeValue || $3[91] !== filteredOptions ? (t33 = () => {
    const listElement = listBoxElementRef.current;
    if (!listElement)
      return;
    const activeOption_1 = filteredOptions.find((o_2) => o_2.value === activeValue);
    if (activeOption_1) {
      const activeIndex_1 = filteredOptions.indexOf(activeOption_1), activeItemElement = listElement.childNodes[activeIndex_1];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement))
          return;
        focusFirstDescendant(activeItemElement);
      }
    }
  }, t34 = [activeValue, filteredOptions], $3[90] = activeValue, $3[91] = filteredOptions, $3[92] = t33, $3[93] = t34) : (t33 = $3[92], t34 = $3[93]), (0, import_react2.useEffect)(t33, t34);
  let t35;
  bb0: {
    if (!loading && !disabled && value) {
      let t362;
      $3[94] === Symbol.for("react.memo_cache_sentinel") ? (t362 = {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      }, $3[94] = t362) : t362 = $3[94], t35 = t362;
      break bb0;
    }
    t35 = void 0;
  }
  const clearButton = t35, openButtonBoxPadding = padding.map(_temp$32), openButtonPadding = padding.map(_temp2$12), openButtonProps = typeof openButton == "object" ? openButton : EMPTY_RECORD;
  let t36;
  $3[95] !== dispatchOpen || $3[96] !== openButtonProps ? (t36 = (event_4) => {
    dispatchOpen(), openButtonProps.onClick && openButtonProps.onClick(event_4), _raf(() => inputElementRef.current?.focus());
  }, $3[95] = dispatchOpen, $3[96] = openButtonProps, $3[97] = t36) : t36 = $3[97];
  const handleOpenClick = t36;
  let t37;
  $3[98] !== disabled || $3[99] !== expanded || $3[100] !== fontSize2 || $3[101] !== handleOpenClick || $3[102] !== openButton || $3[103] !== openButtonBoxPadding || $3[104] !== openButtonPadding || $3[105] !== openButtonProps || $3[106] !== readOnly ? (t37 = !disabled && !readOnly && openButton ? (0, import_jsx_runtime2.jsx)(Box, { "aria-hidden": expanded, padding: openButtonBoxPadding, children: (0, import_jsx_runtime2.jsx)(Button, { "aria-label": "Open", disabled: expanded, fontSize: fontSize2, icon: ChevronDownIcon, mode: "bleed", padding: openButtonPadding, ...openButtonProps, onClick: handleOpenClick }) }) : void 0, $3[98] = disabled, $3[99] = expanded, $3[100] = fontSize2, $3[101] = handleOpenClick, $3[102] = openButton, $3[103] = openButtonBoxPadding, $3[104] = openButtonPadding, $3[105] = openButtonProps, $3[106] = readOnly, $3[107] = t37) : t37 = $3[107];
  const openButtonNode = t37;
  let t38;
  bb1: {
    if (query === null) {
      if (value !== null) {
        let t392;
        $3[108] !== currentOption || $3[109] !== renderValue || $3[110] !== value ? (t392 = renderValue(value, currentOption), $3[108] = currentOption, $3[109] = renderValue, $3[110] = value, $3[111] = t392) : t392 = $3[111], t38 = t392;
        break bb1;
      }
      t38 = "";
      break bb1;
    }
    t38 = query;
  }
  const inputValue = t38;
  let t39;
  $3[112] !== listFocused ? (t39 = (event_5) => {
    event_5.key === "Tab" && listFocused && inputElementRef.current?.focus();
  }, $3[112] = listFocused, $3[113] = t39) : t39 = $3[113];
  const handleListBoxKeyDown = t39;
  let t40;
  bb2: {
    if (filteredOptions.length === 0) {
      t40 = null;
      break bb2;
    }
    let t412;
    if ($3[114] !== activeValue || $3[115] !== currentOption || $3[116] !== filteredOptions || $3[117] !== handleOptionSelect || $3[118] !== id || $3[119] !== listFocused || $3[120] !== loading || $3[121] !== renderOption) {
      let t423;
      $3[123] !== activeValue || $3[124] !== currentOption || $3[125] !== handleOptionSelect || $3[126] !== id || $3[127] !== listFocused || $3[128] !== loading || $3[129] !== renderOption ? (t423 = (option_0) => {
        const active = activeValue !== null ? option_0.value === activeValue : currentOption === option_0;
        return (0, import_jsx_runtime2.jsx)(AutocompleteOption, { id: `${id}-option-${option_0.value}`, onSelect: handleOptionSelect, selected: active, value: option_0.value, children: (0, import_react2.cloneElement)(renderOption(option_0), {
          disabled: loading,
          selected: active,
          tabIndex: listFocused && active ? 0 : -1
        }) }, option_0.value);
      }, $3[123] = activeValue, $3[124] = currentOption, $3[125] = handleOptionSelect, $3[126] = id, $3[127] = listFocused, $3[128] = loading, $3[129] = renderOption, $3[130] = t423) : t423 = $3[130], t412 = filteredOptions.map(t423), $3[114] = activeValue, $3[115] = currentOption, $3[116] = filteredOptions, $3[117] = handleOptionSelect, $3[118] = id, $3[119] = listFocused, $3[120] = loading, $3[121] = renderOption, $3[122] = t412;
    } else
      t412 = $3[122];
    let t422;
    $3[131] !== listBoxId || $3[132] !== t412 ? (t422 = (0, import_jsx_runtime2.jsx)(Stack, { as: "ul", "aria-multiselectable": false, "data-ui": "AutoComplete__resultsList", id: listBoxId, ref: listBoxElementRef, role: "listbox", space: 1, children: t412 }), $3[131] = listBoxId, $3[132] = t412, $3[133] = t422) : t422 = $3[133];
    let t432;
    $3[134] !== handleListBoxKeyDown || $3[135] !== listBox || $3[136] !== t422 ? (t432 = (0, import_jsx_runtime2.jsx)(ListBox, { "data-ui": "AutoComplete__results", onKeyDown: handleListBoxKeyDown, padding: 1, ...listBox, tabIndex: -1, children: t422 }), $3[134] = handleListBoxKeyDown, $3[135] = listBox, $3[136] = t422, $3[137] = t432) : t432 = $3[137], t40 = t432;
  }
  const content2 = t40;
  let t41;
  bb3: {
    if (renderPopover) {
      const t423 = !expanded;
      let t432;
      $3[138] !== content2 || $3[139] !== handlePopoverMouseEnter || $3[140] !== handlePopoverMouseLeave || $3[141] !== inputElement || $3[142] !== renderPopover || $3[143] !== t423 ? (t432 = (0, import_jsx_runtime2.jsx)(RenderPopover, { content: content2, hidden: t423, inputElement, onMouseEnter: handlePopoverMouseEnter, onMouseLeave: handlePopoverMouseLeave, resultsPopoverElementRef, renderPopover }), $3[138] = content2, $3[139] = handlePopoverMouseEnter, $3[140] = handlePopoverMouseLeave, $3[141] = inputElement, $3[142] = renderPopover, $3[143] = t423, $3[144] = t432) : t432 = $3[144], t41 = t432;
      break bb3;
    }
    if (filteredOptionsLen === 0) {
      t41 = null;
      break bb3;
    }
    let t422;
    $3[145] !== content2 || $3[146] !== expanded || $3[147] !== handlePopoverMouseEnter || $3[148] !== handlePopoverMouseLeave || $3[149] !== inputElement || $3[150] !== popover || $3[151] !== radius ? (t422 = (0, import_jsx_runtime2.jsx)(Popover, { arrow: false, constrainSize: true, content: content2, fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS, matchReferenceWidth: true, onMouseEnter: handlePopoverMouseEnter, onMouseLeave: handlePopoverMouseLeave, open: expanded, overflow: "auto", placement: AUTOCOMPLETE_POPOVER_PLACEMENT, portal: true, radius, ref: resultsPopoverElementRef, referenceElement: inputElement, ...popover }), $3[145] = content2, $3[146] = expanded, $3[147] = handlePopoverMouseEnter, $3[148] = handlePopoverMouseLeave, $3[149] = inputElement, $3[150] = popover, $3[151] = radius, $3[152] = t422) : t422 = $3[152], t41 = t422;
  }
  const results = t41, t42 = loading && AnimatedSpinnerIcon, t43 = suffix || openButtonNode;
  let t44;
  $3[153] !== activeItemId || $3[154] !== border2 || $3[155] !== clearButton || $3[156] !== customValidity || $3[157] !== disabled || $3[158] !== expanded || $3[159] !== fontSize2 || $3[160] !== handleClearButtonClick || $3[161] !== handleInputChange || $3[162] !== handleInputFocus || $3[163] !== icon || $3[164] !== id || $3[165] !== inputValue || $3[166] !== listBoxId || $3[167] !== padding || $3[168] !== prefix3 || $3[169] !== radius || $3[170] !== readOnly || $3[171] !== restProps || $3[172] !== t42 || $3[173] !== t43 ? (t44 = (0, import_jsx_runtime2.jsx)(TextInput, { ...restProps, "aria-activedescendant": activeItemId, "aria-autocomplete": "list", "aria-expanded": expanded, "aria-owns": listBoxId, autoCapitalize: "off", autoComplete: "off", autoCorrect: "off", border: border2, clearButton, customValidity, disabled, fontSize: fontSize2, icon, iconRight: t42, id, inputMode: "search", onChange: handleInputChange, onClear: handleClearButtonClick, onFocus: handleInputFocus, padding, prefix: prefix3, radius, readOnly, ref: setInputElement, role: "combobox", spellCheck: false, suffix: t43, value: inputValue }), $3[153] = activeItemId, $3[154] = border2, $3[155] = clearButton, $3[156] = customValidity, $3[157] = disabled, $3[158] = expanded, $3[159] = fontSize2, $3[160] = handleClearButtonClick, $3[161] = handleInputChange, $3[162] = handleInputFocus, $3[163] = icon, $3[164] = id, $3[165] = inputValue, $3[166] = listBoxId, $3[167] = padding, $3[168] = prefix3, $3[169] = radius, $3[170] = readOnly, $3[171] = restProps, $3[172] = t42, $3[173] = t43, $3[174] = t44) : t44 = $3[174];
  let t45;
  return $3[175] !== handleRootBlur || $3[176] !== handleRootFocus || $3[177] !== handleRootKeyDown || $3[178] !== results || $3[179] !== t44 ? (t45 = (0, import_jsx_runtime2.jsxs)(StyledAutocomplete, { "data-ui": "Autocomplete", onBlur: handleRootBlur, onFocus: handleRootFocus, onKeyDown: handleRootKeyDown, ref: rootElementRef, children: [
    t44,
    results
  ] }), $3[175] = handleRootBlur, $3[176] = handleRootFocus, $3[177] = handleRootKeyDown, $3[178] = results, $3[179] = t44, $3[180] = t45) : t45 = $3[180], t45;
});
function RenderPopover({
  renderPopover,
  content: content2,
  hidden,
  inputElement,
  onMouseEnter,
  onMouseLeave,
  resultsPopoverElementRef
}) {
  return renderPopover({
    content: content2,
    hidden,
    inputElement,
    onMouseEnter,
    onMouseLeave
  }, resultsPopoverElementRef);
}
InnerAutocomplete.displayName = "ForwardRef(Autocomplete)";
function _temp$32(v_0) {
  return v_0 === 0 ? 0 : v_0 === 1 || v_0 === 2 ? 1 : v_0 - 2;
}
function _temp2$12(v_1) {
  return Math.max(v_1 - 1, 0);
}
var StyledBreadcrumbs = dt.ol.withConfig({
  displayName: "StyledBreadcrumbs",
  componentId: "sc-1es8h8q-0"
})`margin:0;padding:0;display:flex;list-style:none;align-items:center;white-space:nowrap;line-height:0;`;
var ExpandButton = dt(Button).withConfig({
  displayName: "ExpandButton",
  componentId: "sc-1es8h8q-1"
})`appearance:none;margin:-4px;`;
var Breadcrumbs = (0, import_react2.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime2.c)(29);
  let children, maxLength, restProps, separator, t0;
  $3[0] !== props ? ({
    children,
    maxLength,
    separator,
    space: t0,
    ...restProps
  } = props, $3[0] = props, $3[1] = children, $3[2] = maxLength, $3[3] = restProps, $3[4] = separator, $3[5] = t0) : (children = $3[1], maxLength = $3[2], restProps = $3[3], separator = $3[4], t0 = $3[5]);
  const spaceRaw = t0 === void 0 ? 2 : t0;
  let t1;
  $3[6] !== spaceRaw ? (t1 = _getArrayProp(spaceRaw), $3[6] = spaceRaw, $3[7] = t1) : t1 = $3[7];
  const space = t1, [open, setOpen] = (0, import_react2.useState)(false), expandElementRef = (0, import_react2.useRef)(null), popoverElementRef = (0, import_react2.useRef)(null);
  let t22;
  $3[8] === Symbol.for("react.memo_cache_sentinel") ? (t22 = () => setOpen(false), $3[8] = t22) : t22 = $3[8];
  const collapse = t22;
  let t3;
  $3[9] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => setOpen(true), $3[9] = t3) : t3 = $3[9];
  const expand = t3;
  let t4;
  $3[10] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => [expandElementRef.current, popoverElementRef.current], $3[10] = t4) : t4 = $3[10], useClickOutsideEvent(collapse, t4);
  let t5;
  $3[11] !== children ? (t5 = import_react2.Children.toArray(children).filter(import_react2.isValidElement), $3[11] = children, $3[12] = t5) : t5 = $3[12];
  const rawItems = t5;
  let t6;
  $3[13] !== maxLength || $3[14] !== open || $3[15] !== rawItems || $3[16] !== space ? (t6 = {
    collapse,
    expand,
    expandElementRef,
    maxLength,
    open,
    popoverElementRef,
    rawItems,
    space
  }, $3[13] = maxLength, $3[14] = open, $3[15] = rawItems, $3[16] = space, $3[17] = t6) : t6 = $3[17];
  const items = useItems(t6);
  let t7;
  if ($3[18] !== items || $3[19] !== separator || $3[20] !== space) {
    let t82;
    $3[22] !== separator || $3[23] !== space ? (t82 = (item, itemIndex) => (0, import_jsx_runtime2.jsxs)(import_react2.Fragment, { children: [
      itemIndex > 0 && (0, import_jsx_runtime2.jsx)(Box, { "aria-hidden": true, as: "li", paddingX: space, children: separator || (0, import_jsx_runtime2.jsx)(Text, { muted: true, children: "/" }) }),
      (0, import_jsx_runtime2.jsx)(Box, { as: "li", children: item })
    ] }, itemIndex), $3[22] = separator, $3[23] = space, $3[24] = t82) : t82 = $3[24], t7 = items.map(t82), $3[18] = items, $3[19] = separator, $3[20] = space, $3[21] = t7;
  } else
    t7 = $3[21];
  let t8;
  return $3[25] !== ref || $3[26] !== restProps || $3[27] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(StyledBreadcrumbs, { "data-ui": "Breadcrumbs", ...restProps, ref, children: t7 }), $3[25] = ref, $3[26] = restProps, $3[27] = t7, $3[28] = t8) : t8 = $3[28], t8;
});
Breadcrumbs.displayName = "ForwardRef(Breadcrumbs)";
function useItems(t0) {
  const $3 = (0, import_react_compiler_runtime2.c)(28), {
    collapse,
    expand,
    expandElementRef,
    maxLength,
    open,
    popoverElementRef,
    rawItems,
    space
  } = t0, len = rawItems.length;
  if (maxLength && len > maxLength) {
    const beforeLength = Math.ceil(maxLength / 2), afterLength = Math.floor(maxLength / 2);
    let t1;
    if ($3[0] !== afterLength || $3[1] !== beforeLength || $3[2] !== collapse || $3[3] !== expand || $3[4] !== expandElementRef || $3[5] !== len || $3[6] !== open || $3[7] !== popoverElementRef || $3[8] !== rawItems || $3[9] !== space) {
      const t22 = rawItems.slice(0, beforeLength - 1);
      let t3;
      $3[11] !== afterLength || $3[12] !== beforeLength || $3[13] !== len || $3[14] !== rawItems ? (t3 = rawItems.slice(beforeLength - 1, len - afterLength), $3[11] = afterLength, $3[12] = beforeLength, $3[13] = len, $3[14] = rawItems, $3[15] = t3) : t3 = $3[15];
      let t4;
      $3[16] !== space || $3[17] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(Stack, { as: "ol", overflow: "auto", padding: space, space, children: t3 }), $3[16] = space, $3[17] = t3, $3[18] = t4) : t4 = $3[18];
      const t5 = open ? collapse : expand;
      let t6;
      $3[19] !== expandElementRef || $3[20] !== open || $3[21] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(ExpandButton, { fontSize: 1, mode: "bleed", onClick: t5, padding: 1, ref: expandElementRef, selected: open, text: "…" }), $3[19] = expandElementRef, $3[20] = open, $3[21] = t5, $3[22] = t6) : t6 = $3[22];
      let t7;
      $3[23] !== open || $3[24] !== popoverElementRef || $3[25] !== t4 || $3[26] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(Popover, { constrainSize: true, content: t4, open, placement: "top", portal: true, ref: popoverElementRef, children: t6 }, "button"), $3[23] = open, $3[24] = popoverElementRef, $3[25] = t4, $3[26] = t6, $3[27] = t7) : t7 = $3[27], t1 = [...t22, t7, ...rawItems.slice(len - afterLength)], $3[0] = afterLength, $3[1] = beforeLength, $3[2] = collapse, $3[3] = expand, $3[4] = expandElementRef, $3[5] = len, $3[6] = open, $3[7] = popoverElementRef, $3[8] = rawItems, $3[9] = space, $3[10] = t1;
    } else
      t1 = $3[10];
    return t1;
  }
  return rawItems;
}
function dialogStyle({
  theme
}) {
  const {
    color: color2
  } = getTheme_v2(theme);
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color2.backdrop
  };
}
function responsiveDialogPositionStyle(props) {
  const {
    media: media2
  } = getTheme_v2(props.theme);
  return _responsive(media2, props.$position, (position2) => ({
    "&&": {
      position: position2
    }
  }));
}
function animationDialogStyle(props) {
  return props.$animate ? lt`
    @keyframes zoomIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    animation: fadeIn 200ms ease-out;
    // Animates the dialog card.
    & > [data-ui='DialogCard'] {
      animation: zoomIn 200ms ease-out;
    }
  ` : lt``;
}
var DialogContext = createGlobalScopedContext("@sanity/ui/context/dialog", {
  version: 0
});
function useDialog() {
  return (0, import_react2.useContext)(DialogContext);
}
function isTargetWithinScope(boundaryElement, portalElement, target) {
  return !boundaryElement || !portalElement ? true : containsOrEqualsElement(boundaryElement, target) || containsOrEqualsElement(portalElement, target);
}
var StyledDialog = dt(Layer).withConfig({
  displayName: "StyledDialog",
  componentId: "sc-4n4xb3-0"
})(responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle, animationDialogStyle);
var DialogContainer = dt(Container).withConfig({
  displayName: "DialogContainer",
  componentId: "sc-4n4xb3-1"
})`&:not([hidden]){display:flex;}width:100%;height:100%;flex-direction:column;align-items:center;justify-content:center;`;
var DialogCardRoot = dt(Card).withConfig({
  displayName: "DialogCardRoot",
  componentId: "sc-4n4xb3-2"
})`&:not([hidden]){display:flex;}width:100%;min-height:0;max-height:100%;overflow:hidden;overflow:clip;`;
var DialogLayout = dt(Flex).withConfig({
  displayName: "DialogLayout",
  componentId: "sc-4n4xb3-3"
})`flex:1;min-height:0;width:100%;`;
var DialogHeader = dt(Box).withConfig({
  displayName: "DialogHeader",
  componentId: "sc-4n4xb3-4"
})`position:relative;z-index:2;`;
var DialogContent = dt(Box).withConfig({
  displayName: "DialogContent",
  componentId: "sc-4n4xb3-5"
})`position:relative;z-index:1;overflow:auto;outline:none;`;
var DialogFooter = dt(Box).withConfig({
  displayName: "DialogFooter",
  componentId: "sc-4n4xb3-6"
})`position:relative;z-index:3;`;
var DialogCard = (0, import_react2.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime2.c)(44), {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef: forwardedContentRef,
    footer,
    header,
    id,
    onClickOutside,
    onClose,
    portal: portalProp,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props, portal = usePortal(), portalElement = portalProp ? portal.elements?.[portalProp] || null : portal.element, boundaryElement = useBoundaryElement().element;
  let t0;
  $3[0] !== radiusProp ? (t0 = _getArrayProp(radiusProp), $3[0] = radiusProp, $3[1] = t0) : t0 = $3[1];
  const radius = t0;
  let t1;
  $3[2] !== shadowProp ? (t1 = _getArrayProp(shadowProp), $3[2] = shadowProp, $3[3] = t1) : t1 = $3[3];
  const shadow = t1;
  let t22;
  $3[4] !== widthProp ? (t22 = _getArrayProp(widthProp), $3[4] = widthProp, $3[5] = t22) : t22 = $3[5];
  const width = t22, ref = (0, import_react2.useRef)(null), contentRef = (0, import_react2.useRef)(null), layer = useLayer(), {
    isTopLayer
  } = layer, labelId = `${id}_label`, showCloseButton = !!onClose && hideCloseButton === false, showHeader = !!header || showCloseButton;
  let t3;
  $3[6] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => ref.current, $3[6] = t3) : t3 = $3[6], (0, import_react2.useImperativeHandle)(forwardedRef, t3);
  let t4;
  $3[7] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => contentRef.current, $3[7] = t4) : t4 = $3[7], (0, import_react2.useImperativeHandle)(forwardedContentRef, t4);
  let t5, t6;
  $3[8] !== autoFocus ? (t5 = () => {
    autoFocus && ref.current && focusFirstDescendant(ref.current);
  }, t6 = [autoFocus, ref], $3[8] = autoFocus, $3[9] = t5, $3[10] = t6) : (t5 = $3[9], t6 = $3[10]), (0, import_react2.useEffect)(t5, t6);
  let t7;
  $3[11] !== boundaryElement || $3[12] !== isTopLayer || $3[13] !== onClose || $3[14] !== portalElement ? (t7 = (event) => {
    if (!isTopLayer || !onClose)
      return;
    const target = document.activeElement;
    target && !isTargetWithinScope(boundaryElement, portalElement, target) || event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), onClose());
  }, $3[11] = boundaryElement, $3[12] = isTopLayer, $3[13] = onClose, $3[14] = portalElement, $3[15] = t7) : t7 = $3[15], useGlobalKeyDown(t7);
  let t8;
  $3[16] !== boundaryElement || $3[17] !== isTopLayer || $3[18] !== onClickOutside || $3[19] !== portalElement ? (t8 = isTopLayer && onClickOutside && ((event_0) => {
    const target_0 = event_0.target;
    target_0 && !isTargetWithinScope(boundaryElement, portalElement, target_0) || onClickOutside();
  }), $3[16] = boundaryElement, $3[17] = isTopLayer, $3[18] = onClickOutside, $3[19] = portalElement, $3[20] = t8) : t8 = $3[20];
  let t9;
  $3[21] === Symbol.for("react.memo_cache_sentinel") ? (t9 = () => [ref.current], $3[21] = t9) : t9 = $3[21], useClickOutsideEvent(t8, t9);
  let t10;
  $3[22] !== header || $3[23] !== labelId || $3[24] !== onClose || $3[25] !== showCloseButton || $3[26] !== showHeader ? (t10 = showHeader && (0, import_jsx_runtime2.jsx)(DialogHeader, { children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-start", padding: 3, children: [
    (0, import_jsx_runtime2.jsx)(Box, { flex: 1, padding: 2, children: header && (0, import_jsx_runtime2.jsx)(Text, { id: labelId, size: 1, weight: "semibold", children: header }) }),
    showCloseButton && (0, import_jsx_runtime2.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime2.jsx)(Button, { "aria-label": "Close dialog", disabled: !onClose, icon: CloseIcon, mode: "bleed", onClick: onClose, padding: 2 }) })
  ] }) }), $3[22] = header, $3[23] = labelId, $3[24] = onClose, $3[25] = showCloseButton, $3[26] = showHeader, $3[27] = t10) : t10 = $3[27];
  let t11;
  $3[28] !== children ? (t11 = (0, import_jsx_runtime2.jsx)(DialogContent, { flex: 1, ref: contentRef, tabIndex: -1, children }), $3[28] = children, $3[29] = t11) : t11 = $3[29];
  let t12;
  $3[30] !== footer ? (t12 = footer && (0, import_jsx_runtime2.jsx)(DialogFooter, { children: footer }), $3[30] = footer, $3[31] = t12) : t12 = $3[31];
  let t13;
  $3[32] !== t10 || $3[33] !== t11 || $3[34] !== t12 ? (t13 = (0, import_jsx_runtime2.jsxs)(DialogLayout, { direction: "column", children: [
    t10,
    t11,
    t12
  ] }), $3[32] = t10, $3[33] = t11, $3[34] = t12, $3[35] = t13) : t13 = $3[35];
  let t14;
  $3[36] !== radius || $3[37] !== scheme || $3[38] !== shadow || $3[39] !== t13 ? (t14 = (0, import_jsx_runtime2.jsx)(DialogCardRoot, { radius, ref, scheme, shadow, children: t13 }), $3[36] = radius, $3[37] = scheme, $3[38] = shadow, $3[39] = t13, $3[40] = t14) : t14 = $3[40];
  let t15;
  return $3[41] !== t14 || $3[42] !== width ? (t15 = (0, import_jsx_runtime2.jsx)(DialogContainer, { "data-ui": "DialogCard", width, children: t14 }), $3[41] = t14, $3[42] = width, $3[43] = t15) : t15 = $3[43], t15;
});
DialogCard.displayName = "ForwardRef(DialogCard)";
var Dialog = (0, import_react2.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime2.c)(70), dialog = useDialog(), {
    layer
  } = useTheme_v2();
  let _positionProp, _zOffsetProp, children, contentRef, footer, header, id, onActivate, onClickOutside, onClose, onFocus2, portalProp, restProps, scheme, t0, t1, t22, t3, t4, t5, t6;
  $3[0] !== props ? ({
    __unstable_autoFocus: t0,
    __unstable_hideCloseButton: t1,
    cardRadius: t22,
    cardShadow: t3,
    children,
    contentRef,
    footer,
    header,
    id,
    onActivate,
    onClickOutside,
    onClose,
    onFocus: onFocus2,
    padding: t4,
    portal: portalProp,
    position: _positionProp,
    scheme,
    width: t5,
    zOffset: _zOffsetProp,
    animate: t6,
    ...restProps
  } = props, $3[0] = props, $3[1] = _positionProp, $3[2] = _zOffsetProp, $3[3] = children, $3[4] = contentRef, $3[5] = footer, $3[6] = header, $3[7] = id, $3[8] = onActivate, $3[9] = onClickOutside, $3[10] = onClose, $3[11] = onFocus2, $3[12] = portalProp, $3[13] = restProps, $3[14] = scheme, $3[15] = t0, $3[16] = t1, $3[17] = t22, $3[18] = t3, $3[19] = t4, $3[20] = t5, $3[21] = t6) : (_positionProp = $3[1], _zOffsetProp = $3[2], children = $3[3], contentRef = $3[4], footer = $3[5], header = $3[6], id = $3[7], onActivate = $3[8], onClickOutside = $3[9], onClose = $3[10], onFocus2 = $3[11], portalProp = $3[12], restProps = $3[13], scheme = $3[14], t0 = $3[15], t1 = $3[16], t22 = $3[17], t3 = $3[18], t4 = $3[19], t5 = $3[20], t6 = $3[21]);
  const autoFocus = t0 === void 0 ? true : t0, hideCloseButton = t1 === void 0 ? false : t1, cardRadiusProp = t22 === void 0 ? 4 : t22, cardShadow = t3 === void 0 ? 3 : t3, paddingProp = t4 === void 0 ? 3 : t4, widthProp = t5 === void 0 ? 0 : t5, _animate = t6 === void 0 ? false : t6, positionProp = _positionProp ?? (dialog.position || "fixed"), zOffsetProp = _zOffsetProp ?? (dialog.zOffset || layer.dialog.zOffset), animate = usePrefersReducedMotion() ? false : _animate, portal = usePortal(), portalElement = portalProp ? portal.elements?.[portalProp] || null : portal.element, boundaryElement = useBoundaryElement().element;
  let t7;
  $3[22] !== cardRadiusProp ? (t7 = _getArrayProp(cardRadiusProp), $3[22] = cardRadiusProp, $3[23] = t7) : t7 = $3[23];
  const cardRadius = t7;
  let t8;
  $3[24] !== paddingProp ? (t8 = _getArrayProp(paddingProp), $3[24] = paddingProp, $3[25] = t8) : t8 = $3[25];
  const padding = t8;
  let t9;
  $3[26] !== positionProp ? (t9 = _getArrayProp(positionProp), $3[26] = positionProp, $3[27] = t9) : t9 = $3[27];
  const position2 = t9;
  let t10;
  $3[28] !== widthProp ? (t10 = _getArrayProp(widthProp), $3[28] = widthProp, $3[29] = t10) : t10 = $3[29];
  const width = t10;
  let t11;
  $3[30] !== zOffsetProp ? (t11 = _getArrayProp(zOffsetProp), $3[30] = zOffsetProp, $3[31] = t11) : t11 = $3[31];
  const zOffset = t11, preDivRef = (0, import_react2.useRef)(null), postDivRef = (0, import_react2.useRef)(null), cardRef = (0, import_react2.useRef)(null), focusedElementRef = (0, import_react2.useRef)(null);
  let t12;
  $3[32] !== onFocus2 ? (t12 = (event) => {
    onFocus2?.(event);
    const target = event.target, cardElement = cardRef.current;
    if (cardElement && target === preDivRef.current) {
      focusLastDescendant(cardElement);
      return;
    }
    if (cardElement && target === postDivRef.current) {
      focusFirstDescendant(cardElement);
      return;
    }
    isHTMLElement(event.target) && (focusedElementRef.current = event.target);
  }, $3[32] = onFocus2, $3[33] = t12) : t12 = $3[33];
  const handleFocus = t12, labelId = `${id}_label`, rootClickTimeoutRef = (0, import_react2.useRef)(void 0);
  let t13;
  $3[34] !== boundaryElement || $3[35] !== portalElement ? (t13 = () => {
    rootClickTimeoutRef.current && clearTimeout(rootClickTimeoutRef.current), rootClickTimeoutRef.current = setTimeout(() => {
      const activeElement = document.activeElement;
      if (activeElement && !isTargetWithinScope(boundaryElement, portalElement, activeElement)) {
        const target_0 = focusedElementRef.current;
        if (!target_0 || !document.body.contains(target_0)) {
          const cardElement_0 = cardRef.current;
          cardElement_0 && focusFirstDescendant(cardElement_0);
          return;
        }
        target_0.focus();
      }
    }, 0);
  }, $3[34] = boundaryElement, $3[35] = portalElement, $3[36] = t13) : t13 = $3[36];
  const handleRootClick = t13;
  let t14;
  $3[37] === Symbol.for("react.memo_cache_sentinel") ? (t14 = (0, import_jsx_runtime2.jsx)("div", { ref: preDivRef, tabIndex: 0 }), $3[37] = t14) : t14 = $3[37];
  let t15;
  $3[38] !== autoFocus || $3[39] !== cardRadius || $3[40] !== cardShadow || $3[41] !== children || $3[42] !== contentRef || $3[43] !== footer || $3[44] !== header || $3[45] !== hideCloseButton || $3[46] !== id || $3[47] !== onClickOutside || $3[48] !== onClose || $3[49] !== portalProp || $3[50] !== scheme || $3[51] !== width ? (t15 = (0, import_jsx_runtime2.jsx)(DialogCard, { __unstable_autoFocus: autoFocus, __unstable_hideCloseButton: hideCloseButton, contentRef, footer, header, id, onClickOutside, onClose, portal: portalProp, radius: cardRadius, ref: cardRef, scheme, shadow: cardShadow, width, children }), $3[38] = autoFocus, $3[39] = cardRadius, $3[40] = cardShadow, $3[41] = children, $3[42] = contentRef, $3[43] = footer, $3[44] = header, $3[45] = hideCloseButton, $3[46] = id, $3[47] = onClickOutside, $3[48] = onClose, $3[49] = portalProp, $3[50] = scheme, $3[51] = width, $3[52] = t15) : t15 = $3[52];
  let t16;
  $3[53] === Symbol.for("react.memo_cache_sentinel") ? (t16 = (0, import_jsx_runtime2.jsx)("div", { ref: postDivRef, tabIndex: 0 }), $3[53] = t16) : t16 = $3[53];
  let t17;
  $3[54] !== animate || $3[55] !== handleFocus || $3[56] !== handleRootClick || $3[57] !== id || $3[58] !== labelId || $3[59] !== onActivate || $3[60] !== padding || $3[61] !== position2 || $3[62] !== ref || $3[63] !== restProps || $3[64] !== t15 || $3[65] !== zOffset ? (t17 = (0, import_jsx_runtime2.jsxs)(StyledDialog, { ...restProps, $animate: animate, $padding: padding, $position: position2, "aria-labelledby": labelId, "aria-modal": true, "data-ui": "Dialog", id, onActivate, onClick: handleRootClick, onFocus: handleFocus, ref, role: "dialog", zOffset, children: [
    t14,
    t15,
    t16
  ] }), $3[54] = animate, $3[55] = handleFocus, $3[56] = handleRootClick, $3[57] = id, $3[58] = labelId, $3[59] = onActivate, $3[60] = padding, $3[61] = position2, $3[62] = ref, $3[63] = restProps, $3[64] = t15, $3[65] = zOffset, $3[66] = t17) : t17 = $3[66];
  let t18;
  return $3[67] !== portalProp || $3[68] !== t17 ? (t18 = (0, import_jsx_runtime2.jsx)(Portal, { __unstable_name: portalProp, children: t17 }), $3[67] = portalProp, $3[68] = t17, $3[69] = t18) : t18 = $3[69], t18;
});
Dialog.displayName = "ForwardRef(Dialog)";
function DialogProvider(props) {
  const $3 = (0, import_react_compiler_runtime2.c)(6), {
    children,
    position: position2,
    zOffset
  } = props;
  let t0;
  $3[0] !== position2 || $3[1] !== zOffset ? (t0 = {
    version: 0,
    position: position2,
    zOffset
  }, $3[0] = position2, $3[1] = zOffset, $3[2] = t0) : t0 = $3[2];
  const contextValue = t0;
  let t1;
  return $3[3] !== children || $3[4] !== contextValue ? (t1 = (0, import_jsx_runtime2.jsx)(DialogContext.Provider, { value: contextValue, children }), $3[3] = children, $3[4] = contextValue, $3[5] = t1) : t1 = $3[5], t1;
}
DialogProvider.displayName = "DialogProvider";
var MenuButton = (0, import_react2.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime2.c)(62), {
    __unstable_disableRestoreFocusOnClose: t0,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id,
    menu: menuProp,
    onClose,
    onOpen,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: t1,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props, disableRestoreFocusOnClose = t0 === void 0 ? false : t0, deprecated_portal = t1 === void 0 ? true : t1, [open, setOpen] = (0, import_react2.useState)(false), [shouldFocus, setShouldFocus] = (0, import_react2.useState)(null), [buttonElement, setButtonElement] = (0, import_react2.useState)(null);
  let t22;
  $3[0] === Symbol.for("react.memo_cache_sentinel") ? (t22 = [], $3[0] = t22) : t22 = $3[0];
  const [menuElements, setChildMenuElements] = (0, import_react2.useState)(t22), openRef = (0, import_react2.useRef)(open);
  let t3, t4;
  $3[1] !== onOpen || $3[2] !== open ? (t3 = () => {
    onOpen && open && !openRef.current && onOpen();
  }, t4 = [onOpen, open], $3[1] = onOpen, $3[2] = open, $3[3] = t3, $3[4] = t4) : (t3 = $3[3], t4 = $3[4]), (0, import_react2.useEffect)(t3, t4);
  let t5, t6;
  $3[5] !== onClose || $3[6] !== open ? (t5 = () => {
    onClose && !open && openRef.current && onClose();
  }, t6 = [onClose, open], $3[5] = onClose, $3[6] = open, $3[7] = t5, $3[8] = t6) : (t5 = $3[7], t6 = $3[8]), (0, import_react2.useEffect)(t5, t6);
  let t7, t8;
  $3[9] !== open ? (t7 = () => {
    openRef.current = open;
  }, t8 = [open], $3[9] = open, $3[10] = t7, $3[11] = t8) : (t7 = $3[10], t8 = $3[11]), (0, import_react2.useEffect)(t7, t8);
  let t9;
  $3[12] === Symbol.for("react.memo_cache_sentinel") ? (t9 = () => {
    setOpen(_temp$22), setShouldFocus(null);
  }, $3[12] = t9) : t9 = $3[12];
  const handleButtonClick = t9;
  let t10;
  $3[13] !== open ? (t10 = (event) => {
    open && event.preventDefault();
  }, $3[13] = open, $3[14] = t10) : t10 = $3[14];
  const handleMouseDown = t10;
  let t11;
  $3[15] === Symbol.for("react.memo_cache_sentinel") ? (t11 = (event_0) => {
    if (event_0.key === "ArrowDown" || event_0.key === "Enter" || event_0.key === " ") {
      event_0.preventDefault(), setOpen(true), setShouldFocus("first");
      return;
    }
    if (event_0.key === "ArrowUp") {
      event_0.preventDefault(), setOpen(true), setShouldFocus("last");
      return;
    }
  }, $3[15] = t11) : t11 = $3[15];
  const handleButtonKeyDown = t11;
  let t12;
  $3[16] !== buttonElement || $3[17] !== menuElements ? (t12 = (event_1) => {
    const target = event_1.target;
    if (target instanceof Node && !(buttonElement && (target === buttonElement || buttonElement.contains(target)))) {
      for (const el of menuElements)
        if (target === el || el.contains(target))
          return;
      setOpen(false);
    }
  }, $3[16] = buttonElement, $3[17] = menuElements, $3[18] = t12) : t12 = $3[18];
  const handleMenuClickOutside = t12;
  let t13;
  $3[19] !== buttonElement || $3[20] !== disableRestoreFocusOnClose ? (t13 = () => {
    setOpen(false), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, $3[19] = buttonElement, $3[20] = disableRestoreFocusOnClose, $3[21] = t13) : t13 = $3[21];
  const handleMenuEscape = t13;
  let t14;
  $3[22] !== menuElements ? (t14 = (event_2) => {
    const target_0 = event_2.relatedTarget;
    if (target_0 instanceof Node) {
      for (const el_0 of menuElements)
        if (el_0 === target_0 || el_0.contains(target_0))
          return;
      setOpen(false);
    }
  }, $3[22] = menuElements, $3[23] = t14) : t14 = $3[23];
  const handleBlur = t14;
  let t15;
  $3[24] !== buttonElement || $3[25] !== disableRestoreFocusOnClose ? (t15 = () => {
    setOpen(false), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, $3[24] = buttonElement, $3[25] = disableRestoreFocusOnClose, $3[26] = t15) : t15 = $3[26];
  const handleItemClick = t15;
  let t16;
  $3[27] === Symbol.for("react.memo_cache_sentinel") ? (t16 = (el_1) => (setChildMenuElements((els) => els.concat([el_1])), () => setChildMenuElements((els_0) => els_0.filter((_el) => _el !== el_1))), $3[27] = t16) : t16 = $3[27];
  const registerElement = t16;
  let t17;
  $3[28] !== buttonElement || $3[29] !== handleBlur || $3[30] !== handleItemClick || $3[31] !== handleMenuClickOutside || $3[32] !== handleMenuEscape || $3[33] !== id || $3[34] !== menuProp || $3[35] !== shouldFocus ? (t17 = menuProp && (0, import_react2.cloneElement)(menuProp, {
    "aria-labelledby": id,
    onBlurCapture: handleBlur,
    onClickOutside: handleMenuClickOutside,
    onEscape: handleMenuEscape,
    onItemClick: handleItemClick,
    originElement: buttonElement,
    registerElement,
    shouldFocus
  }), $3[28] = buttonElement, $3[29] = handleBlur, $3[30] = handleItemClick, $3[31] = handleMenuClickOutside, $3[32] = handleMenuEscape, $3[33] = id, $3[34] = menuProp, $3[35] = shouldFocus, $3[36] = t17) : t17 = $3[36];
  const menu = t17;
  let t18;
  $3[37] !== buttonProp || $3[38] !== handleMouseDown || $3[39] !== id || $3[40] !== open ? (t18 = buttonProp && (0, import_react2.cloneElement)(buttonProp, {
    "data-ui": "MenuButton",
    id,
    onClick: handleButtonClick,
    onKeyDown: handleButtonKeyDown,
    onMouseDown: handleMouseDown,
    "aria-haspopup": true,
    "aria-expanded": open,
    ref: setButtonElement,
    selected: buttonProp.props.selected ?? open
  }), $3[37] = buttonProp, $3[38] = handleMouseDown, $3[39] = id, $3[40] = open, $3[41] = t18) : t18 = $3[41];
  const button = t18;
  let t19, t20;
  $3[42] !== buttonElement ? (t19 = () => buttonElement, t20 = [buttonElement], $3[42] = buttonElement, $3[43] = t19, $3[44] = t20) : (t19 = $3[43], t20 = $3[44]), (0, import_react2.useImperativeHandle)(forwardedRef, t19, t20);
  let t21;
  $3[45] !== popover ? (t21 = popover || {}, $3[45] = popover, $3[46] = t21) : t21 = $3[46];
  let t222;
  $3[47] !== deprecated_boundaryElement || $3[48] !== deprecated_placement || $3[49] !== deprecated_popoverRadius || $3[50] !== deprecated_popoverScheme || $3[51] !== deprecated_portal || $3[52] !== deprecated_preventOverflow || $3[53] !== t21 ? (t222 = {
    boundaryElement: deprecated_boundaryElement,
    overflow: "auto",
    placement: deprecated_placement,
    portal: deprecated_portal,
    preventOverflow: deprecated_preventOverflow,
    radius: deprecated_popoverRadius,
    scheme: deprecated_popoverScheme,
    ...t21
  }, $3[47] = deprecated_boundaryElement, $3[48] = deprecated_placement, $3[49] = deprecated_popoverRadius, $3[50] = deprecated_popoverScheme, $3[51] = deprecated_portal, $3[52] = deprecated_preventOverflow, $3[53] = t21, $3[54] = t222) : t222 = $3[54];
  const popoverProps = t222;
  let t23;
  $3[55] !== button ? (t23 = button || (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {}), $3[55] = button, $3[56] = t23) : t23 = $3[56];
  let t24;
  return $3[57] !== menu || $3[58] !== open || $3[59] !== popoverProps || $3[60] !== t23 ? (t24 = (0, import_jsx_runtime2.jsx)(Popover, { "data-ui": "MenuButton__popover", ...popoverProps, content: menu, open, children: t23 }), $3[57] = menu, $3[58] = open, $3[59] = popoverProps, $3[60] = t23, $3[61] = t24) : t24 = $3[61], t24;
});
MenuButton.displayName = "ForwardRef(MenuButton)";
function _temp$22(v2) {
  return !v2;
}
var keyframe = mt`
  0% {
    background-position: 100%;
  }
  100% {
    background-position: -100%;
  }
`;
var animation = lt`
  background-image: linear-gradient(
    to right,
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-to),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from)
  );
  background-position: 100%;
  background-size: 200% 100%;
  background-attachment: fixed;
  animation-name: ${keyframe};
  animation-timing-function: ease-in-out;
  animation-iteration-count: infinite;
  animation-duration: 2000ms;
`;
var skeletonStyle = lt`
  opacity: ${({
  $visible
}) => $visible ? 1 : 0};
  transition: opacity 200ms ease-in;

  @media screen and (prefers-reduced-motion: no-preference) {
    ${({
  $animated
}) => $animated ? animation : lt`
            background-color: var(--card-skeleton-color-from);
          `}
  }

  @media screen and (prefers-reduced-motion: reduce) {
    background-color: var(--card-skeleton-color-from);
  }
`;
var StyledSkeleton$1 = dt(Box).withConfig({
  displayName: "StyledSkeleton",
  componentId: "sc-ebtpni-0"
})(responsiveRadiusStyle, skeletonStyle);
var Skeleton = (0, import_react2.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime2.c)(16);
  let delay2, radius, restProps, t0;
  $3[0] !== props ? ({
    animated: t0,
    delay: delay2,
    radius,
    ...restProps
  } = props, $3[0] = props, $3[1] = delay2, $3[2] = radius, $3[3] = restProps, $3[4] = t0) : (delay2 = $3[1], radius = $3[2], restProps = $3[3], t0 = $3[4]);
  const animated = t0 === void 0 ? false : t0, [visible, setVisible] = (0, import_react2.useState)(!delay2);
  let t1, t22;
  $3[5] !== delay2 ? (t1 = () => {
    if (!delay2)
      return;
    const timeout = setTimeout(() => {
      setVisible(true);
    }, delay2);
    return () => {
      clearTimeout(timeout);
    };
  }, t22 = [delay2], $3[5] = delay2, $3[6] = t1, $3[7] = t22) : (t1 = $3[6], t22 = $3[7]), (0, import_react2.useEffect)(t1, t22);
  let t3;
  $3[8] !== radius ? (t3 = _getArrayProp(radius), $3[8] = radius, $3[9] = t3) : t3 = $3[9];
  const t4 = delay2 ? visible : true;
  let t5;
  return $3[10] !== animated || $3[11] !== ref || $3[12] !== restProps || $3[13] !== t3 || $3[14] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(StyledSkeleton$1, { ...restProps, $animated: animated, $radius: t3, $visible: t4, ref }), $3[10] = animated, $3[11] = ref, $3[12] = restProps, $3[13] = t3, $3[14] = t4, $3[15] = t5) : t5 = $3[15], t5;
});
Skeleton.displayName = "ForwardRef(Skeleton)";
var StyledSkeleton = dt(Skeleton).withConfig({
  displayName: "StyledSkeleton",
  componentId: "sc-2p7a1v-0"
})((props) => {
  const {
    $size,
    $style
  } = props, {
    font,
    media: media2
  } = getTheme_v2(props.theme), fontStyle = font[$style];
  return _responsive(media2, $size, (sizeIndex) => {
    const fontSize2 = fontStyle.sizes[sizeIndex];
    return {
      height: fontSize2.lineHeight - fontSize2.ascenderHeight - fontSize2.descenderHeight
    };
  });
});
var TextSkeleton = (0, import_react2.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime2.c)(9);
  let restProps, t0;
  $3[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $3[0] = props, $3[1] = restProps, $3[2] = t0) : (restProps = $3[1], t0 = $3[2]);
  const size2 = t0 === void 0 ? 2 : t0;
  let t1;
  $3[3] !== size2 ? (t1 = _getArrayProp(size2), $3[3] = size2, $3[4] = t1) : t1 = $3[4];
  const $size = t1;
  let t22;
  return $3[5] !== $size || $3[6] !== ref || $3[7] !== restProps ? (t22 = (0, import_jsx_runtime2.jsx)(StyledSkeleton, { ...restProps, $size, ref, $style: "text" }), $3[5] = $size, $3[6] = ref, $3[7] = restProps, $3[8] = t22) : t22 = $3[8], t22;
});
TextSkeleton.displayName = "ForwardRef(TextSkeleton)";
var LabelSkeleton = (0, import_react2.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime2.c)(9);
  let restProps, t0;
  $3[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $3[0] = props, $3[1] = restProps, $3[2] = t0) : (restProps = $3[1], t0 = $3[2]);
  const size2 = t0 === void 0 ? 2 : t0;
  let t1;
  $3[3] !== size2 ? (t1 = _getArrayProp(size2), $3[3] = size2, $3[4] = t1) : t1 = $3[4];
  const $size = t1;
  let t22;
  return $3[5] !== $size || $3[6] !== ref || $3[7] !== restProps ? (t22 = (0, import_jsx_runtime2.jsx)(StyledSkeleton, { ...restProps, $size, ref, $style: "label" }), $3[5] = $size, $3[6] = ref, $3[7] = restProps, $3[8] = t22) : t22 = $3[8], t22;
});
LabelSkeleton.displayName = "ForwardRef(LabelSkeleton)";
var HeadingSkeleton = (0, import_react2.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime2.c)(9);
  let restProps, t0;
  $3[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $3[0] = props, $3[1] = restProps, $3[2] = t0) : (restProps = $3[1], t0 = $3[2]);
  const size2 = t0 === void 0 ? 2 : t0;
  let t1;
  $3[3] !== size2 ? (t1 = _getArrayProp(size2), $3[3] = size2, $3[4] = t1) : t1 = $3[4];
  const $size = t1;
  let t22;
  return $3[5] !== $size || $3[6] !== ref || $3[7] !== restProps ? (t22 = (0, import_jsx_runtime2.jsx)(StyledSkeleton, { ...restProps, $size, ref, $style: "heading" }), $3[5] = $size, $3[6] = ref, $3[7] = restProps, $3[8] = t22) : t22 = $3[8], t22;
});
HeadingSkeleton.displayName = "ForwardRef(HeadingSkeleton)";
var CodeSkeleton = (0, import_react2.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime2.c)(9);
  let restProps, t0;
  $3[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $3[0] = props, $3[1] = restProps, $3[2] = t0) : (restProps = $3[1], t0 = $3[2]);
  const size2 = t0 === void 0 ? 2 : t0;
  let t1;
  $3[3] !== size2 ? (t1 = _getArrayProp(size2), $3[3] = size2, $3[4] = t1) : t1 = $3[4];
  const $size = t1;
  let t22;
  return $3[5] !== $size || $3[6] !== ref || $3[7] !== restProps ? (t22 = (0, import_jsx_runtime2.jsx)(StyledSkeleton, { ...restProps, $size, ref, $style: "code" }), $3[5] = $size, $3[6] = ref, $3[7] = restProps, $3[8] = t22) : t22 = $3[8], t22;
});
CodeSkeleton.displayName = "ForwardRef(CodeSkeleton)";
var TabPanel = (0, import_react2.forwardRef)(function(props, ref) {
  const $3 = (0, import_react_compiler_runtime2.c)(9);
  let flex, restProps;
  $3[0] !== props ? ({
    flex,
    ...restProps
  } = props, $3[0] = props, $3[1] = flex, $3[2] = restProps) : (flex = $3[1], restProps = $3[2]);
  const t0 = props.tabIndex === void 0 ? 0 : props.tabIndex;
  let t1;
  return $3[3] !== flex || $3[4] !== props.children || $3[5] !== ref || $3[6] !== restProps || $3[7] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(Box, { "data-ui": "TabPanel", ...restProps, flex, ref, role: "tabpanel", tabIndex: t0, children: props.children }), $3[3] = flex, $3[4] = props.children, $3[5] = ref, $3[6] = restProps, $3[7] = t0, $3[8] = t1) : t1 = $3[8], t1;
});
TabPanel.displayName = "ForwardRef(TabPanel)";
var LOADING_BAR_HEIGHT = 2;
var STATUS_CARD_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "neutral"
};
var BUTTON_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "neutral"
};
var TextBox = dt(Flex).withConfig({
  displayName: "TextBox",
  componentId: "sc-1rr7rxo-0"
})`overflow-x:auto;`;
var StyledToast = dt(Card).withConfig({
  displayName: "StyledToast",
  componentId: "sc-1rr7rxo-1"
})`pointer-events:all;width:100%;position:relative;overflow:hidden;overflow:clip;&[data-has-duration]{padding-bottom:calc(${LOADING_BAR_HEIGHT}px / 2);}`;
var LoadingBar = dt.div.withConfig({
  displayName: "LoadingBar",
  componentId: "sc-1rr7rxo-2"
})`display:flex;position:absolute;bottom:0px;top:0px;left:0px;right:0px;pointer-events:none;z-index:-1;overflow:hidden;overflow:clip;background:transparent;align-items:flex-end;will-change:opacity;`;
var LoadingBarMask = dt(Card).withConfig({
  displayName: "LoadingBarMask",
  componentId: "sc-1rr7rxo-3"
})`position:absolute;top:0;left:-${LOADING_BAR_HEIGHT}px;right:-${LOADING_BAR_HEIGHT}px;bottom:${LOADING_BAR_HEIGHT}px;z-index:1;`;
var LoadingBarProgress = dt(Card).withConfig({
  displayName: "LoadingBarProgress",
  componentId: "sc-1rr7rxo-4"
})`display:block;height:100%;width:100%;transform-origin:0% 50%;background-color:${(props) => {
  const {
    color: color2
  } = getTheme_v2(props.theme);
  return color2.button.default[props.tone].enabled.bg;
}};`;
var ROLES = {
  error: "alert",
  warning: "alert",
  success: "alert",
  info: "alert"
};
var LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function Toast(props) {
  const $3 = (0, import_react_compiler_runtime2.c)(50);
  let closable, description, duration, onClose, restProps, status, t0, title, updatedAt;
  $3[0] !== props ? ({
    closable,
    description,
    duration,
    onClose,
    radius: t0,
    title,
    status,
    updatedAt,
    ...restProps
  } = props, $3[0] = props, $3[1] = closable, $3[2] = description, $3[3] = duration, $3[4] = onClose, $3[5] = restProps, $3[6] = status, $3[7] = t0, $3[8] = title, $3[9] = updatedAt) : (closable = $3[1], description = $3[2], duration = $3[3], onClose = $3[4], restProps = $3[5], status = $3[6], t0 = $3[7], title = $3[8], updatedAt = $3[9]);
  const radius = t0 === void 0 ? 3 : t0, cardTone = status ? STATUS_CARD_TONE[status] : "default", buttonTone = status ? BUTTON_TONE[status] : "default", role = status ? ROLES[status] : "status", visualDuration = usePrefersReducedMotion() ? 0 : 0.26;
  let t1;
  $3[10] !== visualDuration ? (t1 = visualDuration ? {
    type: "spring",
    visualDuration,
    bounce: 0.25
  } : {
    duration: 0
  }, $3[10] = visualDuration, $3[11] = t1) : t1 = $3[11];
  const transition = t1, hasDuration = duration && isFinite(duration) && duration < LONG_ENOUGH_BUT_NOT_TOO_LONG;
  let t22;
  $3[12] === Symbol.for("react.memo_cache_sentinel") ? (t22 = ["hidden", "initial"], $3[12] = t22) : t22 = $3[12];
  const initial = t22;
  let t3;
  $3[13] === Symbol.for("react.memo_cache_sentinel") ? (t3 = ["visible", "slideIn"], $3[13] = t3) : t3 = $3[13];
  const animate = t3;
  let t4;
  $3[14] === Symbol.for("react.memo_cache_sentinel") ? (t4 = ["hidden", "slideOut"], $3[14] = t4) : t4 = $3[14];
  const exit = t4, t5 = hasDuration ? "" : void 0;
  let t6;
  $3[15] !== title ? (t6 = title && (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: title }), $3[15] = title, $3[16] = t6) : t6 = $3[16];
  let t7;
  $3[17] !== description || $3[18] !== transition ? (t7 = description && (0, import_jsx_runtime2.jsx)(MotionText, { muted: true, size: 1, variants: content, transition, children: description }), $3[17] = description, $3[18] = transition, $3[19] = t7) : t7 = $3[19];
  let t8;
  $3[20] !== t6 || $3[21] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(TextBox, { flex: 1, padding: 3, children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 3, children: [
    t6,
    t7
  ] }) }), $3[20] = t6, $3[21] = t7, $3[22] = t8) : t8 = $3[22];
  let t9;
  $3[23] !== buttonTone || $3[24] !== closable || $3[25] !== onClose ? (t9 = closable && (0, import_jsx_runtime2.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime2.jsx)(Button, { as: "button", icon: CloseIcon, mode: "bleed", padding: 2, tone: buttonTone, onClick: onClose, style: {
    verticalAlign: "top"
  } }) }), $3[23] = buttonTone, $3[24] = closable, $3[25] = onClose, $3[26] = t9) : t9 = $3[26];
  let t10;
  $3[27] !== t8 || $3[28] !== t9 || $3[29] !== transition ? (t10 = (0, import_jsx_runtime2.jsxs)(MotionFlex2, { align: "flex-start", variants: content, transition, children: [
    t8,
    t9
  ] }), $3[27] = t8, $3[28] = t9, $3[29] = transition, $3[30] = t10) : t10 = $3[30];
  let t11;
  $3[31] !== cardTone || $3[32] !== duration || $3[33] !== hasDuration || $3[34] !== onClose || $3[35] !== radius || $3[36] !== transition || $3[37] !== updatedAt || $3[38] !== visualDuration ? (t11 = hasDuration && (0, import_jsx_runtime2.jsxs)(MotionLoadingBar, { variants: content, transition, children: [
    (0, import_jsx_runtime2.jsx)(LoadingBarMask, { tone: cardTone, radius }),
    (0, import_jsx_runtime2.jsx)(MotionLoadingBarProgress, { tone: cardTone, initial: {
      scaleX: 0
    }, animate: {
      scaleX: 1
    }, transition: {
      delay: visualDuration,
      duration: duration / 1e3,
      ease: "linear"
    }, onAnimationComplete: onClose }, `progress-${updatedAt}`)
  ] }), $3[31] = cardTone, $3[32] = duration, $3[33] = hasDuration, $3[34] = onClose, $3[35] = radius, $3[36] = transition, $3[37] = updatedAt, $3[38] = visualDuration, $3[39] = t11) : t11 = $3[39];
  let t12;
  return $3[40] !== cardTone || $3[41] !== radius || $3[42] !== restProps || $3[43] !== role || $3[44] !== t10 || $3[45] !== t11 || $3[46] !== t5 || $3[47] !== transition || $3[48] !== visualDuration ? (t12 = (0, import_jsx_runtime2.jsxs)(MotionToast, { "data-ui": "Toast", role, ...restProps, "data-has-duration": t5, custom: visualDuration, radius, shadow: 2, tone: cardTone, forwardedAs: "li", layout: "position", variants: container, initial, animate, exit, transition, children: [
    t10,
    t11
  ] }), $3[40] = cardTone, $3[41] = radius, $3[42] = restProps, $3[43] = role, $3[44] = t10, $3[45] = t11, $3[46] = t5, $3[47] = transition, $3[48] = visualDuration, $3[49] = t12) : t12 = $3[49], t12;
}
Toast.displayName = "Toast";
var container = {
  initial: {
    y: 32,
    scale: 0.5,
    zIndex: 1
  },
  hidden: {
    opacity: 0
  },
  visible: (visualDuration) => visualDuration ? {
    opacity: 1,
    transition: {
      when: "beforeChildren",
      staggerChildren: visualDuration / 3,
      duration: visualDuration / 3
    }
  } : {
    opacity: 1
  },
  slideIn: {
    y: 0,
    scale: 1
  },
  slideOut: {
    zIndex: 0,
    scale: 0.75
  }
};
var content = {
  initial: {
    willChange: "transform"
  },
  hidden: {
    opacity: 0
  },
  visible: {
    opacity: 1
  }
};
var MotionToast = motion.create(StyledToast);
var MotionFlex2 = motion.create(Flex);
var MotionText = motion.create(Text);
var MotionLoadingBar = motion.create(LoadingBar);
var MotionLoadingBarProgress = motion.create(LoadingBarProgress);
function useMounted() {
  return (0, import_react2.useSyncExternalStore)(subscribe, _temp$12, _temp22);
}
function _temp22() {
  return false;
}
function _temp$12() {
  return true;
}
var subscribe = () => () => {
};
var ToastContext = createGlobalScopedContext("@sanity/ui/context/toast", null);
function ToastLayer(props) {
  const $3 = (0, import_react_compiler_runtime2.c)(9), {
    children,
    padding: t0,
    paddingX,
    paddingY,
    gap: t1
  } = props, padding = t0 === void 0 ? 4 : t0, gap = t1 === void 0 ? 3 : t1, {
    zIndex
  } = useLayer();
  let t22;
  $3[0] !== zIndex ? (t22 = {
    zIndex
  }, $3[0] = zIndex, $3[1] = t22) : t22 = $3[1];
  let t3;
  return $3[2] !== children || $3[3] !== gap || $3[4] !== padding || $3[5] !== paddingX || $3[6] !== paddingY || $3[7] !== t22 ? (t3 = (0, import_jsx_runtime2.jsx)(StyledLayer2, { forwardedAs: "ul", "data-ui": "ToastProvider", padding, paddingX, paddingY, gap, columns: 1, style: t22, children }), $3[2] = children, $3[3] = gap, $3[4] = padding, $3[5] = paddingX, $3[6] = paddingY, $3[7] = t22, $3[8] = t3) : t3 = $3[8], t3;
}
ToastLayer.displayName = "ToastLayer";
var StyledLayer2 = dt(Grid).withConfig({
  displayName: "StyledLayer",
  componentId: "sc-1tbwn58-0"
})`box-sizing:border-box;position:fixed;right:0;bottom:0;list-style:none;pointer-events:none;max-width:420px;width:100%;`;
var toastId = 0;
function generateToastId() {
  return String(toastId++);
}
function ToastProvider(props) {
  const $3 = (0, import_react_compiler_runtime2.c)(13), {
    children,
    padding,
    paddingX,
    paddingY,
    gap,
    zOffset: t0
  } = props, zOffset = t0 === void 0 ? 1 : t0;
  let t1;
  $3[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = [], $3[0] = t1) : t1 = $3[0];
  const [state, setState] = (0, import_react2.useState)(t1), mounted = useMounted();
  let t22;
  $3[1] === Symbol.for("react.memo_cache_sentinel") ? (t22 = {
    version: 0,
    push: (params) => {
      const id = params.id || generateToastId(), duration = params.duration || 5e3;
      return (0, import_react2.startTransition)(() => {
        setState((prevState) => {
          if (duration === 0.01)
            return prevState.filter((toast) => toast.id !== id);
          const dismiss = () => (0, import_react2.startTransition)(() => setState((currentState) => currentState.filter((toast_0) => toast_0.id !== id)));
          return [...prevState.filter((toast_1) => toast_1.id !== id), {
            dismiss,
            id,
            updatedAt: Date.now(),
            params: {
              ...params,
              duration
            }
          }];
        });
      }), id;
    }
  }, $3[1] = t22) : t22 = $3[1];
  const value = t22;
  let t3;
  $3[2] !== gap || $3[3] !== mounted || $3[4] !== padding || $3[5] !== paddingX || $3[6] !== paddingY || $3[7] !== state || $3[8] !== zOffset ? (t3 = mounted && (0, import_jsx_runtime2.jsx)(LayerProvider, { zOffset, children: (0, import_jsx_runtime2.jsx)(ToastLayer, { padding, paddingX, paddingY, gap, children: (0, import_jsx_runtime2.jsx)(AnimatePresence, { initial: false, mode: "popLayout", children: state.map(_temp4) }) }) }), $3[2] = gap, $3[3] = mounted, $3[4] = padding, $3[5] = paddingX, $3[6] = paddingY, $3[7] = state, $3[8] = zOffset, $3[9] = t3) : t3 = $3[9];
  let t4;
  return $3[10] !== children || $3[11] !== t3 ? (t4 = (0, import_jsx_runtime2.jsxs)(ToastContext.Provider, { value, children: [
    children,
    t3
  ] }), $3[10] = children, $3[11] = t3, $3[12] = t4) : t4 = $3[12], t4;
}
function _temp4(t0) {
  const {
    dismiss: dismiss_0,
    id: id_0,
    params: params_0,
    updatedAt
  } = t0;
  return (0, import_jsx_runtime2.jsx)(Toast, { closable: params_0.closable, description: params_0.description, onClose: dismiss_0, status: params_0.status, title: params_0.title, duration: params_0.duration, updatedAt }, id_0);
}
ToastProvider.displayName = "ToastProvider";
function useToast() {
  const value = (0, import_react2.useContext)(ToastContext);
  if (!value)
    throw new Error("useToast(): missing context value");
  if (!isRecord2(value) || value.version !== 0)
    throw new Error("useToast(): the context value is not compatible");
  return value;
}
function _findPrevItemElement(state, itemElements, focusedElement) {
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(0, idx), len = els.length;
  for (let i3 = len - 1; i3 >= 0; i3 -= 1) {
    const itemKey = els[i3].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p2 = [];
    let expanded = true;
    for (let j3 = 0; j3 < segments.length; j3 += 1) {
      p2.push(segments[j3]);
      const k2 = p2.join("/");
      if (!state[k2]?.expanded) {
        expanded = false;
        break;
      }
    }
    if (expanded)
      return els[i3];
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(idx), len = itemElements.length;
  for (let i3 = 1; i3 < len; i3 += 1) {
    if (!els[i3])
      continue;
    const itemKey = els[i3].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p2 = [];
    let expanded = true;
    for (let j3 = 0; j3 < segments.length; j3 += 1) {
      p2.push(segments[j3]);
      const k2 = p2.join("/");
      if (!state[k2]?.expanded) {
        expanded = false;
        break;
      }
    }
    if (expanded)
      return els[i3];
  }
  return null;
}
function _focusItemElement(el) {
  if (el.getAttribute("role") === "treeitem" && el.focus(), el.getAttribute("role") === "none") {
    const firstChild = el.firstChild;
    firstChild && firstChild instanceof HTMLElement && firstChild.focus();
  }
}
var TreeContext = createGlobalScopedContext("@sanity/ui/context/tree", null);
var Tree = (0, import_react2.forwardRef)(function(props, forwardedRef) {
  const $3 = (0, import_react_compiler_runtime2.c)(37);
  let children, onFocus2, restProps, t0;
  $3[0] !== props ? ({
    children,
    space: t0,
    onFocus: onFocus2,
    ...restProps
  } = props, $3[0] = props, $3[1] = children, $3[2] = onFocus2, $3[3] = restProps, $3[4] = t0) : (children = $3[1], onFocus2 = $3[2], restProps = $3[3], t0 = $3[4]);
  const space = t0 === void 0 ? 1 : t0, ref = (0, import_react2.useRef)(null), [focusedElement, setFocusedElement] = (0, import_react2.useState)(null), focusedElementRef = (0, import_react2.useRef)(focusedElement);
  let t1;
  $3[5] === Symbol.for("react.memo_cache_sentinel") ? (t1 = [], $3[5] = t1) : t1 = $3[5];
  const path = t1;
  let t22;
  $3[6] === Symbol.for("react.memo_cache_sentinel") ? (t22 = [], $3[6] = t22) : t22 = $3[6];
  const [itemElements, setItemElements] = (0, import_react2.useState)(t22);
  let t3;
  $3[7] === Symbol.for("react.memo_cache_sentinel") ? (t3 = {}, $3[7] = t3) : t3 = $3[7];
  const [state, setState] = (0, import_react2.useState)(t3), stateRef = (0, import_react2.useRef)(state);
  let t4;
  $3[8] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => ref.current, $3[8] = t4) : t4 = $3[8], (0, import_react2.useImperativeHandle)(forwardedRef, t4);
  let t5, t6;
  $3[9] !== focusedElement ? (t5 = () => {
    focusedElementRef.current = focusedElement;
  }, t6 = [focusedElement], $3[9] = focusedElement, $3[10] = t5, $3[11] = t6) : (t5 = $3[10], t6 = $3[11]), (0, import_react2.useEffect)(t5, t6);
  let t7, t8;
  $3[12] !== state ? (t7 = () => {
    stateRef.current = state;
  }, t8 = [state], $3[12] = state, $3[13] = t7, $3[14] = t8) : (t7 = $3[13], t8 = $3[14]), (0, import_react2.useEffect)(t7, t8);
  let t9;
  $3[15] === Symbol.for("react.memo_cache_sentinel") ? (t9 = (element, path_0, expanded, selected) => (setState((s3) => ({
    ...s3,
    [path_0]: {
      element,
      expanded
    }
  })), selected && setFocusedElement(element), () => {
    setState((s_0) => {
      const newState = {
        ...s_0
      };
      return delete newState[path_0], newState;
    });
  }), $3[15] = t9) : t9 = $3[15];
  const registerItem = t9;
  let t10;
  $3[16] === Symbol.for("react.memo_cache_sentinel") ? (t10 = (path_1, expanded_0) => {
    setState((s_1) => {
      const itemState = s_1[path_1];
      return itemState ? {
        ...s_1,
        [path_1]: {
          ...itemState,
          expanded: expanded_0
        }
      } : s_1;
    });
  }, $3[16] = t10) : t10 = $3[16];
  const setExpanded = t10, t11 = focusedElement || itemElements[0] || null;
  let t12;
  $3[17] !== space || $3[18] !== state || $3[19] !== t11 ? (t12 = {
    version: 0,
    focusedElement: t11,
    level: 0,
    path,
    registerItem,
    setExpanded,
    setFocusedElement,
    space,
    state
  }, $3[17] = space, $3[18] = state, $3[19] = t11, $3[20] = t12) : t12 = $3[20];
  const contextValue = t12;
  let t13;
  $3[21] !== itemElements ? (t13 = (event) => {
    if (focusedElementRef.current) {
      if (event.key === "ArrowDown") {
        event.preventDefault();
        const nextEl = _findNextItemElement(stateRef.current, itemElements, focusedElementRef.current);
        nextEl && (_focusItemElement(nextEl), setFocusedElement(nextEl));
        return;
      }
      if (event.key === "ArrowUp") {
        event.preventDefault();
        const prevEl = _findPrevItemElement(stateRef.current, itemElements, focusedElementRef.current);
        prevEl && (_focusItemElement(prevEl), setFocusedElement(prevEl));
        return;
      }
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
        if (!itemKey)
          return;
        const itemState_0 = stateRef.current[itemKey];
        if (!itemState_0)
          return;
        if (itemState_0.expanded)
          setState((s_2) => {
            const itemState_1 = s_2[itemKey];
            return itemState_1 ? {
              ...s_2,
              [itemKey]: {
                ...itemState_1,
                expanded: false
              }
            } : s_2;
          });
        else {
          const itemPath = itemKey.split("/");
          itemPath.pop();
          const parentKey = itemPath.join("/"), parentState = parentKey && stateRef.current[parentKey];
          parentState && (parentState.element.focus(), setFocusedElement(parentState.element));
        }
        return;
      }
      if (event.key === "ArrowRight") {
        event.preventDefault();
        const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
        if (!focusedKey)
          return;
        stateRef.current[focusedKey]?.expanded || setState((s_3) => {
          const itemState_2 = s_3[focusedKey];
          return itemState_2 ? {
            ...s_3,
            [focusedKey]: {
              ...itemState_2,
              expanded: true
            }
          } : s_3;
        });
        return;
      }
    }
  }, $3[21] = itemElements, $3[22] = t13) : t13 = $3[22];
  const handleKeyDown = t13;
  let t14;
  $3[23] !== onFocus2 ? (t14 = (event_0) => {
    setFocusedElement(event_0.target), onFocus2?.(event_0);
  }, $3[23] = onFocus2, $3[24] = t14) : t14 = $3[24];
  const handleFocus = t14;
  let t15;
  $3[25] === Symbol.for("react.memo_cache_sentinel") ? (t15 = () => {
    if (!ref.current)
      return;
    const _itemElements = Array.from(ref.current.querySelectorAll('[data-ui="TreeItem"]'));
    setItemElements(_itemElements);
  }, $3[25] = t15) : t15 = $3[25];
  let t16;
  $3[26] !== children ? (t16 = [children], $3[26] = children, $3[27] = t16) : t16 = $3[27], (0, import_react2.useEffect)(t15, t16);
  let t17;
  $3[28] !== children || $3[29] !== handleFocus || $3[30] !== handleKeyDown || $3[31] !== restProps || $3[32] !== space ? (t17 = (0, import_jsx_runtime2.jsx)(Stack, { as: "ul", "data-ui": "Tree", ...restProps, onFocus: handleFocus, onKeyDown: handleKeyDown, ref, role: "tree", space, children }), $3[28] = children, $3[29] = handleFocus, $3[30] = handleKeyDown, $3[31] = restProps, $3[32] = space, $3[33] = t17) : t17 = $3[33];
  let t18;
  return $3[34] !== contextValue || $3[35] !== t17 ? (t18 = (0, import_jsx_runtime2.jsx)(TreeContext.Provider, { value: contextValue, children: t17 }), $3[34] = contextValue, $3[35] = t17, $3[36] = t18) : t18 = $3[36], t18;
});
Tree.displayName = "ForwardRef(Tree)";
function treeItemRootStyle() {
  return lt`
    &[role='none'] > [role='treeitem'] {
      outline: none;
      cursor: default;
      border-radius: 3px;

      background-color: var(--card-bg-color);
      color: var(--treeitem-fg-color);

      &:focus {
        position: relative;
      }
    }

    &[role='treeitem'] {
      outline: none;

      & > div {
        cursor: default;
        border-radius: 3px;

        background-color: var(--card-bg-color);
        color: var(--treeitem-fg-color);
      }

      &:focus > div {
        position: relative;
      }
    }
  `;
}
function treeItemRootColorStyle(props) {
  const $tone = "default", {
    color: color2
  } = getTheme_v2(props.theme), tone = color2.selectable[$tone];
  return lt`
    &[role='none'] {
      & > [role='treeitem'] {
        ${_cardColorStyle(color2, tone.enabled)}
      }

      &[data-selected] > [role='treeitem'] {
        ${_cardColorStyle(color2, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {
          ${_cardColorStyle(color2, tone.hovered)}
        }

        & > [role='treeitem']:focus {
          ${_cardColorStyle(color2, tone.selected)}
        }
      }
    }

    &[role='treeitem'] {
      & > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color2, tone.enabled)}
      }

      &[data-selected] > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color2, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {
          ${_cardColorStyle(color2, tone.hovered)}
        }

        &:focus > [data-ui='TreeItem__box'] {
          ${_cardColorStyle(color2, tone.selected)}
        }
      }
    }
  `;
}
function treeItemBoxStyle(props) {
  const {
    $level
  } = props, {
    space
  } = getTheme_v2(props.theme);
  return lt`
    padding-left: ${rem(space[2] * $level)};

    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function useTree() {
  const tree = (0, import_react2.useContext)(TreeContext);
  if (!tree)
    throw new Error("Tree: missing context value");
  return tree;
}
function TreeGroup(props) {
  const $3 = (0, import_react_compiler_runtime2.c)(9);
  let children, restProps, t0;
  $3[0] !== props ? ({
    children,
    expanded: t0,
    ...restProps
  } = props, $3[0] = props, $3[1] = children, $3[2] = restProps, $3[3] = t0) : (children = $3[1], restProps = $3[2], t0 = $3[3]);
  const expanded = t0 === void 0 ? false : t0, tree = useTree(), t1 = !expanded;
  let t22;
  return $3[4] !== children || $3[5] !== restProps || $3[6] !== t1 || $3[7] !== tree.space ? (t22 = (0, import_jsx_runtime2.jsx)(Stack, { as: "ul", "data-ui": "TreeGroup", ...restProps, hidden: t1, marginTop: tree.space, role: "group", space: tree.space, children }), $3[4] = children, $3[5] = restProps, $3[6] = t1, $3[7] = tree.space, $3[8] = t22) : t22 = $3[8], t22;
}
var StyledTreeItem = dt.li.withConfig({
  displayName: "StyledTreeItem",
  componentId: "sc-iiskig-0"
})(treeItemRootStyle, treeItemRootColorStyle);
var TreeItemBox = dt(Box).attrs({
  forwardedAs: "a"
}).withConfig({
  displayName: "TreeItemBox",
  componentId: "sc-iiskig-1"
})(treeItemBoxStyle);
var ToggleArrowText = dt(Text).withConfig({
  displayName: "ToggleArrowText",
  componentId: "sc-iiskig-2"
})`& > svg{transition:transform 100ms;}`;
function TreeItem(props) {
  const $3 = (0, import_react_compiler_runtime2.c)(113);
  let IconComponent, children, href, idProp, linkAs, muted, onClick, restProps, t0, t1, t22, t3, t4, text, weight;
  $3[0] !== props ? ({
    children,
    expanded: t0,
    fontSize: t1,
    href,
    icon: IconComponent,
    id: idProp,
    linkAs,
    muted,
    onClick,
    padding: t22,
    selected: t3,
    space: t4,
    text,
    weight,
    ...restProps
  } = props, $3[0] = props, $3[1] = IconComponent, $3[2] = children, $3[3] = href, $3[4] = idProp, $3[5] = linkAs, $3[6] = muted, $3[7] = onClick, $3[8] = restProps, $3[9] = t0, $3[10] = t1, $3[11] = t22, $3[12] = t3, $3[13] = t4, $3[14] = text, $3[15] = weight) : (IconComponent = $3[1], children = $3[2], href = $3[3], idProp = $3[4], linkAs = $3[5], muted = $3[6], onClick = $3[7], restProps = $3[8], t0 = $3[9], t1 = $3[10], t22 = $3[11], t3 = $3[12], t4 = $3[13], text = $3[14], weight = $3[15]);
  const expandedProp = t0 === void 0 ? false : t0, fontSize2 = t1 === void 0 ? 1 : t1, padding = t22 === void 0 ? 2 : t22, selected = t3 === void 0 ? false : t3, space = t4 === void 0 ? 2 : t4, [rootElement, _setRootElement] = (0, import_react2.useState)(null);
  let t5;
  $3[16] === Symbol.for("react.memo_cache_sentinel") ? (t5 = (node2) => {
    (0, import_react2.startTransition)(() => _setRootElement(node2));
  }, $3[16] = t5) : t5 = $3[16];
  const setRootElement = t5, treeitemRef = (0, import_react2.useRef)(null), tree = useTree(), {
    path,
    registerItem,
    setExpanded,
    setFocusedElement
  } = tree, _id = (0, import_react2.useId)(), id = idProp || _id;
  let t6, t7;
  if ($3[17] !== id || $3[18] !== path) {
    const itemPath = path.concat([id || ""]);
    t6 = itemPath, t7 = itemPath.join("/"), $3[17] = id, $3[18] = path, $3[19] = t6, $3[20] = t7;
  } else
    t6 = $3[19], t7 = $3[20];
  let t8;
  $3[21] !== t6 || $3[22] !== t7 ? (t8 = [t6, t7], $3[21] = t6, $3[22] = t7, $3[23] = t8) : t8 = $3[23];
  const [itemPath_0, itemKey] = t8, itemState = tree.state[itemKey], focused = tree.focusedElement === rootElement, expanded = itemState?.expanded === void 0 ? expandedProp : itemState?.expanded || false, tabIndex = tree.focusedElement && tree.focusedElement === rootElement ? 0 : -1, t9 = tree.level + 1;
  let t10;
  $3[24] !== itemPath_0 || $3[25] !== t9 || $3[26] !== tree ? (t10 = {
    ...tree,
    level: t9,
    path: itemPath_0
  }, $3[24] = itemPath_0, $3[25] = t9, $3[26] = tree, $3[27] = t10) : t10 = $3[27];
  const contextValue = t10;
  let t11;
  $3[28] !== expanded || $3[29] !== itemKey || $3[30] !== onClick || $3[31] !== rootElement || $3[32] !== setExpanded || $3[33] !== setFocusedElement ? (t11 = (event) => {
    onClick && onClick(event);
    const target = event.target;
    target instanceof HTMLElement && (target.getAttribute("data-ui") === "TreeItem" || target.closest('[data-ui="TreeItem__box"]')) && (event.stopPropagation(), setExpanded(itemKey, !expanded), setFocusedElement(rootElement));
  }, $3[28] = expanded, $3[29] = itemKey, $3[30] = onClick, $3[31] = rootElement, $3[32] = setExpanded, $3[33] = setFocusedElement, $3[34] = t11) : t11 = $3[34];
  const handleClick = t11;
  let t12;
  $3[35] !== focused || $3[36] !== rootElement ? (t12 = (event_0) => {
    focused && event_0.key === "Enter" && (treeitemRef.current || rootElement)?.click();
  }, $3[35] = focused, $3[36] = rootElement, $3[37] = t12) : t12 = $3[37];
  const handleKeyDown = t12;
  let t13, t14;
  $3[38] !== expanded || $3[39] !== itemKey || $3[40] !== registerItem || $3[41] !== rootElement || $3[42] !== selected ? (t13 = () => {
    if (rootElement)
      return registerItem(rootElement, itemKey, expanded, selected);
  }, t14 = [expanded, itemKey, registerItem, rootElement, selected], $3[38] = expanded, $3[39] = itemKey, $3[40] = registerItem, $3[41] = rootElement, $3[42] = selected, $3[43] = t13, $3[44] = t14) : (t13 = $3[43], t14 = $3[44]), (0, import_react2.useEffect)(t13, t14);
  const t15 = IconComponent || children ? "visible" : "hidden";
  let t16;
  $3[45] !== t15 ? (t16 = {
    visibility: t15,
    pointerEvents: "none"
  }, $3[45] = t15, $3[46] = t16) : t16 = $3[46];
  let t17;
  $3[47] !== IconComponent || $3[48] !== fontSize2 || $3[49] !== muted || $3[50] !== weight ? (t17 = IconComponent && (0, import_jsx_runtime2.jsx)(Text, { muted, size: fontSize2, weight, children: (0, import_jsx_runtime2.jsx)(IconComponent, {}) }), $3[47] = IconComponent, $3[48] = fontSize2, $3[49] = muted, $3[50] = weight, $3[51] = t17) : t17 = $3[51];
  let t18;
  $3[52] !== IconComponent || $3[53] !== expanded || $3[54] !== fontSize2 || $3[55] !== muted || $3[56] !== weight ? (t18 = !IconComponent && (0, import_jsx_runtime2.jsx)(ToggleArrowText, { muted, size: fontSize2, weight, children: (0, import_jsx_runtime2.jsx)(ToggleArrowRightIcon, { style: {
    transform: expanded ? "rotate(90deg)" : void 0
  } }) }), $3[52] = IconComponent, $3[53] = expanded, $3[54] = fontSize2, $3[55] = muted, $3[56] = weight, $3[57] = t18) : t18 = $3[57];
  let t19;
  $3[58] !== space || $3[59] !== t16 || $3[60] !== t17 || $3[61] !== t18 ? (t19 = (0, import_jsx_runtime2.jsxs)(Box, { marginRight: space, style: t16, children: [
    t17,
    t18
  ] }), $3[58] = space, $3[59] = t16, $3[60] = t17, $3[61] = t18, $3[62] = t19) : t19 = $3[62];
  let t20;
  $3[63] !== fontSize2 || $3[64] !== muted || $3[65] !== text || $3[66] !== weight ? (t20 = (0, import_jsx_runtime2.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime2.jsx)(Text, { muted, size: fontSize2, textOverflow: "ellipsis", weight, children: text }) }), $3[63] = fontSize2, $3[64] = muted, $3[65] = text, $3[66] = weight, $3[67] = t20) : t20 = $3[67];
  let t21;
  $3[68] !== padding || $3[69] !== t19 || $3[70] !== t20 ? (t21 = (0, import_jsx_runtime2.jsxs)(Flex, { padding, children: [
    t19,
    t20
  ] }), $3[68] = padding, $3[69] = t19, $3[70] = t20, $3[71] = t21) : t21 = $3[71];
  const content2 = t21;
  if (href) {
    const t2222 = selected ? "" : void 0;
    let t232;
    $3[72] !== content2 || $3[73] !== expanded || $3[74] !== href || $3[75] !== linkAs || $3[76] !== tabIndex || $3[77] !== tree.level ? (t232 = (0, import_jsx_runtime2.jsx)(TreeItemBox, { $level: tree.level, "aria-expanded": expanded, as: linkAs, "data-ui": "TreeItem__box", href, ref: treeitemRef, role: "treeitem", tabIndex, children: content2 }), $3[72] = content2, $3[73] = expanded, $3[74] = href, $3[75] = linkAs, $3[76] = tabIndex, $3[77] = tree.level, $3[78] = t232) : t232 = $3[78];
    let t242;
    $3[79] !== children || $3[80] !== expanded ? (t242 = children && (0, import_jsx_runtime2.jsx)(TreeGroup, { hidden: !expanded, children }), $3[79] = children, $3[80] = expanded, $3[81] = t242) : t242 = $3[81];
    let t252;
    $3[82] !== contextValue || $3[83] !== t242 ? (t252 = (0, import_jsx_runtime2.jsx)(TreeContext.Provider, { value: contextValue, children: t242 }), $3[82] = contextValue, $3[83] = t242, $3[84] = t252) : t252 = $3[84];
    let t262;
    return $3[85] !== handleClick || $3[86] !== id || $3[87] !== itemKey || $3[88] !== restProps || $3[89] !== t2222 || $3[90] !== t232 || $3[91] !== t252 ? (t262 = (0, import_jsx_runtime2.jsxs)(StyledTreeItem, { "data-selected": t2222, "data-tree-id": id, "data-tree-key": itemKey, "data-ui": "TreeItem", ...restProps, onClick: handleClick, ref: setRootElement, role: "none", children: [
      t232,
      t252
    ] }), $3[85] = handleClick, $3[86] = id, $3[87] = itemKey, $3[88] = restProps, $3[89] = t2222, $3[90] = t232, $3[91] = t252, $3[92] = t262) : t262 = $3[92], t262;
  }
  const t222 = selected ? "" : void 0;
  let t23;
  $3[93] !== content2 || $3[94] !== tree.level ? (t23 = (0, import_jsx_runtime2.jsx)(TreeItemBox, { $level: tree.level, as: "div", "data-ui": "TreeItem__box", children: content2 }), $3[93] = content2, $3[94] = tree.level, $3[95] = t23) : t23 = $3[95];
  let t24;
  $3[96] !== children || $3[97] !== expanded ? (t24 = children && (0, import_jsx_runtime2.jsx)(TreeGroup, { expanded, children }), $3[96] = children, $3[97] = expanded, $3[98] = t24) : t24 = $3[98];
  let t25;
  $3[99] !== contextValue || $3[100] !== t24 ? (t25 = (0, import_jsx_runtime2.jsx)(TreeContext.Provider, { value: contextValue, children: t24 }), $3[99] = contextValue, $3[100] = t24, $3[101] = t25) : t25 = $3[101];
  let t26;
  return $3[102] !== expanded || $3[103] !== handleClick || $3[104] !== handleKeyDown || $3[105] !== id || $3[106] !== itemKey || $3[107] !== restProps || $3[108] !== t222 || $3[109] !== t23 || $3[110] !== t25 || $3[111] !== tabIndex ? (t26 = (0, import_jsx_runtime2.jsxs)(StyledTreeItem, { "data-selected": t222, "data-ui": "TreeItem", "data-tree-id": id, "data-tree-key": itemKey, ...restProps, "aria-expanded": expanded, onClick: handleClick, onKeyDown: handleKeyDown, ref: setRootElement, role: "treeitem", tabIndex, children: [
    t23,
    t25
  ] }), $3[102] = expanded, $3[103] = handleClick, $3[104] = handleKeyDown, $3[105] = id, $3[106] = itemKey, $3[107] = restProps, $3[108] = t222, $3[109] = t23, $3[110] = t25, $3[111] = tabIndex, $3[112] = t26) : t26 = $3[112], t26;
}
TreeItem.displayName = "TreeItem";

// node_modules/sanity-plugin-media/dist/index.mjs
var import_react19 = __toESM(require_react(), 1);

// node_modules/sanity-plugin-media/node_modules/groq/lib/groq.js
function groq(strings2, ...keys) {
  const lastIndex = strings2.length - 1;
  return strings2.slice(0, lastIndex).reduce((acc, str, i3) => acc + str + keys[i3], "") + strings2[lastIndex];
}

// node_modules/react-redux/dist/react-redux.mjs
var React = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var IS_REACT_19 = React.version.startsWith("19");
var REACT_ELEMENT_TYPE = Symbol.for(
  IS_REACT_19 ? "react.transitional.element" : "react.element"
);
var REACT_PORTAL_TYPE = Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
var REACT_CONTEXT_TYPE = Symbol.for("react.context");
var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = Symbol.for(
  "react.suspense_list"
);
var REACT_MEMO_TYPE = Symbol.for("react.memo");
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
var REACT_CLIENT_REFERENCE = Symbol.for(
  "react.client.reference"
);
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function defaultNoopBatch(callback) {
  callback();
}
function createListenerCollection() {
  let first2 = null;
  let last = null;
  return {
    clear() {
      first2 = null;
      last = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener2 = first2;
        while (listener2) {
          listener2.callback();
          listener2 = listener2.next;
        }
      });
    },
    get() {
      const listeners = [];
      let listener2 = first2;
      while (listener2) {
        listeners.push(listener2);
        listener2 = listener2.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener2 = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener2.prev) {
        listener2.prev.next = listener2;
      } else {
        first2 = listener2;
      }
      return function unsubscribe() {
        if (!isSubscribed || first2 === null) return;
        isSubscribed = false;
        if (listener2.next) {
          listener2.next.prev = listener2.prev;
        } else {
          last = listener2.prev;
        }
        if (listener2.prev) {
          listener2.prev.next = listener2.next;
        } else {
          first2 = listener2.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener2) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener2);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = canUseDOM();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? React.useLayoutEffect : React.useEffect;
var useIsomorphicLayoutEffect = getUseIsomorphicLayoutEffect();
var FORWARD_REF_STATICS = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {
  [ForwardRef]: FORWARD_REF_STATICS,
  [Memo]: MEMO_STATICS
};
var objectPrototype = Object.prototype;
var ContextKey = Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  if (!React.createContext) return {};
  const contextMap = gT[ContextKey] ??= /* @__PURE__ */ new Map();
  let realContext = contextMap.get(React.createContext);
  if (!realContext) {
    realContext = React.createContext(
      null
    );
    if (true) {
      realContext.displayName = "ReactRedux";
    }
    contextMap.set(React.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = getContext();
function Provider(providerProps) {
  const { children, context, serverState, store } = providerProps;
  const contextValue = React.useMemo(() => {
    const subscription = createSubscription(store);
    const baseContextValue = {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
    if (false) {
      return baseContextValue;
    } else {
      const { identityFunctionCheck = "once", stabilityCheck = "once" } = providerProps;
      return Object.assign(baseContextValue, {
        stabilityCheck,
        identityFunctionCheck
      });
    }
  }, [store, serverState]);
  const previousState = React.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return React.createElement(Context.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;
function createReduxContextHook(context = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = React.useContext(context);
    if (!contextValue) {
      throw new Error(
        "could not find react-redux context value; please ensure the component is wrapped in a <Provider>"
      );
    }
    return contextValue;
  };
}
var useReduxContext = createReduxContextHook();
function createStoreHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
    // @ts-ignore
    createReduxContextHook(context)
  );
  const useStore2 = () => {
    const { store } = useReduxContext2();
    return store;
  };
  Object.assign(useStore2, {
    withTypes: () => useStore2
  });
  return useStore2;
}
var useStore = createStoreHook();
function createDispatchHook(context = ReactReduxContext) {
  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
  const useDispatch2 = () => {
    const store = useStore2();
    return store.dispatch;
  };
  Object.assign(useDispatch2, {
    withTypes: () => useDispatch2
  });
  return useDispatch2;
}
var useDispatch = createDispatchHook();
var refEquality = (a2, b2) => a2 === b2;
function createSelectorHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
  const useSelector2 = (selector, equalityFnOrOptions = {}) => {
    const { equalityFn = refEquality } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
    if (true) {
      if (!selector) {
        throw new Error(`You must pass a selector to useSelector`);
      }
      if (typeof selector !== "function") {
        throw new Error(`You must pass a function as a selector to useSelector`);
      }
      if (typeof equalityFn !== "function") {
        throw new Error(
          `You must pass a function as an equality function to useSelector`
        );
      }
    }
    const reduxContext = useReduxContext2();
    const { store, subscription, getServerState } = reduxContext;
    const firstRun = React.useRef(true);
    const wrappedSelector = React.useCallback(
      {
        [selector.name](state) {
          const selected = selector(state);
          if (true) {
            const { devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? {} : equalityFnOrOptions;
            const { identityFunctionCheck, stabilityCheck } = reduxContext;
            const {
              identityFunctionCheck: finalIdentityFunctionCheck,
              stabilityCheck: finalStabilityCheck
            } = {
              stabilityCheck,
              identityFunctionCheck,
              ...devModeChecks
            };
            if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
              const toCompare = selector(state);
              if (!equalityFn(selected, toCompare)) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e2) {
                  ;
                  ({ stack } = e2);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization",
                  {
                    state,
                    selected,
                    selected2: toCompare,
                    stack
                  }
                );
              }
            }
            if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
              if (selected === state) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e2) {
                  ;
                  ({ stack } = e2);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.",
                  { stack }
                );
              }
            }
            if (firstRun.current) firstRun.current = false;
          }
          return selected;
        }
      }[selector.name],
      [selector]
    );
    const selectedState = (0, import_with_selector.useSyncExternalStoreWithSelector)(
      subscription.addNestedSub,
      store.getState,
      getServerState || store.getState,
      wrappedSelector,
      equalityFn
    );
    React.useDebugValue(selectedState);
    return selectedState;
  };
  Object.assign(useSelector2, {
    withTypes: () => useSelector2
  });
  return useSelector2;
}
var useSelector = createSelectorHook();

// node_modules/redux/dist/redux.mjs
var $$observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${randomString()}`,
  REPLACE: `@@redux/REPLACE${randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto2 = obj;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(obj) === proto2 || Object.getPrototypeOf(obj) === null;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  const type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate(val))
    return "date";
  if (isError(val))
    return "error";
  const constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  let typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer2, preloadedState, enhancer) {
  if (typeof reducer2 !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer2)}'`);
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
    }
    return enhancer(createStore)(reducer2, preloadedState);
  }
  let currentReducer = reducer2;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener2, key2) => {
        nextListeners.set(key2, listener2);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe2(listener2) {
    if (typeof listener2 !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : `Expected the listener to be a function. Instead, received: '${kindOf(listener2)}'`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener2);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (typeof action.type !== "string") {
      throw new Error(false ? formatProdErrorMessage(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener2) => {
      listener2();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe2;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe: subscribe2,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function warning(message2) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message2);
  }
  try {
    throw new Error(message2);
  } catch (e2) {
  }
}
function getUnexpectedStateShapeWarningMessage(inputState, reducers2, action, unexpectedKeyCache) {
  const reducerKeys = Object.keys(reducers2);
  const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (reducerKeys.length === 0) {
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  }
  if (!isPlainObject(inputState)) {
    return `The ${argumentName} has unexpected type of "${kindOf(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join('", "')}"`;
  }
  const unexpectedKeys = Object.keys(inputState).filter((key2) => !reducers2.hasOwnProperty(key2) && !unexpectedKeyCache[key2]);
  unexpectedKeys.forEach((key2) => {
    unexpectedKeyCache[key2] = true;
  });
  if (action && action.type === actionTypes_default.REPLACE)
    return;
  if (unexpectedKeys.length > 0) {
    return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join('", "')}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join('", "')}". Unexpected keys will be ignored.`;
  }
}
function assertReducerShape(reducers2) {
  Object.keys(reducers2).forEach((key2) => {
    const reducer2 = reducers2[key2];
    const initialState4 = reducer2(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState4 === "undefined") {
      throw new Error(false ? formatProdErrorMessage(12) : `The slice reducer for key "${key2}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    }
    if (typeof reducer2(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(false ? formatProdErrorMessage(13) : `The slice reducer for key "${key2}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
    }
  });
}
function combineReducers(reducers2) {
  const reducerKeys = Object.keys(reducers2);
  const finalReducers = {};
  for (let i3 = 0; i3 < reducerKeys.length; i3++) {
    const key2 = reducerKeys[i3];
    if (true) {
      if (typeof reducers2[key2] === "undefined") {
        warning(`No reducer provided for key "${key2}"`);
      }
    }
    if (typeof reducers2[key2] === "function") {
      finalReducers[key2] = reducers2[key2];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let unexpectedKeyCache;
  if (true) {
    unexpectedKeyCache = {};
  }
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e2) {
    shapeAssertionError = e2;
  }
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    if (true) {
      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning(warningMessage);
      }
    }
    let hasChanged = false;
    const nextState = {};
    for (let i3 = 0; i3 < finalReducerKeys.length; i3++) {
      const key2 = finalReducerKeys[i3];
      const reducer2 = finalReducers[key2];
      const previousStateForKey = state[key2];
      const nextStateForKey = reducer2(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        const actionType = action && action.type;
        throw new Error(false ? formatProdErrorMessage(14) : `When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key2}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
      }
      nextState[key2] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore2) => (reducer2, preloadedState) => {
    const store = createStore2(reducer2, preloadedState);
    let dispatch = () => {
      throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware2) => middleware2(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}
function isAction(action) {
  return isPlainObject(action) && "type" in action && typeof action.type === "string";
}

// node_modules/reselect/dist/reselect.mjs
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
    let isInputSameAsOutput = false;
    try {
      const emptyObject = {};
      if (resultFunc(emptyObject) === emptyObject)
        isInputSameAsOutput = true;
    } catch {
    }
    if (isInputSameAsOutput) {
      let stack = void 0;
      try {
        throw new Error();
      } catch (e2) {
        ;
        ({ stack } = e2);
      }
      console.warn(
        "The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",
        { stack }
      );
    }
  }
};
var runInputStabilityCheck = (inputSelectorResultsObject, options2, inputSelectorArgs) => {
  const { memoize: memoize2, memoizeOptions } = options2;
  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
  const createAnEmptyObject = memoize2(() => ({}), ...memoizeOptions);
  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
  if (!areInputSelectorResultsEqual) {
    let stack = void 0;
    try {
      throw new Error();
    } catch (e2) {
      ;
      ({ stack } = e2);
    }
    console.warn(
      "An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",
      {
        arguments: inputSelectorArgs,
        firstInputs: inputSelectorResults,
        secondInputs: inputSelectorResultsCopy,
        stack
      }
    );
  }
};
var globalDevModeChecks = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
var NOT_FOUND = Symbol("NOT_FOUND");
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
  if (typeof object !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array.every((item) => typeof item === "function")) {
    const itemTypes = array.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length: length2 } = dependencies;
  for (let i3 = 0; i3 < length2; i3++) {
    inputSelectorResults.push(dependencies[i3].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
  const { identityFunctionCheck, inputStabilityCheck } = {
    ...globalDevModeChecks,
    ...devModeChecks
  };
  return {
    identityFunctionCheck: {
      shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
      run: runIdentityFunctionCheck
    },
    inputStabilityCheck: {
      shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
      run: runInputStabilityCheck
    }
  };
};
var REDUX_PROXY_LABEL = Symbol();
var proto = Object.getPrototypeOf({});
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options2 = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options2;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    let cacheNode = fnNode;
    const { length: length2 } = arguments;
    for (let i3 = 0, l2 = length2; i3 < l2; i3++) {
      const arg = arguments[i3];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = lastResult?.deref?.() ?? lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize: memoize2,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize2(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    let firstRun = true;
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      if (true) {
        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
        if (identityFunctionCheck.shouldRun) {
          identityFunctionCheck.run(
            resultFunc,
            inputSelectorResults,
            lastResult
          );
        }
        if (inputStabilityCheck.shouldRun) {
          const inputSelectorResultsCopy = collectInputSelectorResults(
            dependencies,
            arguments
          );
          inputStabilityCheck.run(
            { inputSelectorResults, inputSelectorResultsCopy },
            { memoize: memoize2, memoizeOptions: finalMemoizeOptions },
            arguments
          );
        }
        if (firstRun)
          firstRun = false;
      }
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize: memoize2,
      argsMemoize
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
var createSelector = createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key2) => inputSelectorsObject[key2]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index2) => {
          composition[inputSelectorKeys[index2]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);

// node_modules/redux-thunk/dist/redux-thunk.mjs
function createThunkMiddleware(extraArgument) {
  const middleware2 = ({ dispatch, getState }) => (next2) => (action) => {
    if (typeof action === "function") {
      return action(dispatch, getState, extraArgument);
    }
    return next2(action);
  };
  return middleware2;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;

// node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs
var createDraftSafeSelectorCreator = (...args) => {
  const createSelector2 = createSelectorCreator(...args);
  const createDraftSafeSelector2 = Object.assign((...args2) => {
    const selector = createSelector2(...args2);
    const wrappedSelector = (value, ...rest) => selector(isDraft(value) ? current(value) : value, ...rest);
    Object.assign(wrappedSelector, selector);
    return wrappedSelector;
  }, {
    withTypes: () => createDraftSafeSelector2
  });
  return createDraftSafeSelector2;
};
var createDraftSafeSelector = createDraftSafeSelectorCreator(weakMapMemoize);
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0) return void 0;
  if (typeof arguments[0] === "object") return compose;
  return compose.apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
  return function(noop32) {
    return noop32;
  };
};
var hasMatchFunction = (v2) => {
  return v2 && typeof v2.match === "function";
};
function createAction(type, prepareAction) {
  function actionCreator(...args) {
    if (prepareAction) {
      let prepared = prepareAction(...args);
      if (!prepared) {
        throw new Error(false ? formatProdErrorMessage(0) : "prepareAction did not return an object");
      }
      return {
        type,
        payload: prepared.payload,
        ..."meta" in prepared && {
          meta: prepared.meta
        },
        ..."error" in prepared && {
          error: prepared.error
        }
      };
    }
    return {
      type,
      payload: args[0]
    };
  }
  actionCreator.toString = () => `${type}`;
  actionCreator.type = type;
  actionCreator.match = (action) => isAction(action) && action.type === type;
  return actionCreator;
}
function isActionCreator(action) {
  return typeof action === "function" && "type" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  hasMatchFunction(action);
}
function getMessage(type) {
  const splitType = type ? `${type}`.split("/") : [];
  const actionName = splitType[splitType.length - 1] || "actionCreator";
  return `Detected an action creator with type "${type || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${actionName}())\` instead of \`dispatch(${actionName})\`. This is necessary even if the action has no payload.`;
}
function createActionCreatorInvariantMiddleware(options2 = {}) {
  if (false) {
    return () => (next2) => (action) => next2(action);
  }
  const {
    isActionCreator: isActionCreator2 = isActionCreator
  } = options2;
  return () => (next2) => (action) => {
    if (isActionCreator2(action)) {
      console.warn(getMessage(action.type));
    }
    return next2(action);
  };
}
function getTimeMeasureUtils(maxDelay, fnName) {
  let elapsed = 0;
  return {
    measureTime(fn2) {
      const started = Date.now();
      try {
        return fn2();
      } finally {
        const finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded() {
      if (elapsed > maxDelay) {
        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
      }
    }
  };
}
var Tuple = class _Tuple extends Array {
  constructor(...items) {
    super(...items);
    Object.setPrototypeOf(this, _Tuple.prototype);
  }
  static get [Symbol.species]() {
    return _Tuple;
  }
  concat(...arr) {
    return super.concat.apply(this, arr);
  }
  prepend(...arr) {
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _Tuple(...arr[0].concat(this));
    }
    return new _Tuple(...arr.concat(this));
  }
};
function freezeDraftable(val) {
  return isDraftable(val) ? produce(val, () => {
  }) : val;
}
function getOrInsertComputed(map2, key2, compute) {
  if (map2.has(key2)) return map2.get(key2);
  return map2.set(key2, compute(key2)).get(key2);
}
function isImmutableDefault(value) {
  return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations() {
      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}
function trackProperties(isImmutable, ignorePaths = [], obj, path = "", checkedObjects = /* @__PURE__ */ new Set()) {
  const tracked = {
    value: obj
  };
  if (!isImmutable(obj) && !checkedObjects.has(obj)) {
    checkedObjects.add(obj);
    tracked.children = {};
    for (const key2 in obj) {
      const childPath = path ? path + "." + key2 : key2;
      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
        continue;
      }
      tracked.children[key2] = trackProperties(isImmutable, ignorePaths, obj[key2], childPath);
    }
  }
  return tracked;
}
function detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = "") {
  const prevObj = trackedProperty ? trackedProperty.value : void 0;
  const sameRef = prevObj === obj;
  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return {
      wasMutated: true,
      path
    };
  }
  if (isImmutable(prevObj) || isImmutable(obj)) {
    return {
      wasMutated: false
    };
  }
  const keysToDetect = {};
  for (let key2 in trackedProperty.children) {
    keysToDetect[key2] = true;
  }
  for (let key2 in obj) {
    keysToDetect[key2] = true;
  }
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (let key2 in keysToDetect) {
    const nestedPath = path ? path + "." + key2 : key2;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key2], obj[key2], sameRef, nestedPath);
    if (result.wasMutated) {
      return result;
    }
  }
  return {
    wasMutated: false
  };
}
function createImmutableStateInvariantMiddleware(options2 = {}) {
  if (false) {
    return () => (next2) => (action) => next2(action);
  } else {
    let stringify22 = function(obj, serializer, indent, decycler) {
      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);
    }, getSerialize2 = function(serializer, decycler) {
      let stack = [], keys = [];
      if (!decycler) decycler = function(_, value) {
        if (stack[0] === value) return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key2, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key2) : keys.push(key2);
          if (~stack.indexOf(value)) value = decycler.call(this, key2, value);
        } else stack.push(value);
        return serializer == null ? value : serializer.call(this, key2, value);
      };
    };
    var stringify2 = stringify22, getSerialize = getSerialize2;
    let {
      isImmutable = isImmutableDefault,
      ignoredPaths,
      warnAfter = 32
    } = options2;
    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
    return ({
      getState
    }) => {
      let state = getState();
      let tracker = track(state);
      let result;
      return (next2) => (action) => {
        const measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(false ? formatProdErrorMessage(19) : `A state mutation was detected between dispatches, in the path '${result.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        const dispatchedAction = next2(action);
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(false ? formatProdErrorMessage(20) : `A state mutation was detected inside a dispatch, in the path: ${result.path || ""}. Take a look at the reducer(s) handling the action ${stringify22(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        measureUtils.warnIfExceeded();
        return dispatchedAction;
      };
    };
  }
}
function isPlain(val) {
  const type = typeof val;
  return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject(val);
}
function findNonSerializableValue(value, path = "", isSerializable = isPlain, getEntries, ignoredPaths = [], cache2) {
  let foundNestedSerializable;
  if (!isSerializable(value)) {
    return {
      keyPath: path || "<root>",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (cache2?.has(value)) return false;
  const entries = getEntries != null ? getEntries(value) : Object.entries(value);
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (const [key2, nestedValue] of entries) {
    const nestedPath = path ? path + "." + key2 : key2;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    if (!isSerializable(nestedValue)) {
      return {
        keyPath: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache2);
      if (foundNestedSerializable) {
        return foundNestedSerializable;
      }
    }
  }
  if (cache2 && isNestedFrozen(value)) cache2.add(value);
  return false;
}
function isNestedFrozen(value) {
  if (!Object.isFrozen(value)) return false;
  for (const nestedValue of Object.values(value)) {
    if (typeof nestedValue !== "object" || nestedValue === null) continue;
    if (!isNestedFrozen(nestedValue)) return false;
  }
  return true;
}
function createSerializableStateInvariantMiddleware(options2 = {}) {
  if (false) {
    return () => (next2) => (action) => next2(action);
  } else {
    const {
      isSerializable = isPlain,
      getEntries,
      ignoredActions = [],
      ignoredActionPaths = ["meta.arg", "meta.baseQueryMeta"],
      ignoredPaths = [],
      warnAfter = 32,
      ignoreState = false,
      ignoreActions = false,
      disableCache = false
    } = options2;
    const cache2 = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
    return (storeAPI) => (next2) => (action) => {
      if (!isAction(action)) {
        return next2(action);
      }
      const result = next2(action);
      const measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
        measureUtils.measureTime(() => {
          const foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache2);
          if (foundActionNonSerializableValue) {
            const {
              keyPath,
              value
            } = foundActionNonSerializableValue;
            console.error(`A non-serializable value was detected in an action, in the path: \`${keyPath}\`. Value:`, value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
          }
        });
      }
      if (!ignoreState) {
        measureUtils.measureTime(() => {
          const state = storeAPI.getState();
          const foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache2);
          if (foundStateNonSerializableValue) {
            const {
              keyPath,
              value
            } = foundStateNonSerializableValue;
            console.error(`A non-serializable value was detected in the state, in the path: \`${keyPath}\`. Value:`, value, `
Take a look at the reducer(s) handling this action type: ${action.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
          }
        });
        measureUtils.warnIfExceeded();
      }
      return result;
    };
  }
}
function isBoolean(x3) {
  return typeof x3 === "boolean";
}
var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options2) {
  const {
    thunk: thunk2 = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options2 ?? {};
  let middlewareArray = new Tuple();
  if (thunk2) {
    if (isBoolean(thunk2)) {
      middlewareArray.push(thunk);
    } else {
      middlewareArray.push(withExtraArgument(thunk2.extraArgument));
    }
  }
  if (true) {
    if (immutableCheck) {
      let immutableOptions = {};
      if (!isBoolean(immutableCheck)) {
        immutableOptions = immutableCheck;
      }
      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
    }
    if (serializableCheck) {
      let serializableOptions = {};
      if (!isBoolean(serializableCheck)) {
        serializableOptions = serializableCheck;
      }
      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
    }
    if (actionCreatorCheck) {
      let actionCreatorOptions = {};
      if (!isBoolean(actionCreatorCheck)) {
        actionCreatorOptions = actionCreatorCheck;
      }
      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
    }
  }
  return middlewareArray;
};
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var createQueueWithTimer = (timeout) => {
  return (notify) => {
    setTimeout(notify, timeout);
  };
};
var autoBatchEnhancer = (options2 = {
  type: "raf"
}) => (next2) => (...args) => {
  const store = next2(...args);
  let notifying = true;
  let shouldNotifyAtEndOfTick = false;
  let notificationQueued = false;
  const listeners = /* @__PURE__ */ new Set();
  const queueCallback = options2.type === "tick" ? queueMicrotask : options2.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
  ) : options2.type === "callback" ? options2.queueNotification : createQueueWithTimer(options2.timeout);
  const notifyListeners = () => {
    notificationQueued = false;
    if (shouldNotifyAtEndOfTick) {
      shouldNotifyAtEndOfTick = false;
      listeners.forEach((l2) => l2());
    }
  };
  return Object.assign({}, store, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(listener2) {
      const wrappedListener = () => notifying && listener2();
      const unsubscribe = store.subscribe(wrappedListener);
      listeners.add(listener2);
      return () => {
        unsubscribe();
        listeners.delete(listener2);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(action) {
      try {
        notifying = !action?.meta?.[SHOULD_AUTOBATCH];
        shouldNotifyAtEndOfTick = !notifying;
        if (shouldNotifyAtEndOfTick) {
          if (!notificationQueued) {
            notificationQueued = true;
            queueCallback(notifyListeners);
          }
        }
        return store.dispatch(action);
      } finally {
        notifying = true;
      }
    }
  });
};
var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options2) {
  const {
    autoBatch = true
  } = options2 ?? {};
  let enhancerArray = new Tuple(middlewareEnhancer);
  if (autoBatch) {
    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
  }
  return enhancerArray;
};
function configureStore(options2) {
  const getDefaultMiddleware = buildGetDefaultMiddleware();
  const {
    reducer: reducer2 = void 0,
    middleware: middleware2,
    devTools = true,
    duplicateMiddlewareCheck = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options2 || {};
  let rootReducer2;
  if (typeof reducer2 === "function") {
    rootReducer2 = reducer2;
  } else if (isPlainObject(reducer2)) {
    rootReducer2 = combineReducers(reducer2);
  } else {
    throw new Error(false ? formatProdErrorMessage(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
  }
  if (middleware2 && typeof middleware2 !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : "`middleware` field must be a callback");
  }
  let finalMiddleware;
  if (typeof middleware2 === "function") {
    finalMiddleware = middleware2(getDefaultMiddleware);
    if (!Array.isArray(finalMiddleware)) {
      throw new Error(false ? formatProdErrorMessage(3) : "when using a middleware builder function, an array of middleware must be returned");
    }
  } else {
    finalMiddleware = getDefaultMiddleware();
  }
  if (finalMiddleware.some((item) => typeof item !== "function")) {
    throw new Error(false ? formatProdErrorMessage(4) : "each middleware provided to configureStore must be a function");
  }
  if (duplicateMiddlewareCheck) {
    let middlewareReferences = /* @__PURE__ */ new Set();
    finalMiddleware.forEach((middleware22) => {
      if (middlewareReferences.has(middleware22)) {
        throw new Error(false ? formatProdErrorMessage(42) : "Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.");
      }
      middlewareReferences.add(middleware22);
    });
  }
  let finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: true,
      ...typeof devTools === "object" && devTools
    });
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
  if (enhancers && typeof enhancers !== "function") {
    throw new Error(false ? formatProdErrorMessage(5) : "`enhancers` field must be a callback");
  }
  let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
  if (!Array.isArray(storeEnhancers)) {
    throw new Error(false ? formatProdErrorMessage(6) : "`enhancers` callback must return an array");
  }
  if (storeEnhancers.some((item) => typeof item !== "function")) {
    throw new Error(false ? formatProdErrorMessage(7) : "each enhancer provided to configureStore must be a function");
  }
  if (finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {
    console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
  }
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore(rootReducer2, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer2) {
      if (true) {
        if (actionMatchers.length > 0) {
          throw new Error(false ? formatProdErrorMessage(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
        }
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
        }
      }
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error(false ? formatProdErrorMessage(28) : "`builder.addCase` cannot be called with an empty action type");
      }
      if (type in actionsMap) {
        throw new Error(false ? formatProdErrorMessage(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${type}'`);
      }
      actionsMap[type] = reducer2;
      return builder;
    },
    addAsyncThunk(asyncThunk, reducers2) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(43) : "`builder.addAsyncThunk` should only be called before calling `builder.addDefaultCase`");
        }
      }
      if (reducers2.pending) actionsMap[asyncThunk.pending.type] = reducers2.pending;
      if (reducers2.rejected) actionsMap[asyncThunk.rejected.type] = reducers2.rejected;
      if (reducers2.fulfilled) actionsMap[asyncThunk.fulfilled.type] = reducers2.fulfilled;
      if (reducers2.settled) actionMatchers.push({
        matcher: asyncThunk.settled,
        reducer: reducers2.settled
      });
      return builder;
    },
    addMatcher(matcher, reducer2) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
        }
      }
      actionMatchers.push({
        matcher,
        reducer: reducer2
      });
      return builder;
    },
    addDefaultCase(reducer2) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(31) : "`builder.addDefaultCase` can only be called once");
        }
      }
      defaultCaseReducer = reducer2;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x3) {
  return typeof x3 === "function";
}
function createReducer(initialState4, mapOrBuilderCallback) {
  if (true) {
    if (typeof mapOrBuilderCallback === "object") {
      throw new Error(false ? formatProdErrorMessage(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
    }
  }
  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
  let getInitialState;
  if (isStateFunction(initialState4)) {
    getInitialState = () => freezeDraftable(initialState4());
  } else {
    const frozenInitialState = freezeDraftable(initialState4);
    getInitialState = () => frozenInitialState;
  }
  function reducer2(state = getInitialState(), action) {
    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
      matcher
    }) => matcher(action)).map(({
      reducer: reducer22
    }) => reducer22)];
    if (caseReducers.filter((cr2) => !!cr2).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        if (isDraft(previousState)) {
          const draft = previousState;
          const result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!isDraftable(previousState)) {
          const result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return produce(previousState, (draft) => {
            return caseReducer(draft, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer2.getInitialState = getInitialState;
  return reducer2;
}
var matches = (matcher, action) => {
  if (hasMatchFunction(matcher)) {
    return matcher.match(action);
  } else {
    return matcher(action);
  }
};
function isAnyOf(...matchers) {
  return (action) => {
    return matchers.some((matcher) => matches(matcher, action));
  };
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid2 = (size2 = 21) => {
  let id = "";
  let i3 = size2;
  while (i3--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var commonProperties = ["name", "message", "stack", "code"];
var RejectWithValue = class {
  constructor(payload, meta) {
    this.payload = payload;
    this.meta = meta;
  }
  /*
  type-only property to distinguish between RejectWithValue and FulfillWithMeta
  does not exist at runtime
  */
  _type;
};
var FulfillWithMeta = class {
  constructor(payload, meta) {
    this.payload = payload;
    this.meta = meta;
  }
  /*
  type-only property to distinguish between RejectWithValue and FulfillWithMeta
  does not exist at runtime
  */
  _type;
};
var miniSerializeError = (value) => {
  if (typeof value === "object" && value !== null) {
    const simpleError = {};
    for (const property of commonProperties) {
      if (typeof value[property] === "string") {
        simpleError[property] = value[property];
      }
    }
    return simpleError;
  }
  return {
    message: String(value)
  };
};
var externalAbortMessage = "External signal was aborted";
var createAsyncThunk = (() => {
  function createAsyncThunk2(typePrefix, payloadCreator, options2) {
    const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
      payload,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "fulfilled"
      }
    }));
    const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
      payload: void 0,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "pending"
      }
    }));
    const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta) => ({
      payload,
      error: (options2 && options2.serializeError || miniSerializeError)(error || "Rejected"),
      meta: {
        ...meta || {},
        arg,
        requestId,
        rejectedWithValue: !!payload,
        requestStatus: "rejected",
        aborted: error?.name === "AbortError",
        condition: error?.name === "ConditionError"
      }
    }));
    function actionCreator(arg, {
      signal
    } = {}) {
      return (dispatch, getState, extra) => {
        const requestId = options2?.idGenerator ? options2.idGenerator(arg) : nanoid2();
        const abortController = new AbortController();
        let abortHandler;
        let abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        if (signal) {
          if (signal.aborted) {
            abort(externalAbortMessage);
          } else {
            signal.addEventListener("abort", () => abort(externalAbortMessage), {
              once: true
            });
          }
        }
        const promise = (async function() {
          let finalAction;
          try {
            let conditionResult = options2?.condition?.(arg, {
              getState,
              extra
            });
            if (isThenable(conditionResult)) {
              conditionResult = await conditionResult;
            }
            if (conditionResult === false || abortController.signal.aborted) {
              throw {
                name: "ConditionError",
                message: "Aborted due to condition callback returning false."
              };
            }
            const abortedPromise = new Promise((_, reject) => {
              abortHandler = () => {
                reject({
                  name: "AbortError",
                  message: abortReason || "Aborted"
                });
              };
              abortController.signal.addEventListener("abort", abortHandler);
            });
            dispatch(pending(requestId, arg, options2?.getPendingMeta?.({
              requestId,
              arg
            }, {
              getState,
              extra
            })));
            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
              dispatch,
              getState,
              extra,
              requestId,
              signal: abortController.signal,
              abort,
              rejectWithValue: (value, meta) => {
                return new RejectWithValue(value, meta);
              },
              fulfillWithValue: (value, meta) => {
                return new FulfillWithMeta(value, meta);
              }
            })).then((result) => {
              if (result instanceof RejectWithValue) {
                throw result;
              }
              if (result instanceof FulfillWithMeta) {
                return fulfilled(result.payload, requestId, arg, result.meta);
              }
              return fulfilled(result, requestId, arg);
            })]);
          } catch (err) {
            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
          } finally {
            if (abortHandler) {
              abortController.signal.removeEventListener("abort", abortHandler);
            }
          }
          const skipDispatch = options2 && !options2.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
          if (!skipDispatch) {
            dispatch(finalAction);
          }
          return finalAction;
        })();
        return Object.assign(promise, {
          abort,
          requestId,
          arg,
          unwrap() {
            return promise.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      settled: isAnyOf(rejected, fulfilled),
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = () => createAsyncThunk2;
  return createAsyncThunk2;
})();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
var asyncThunkSymbol = Symbol.for("rtk-slice-createasyncthunk");
var asyncThunkCreator = {
  [asyncThunkSymbol]: createAsyncThunk
};
var ReducerType = ((ReducerType2) => {
  ReducerType2["reducer"] = "reducer";
  ReducerType2["reducerWithPrepare"] = "reducerWithPrepare";
  ReducerType2["asyncThunk"] = "asyncThunk";
  return ReducerType2;
})(ReducerType || {});
function getType(slice2, actionKey) {
  return `${slice2}/${actionKey}`;
}
function buildCreateSlice({
  creators
} = {}) {
  const cAT = creators?.asyncThunk?.[asyncThunkSymbol];
  return function createSlice2(options2) {
    const {
      name,
      reducerPath = name
    } = options2;
    if (!name) {
      throw new Error(false ? formatProdErrorMessage(11) : "`name` is a required option for createSlice");
    }
    if (typeof process !== "undefined" && true) {
      if (options2.initialState === void 0) {
        console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
      }
    }
    const reducers2 = (typeof options2.reducers === "function" ? options2.reducers(buildReducerCreators()) : options2.reducers) || {};
    const reducerNames = Object.keys(reducers2);
    const context = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    };
    const contextMethods = {
      addCase(typeOrActionCreator, reducer22) {
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(false ? formatProdErrorMessage(12) : "`context.addCase` cannot be called with an empty action type");
        }
        if (type in context.sliceCaseReducersByType) {
          throw new Error(false ? formatProdErrorMessage(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + type);
        }
        context.sliceCaseReducersByType[type] = reducer22;
        return contextMethods;
      },
      addMatcher(matcher, reducer22) {
        context.sliceMatchers.push({
          matcher,
          reducer: reducer22
        });
        return contextMethods;
      },
      exposeAction(name2, actionCreator) {
        context.actionCreators[name2] = actionCreator;
        return contextMethods;
      },
      exposeCaseReducer(name2, reducer22) {
        context.sliceCaseReducersByName[name2] = reducer22;
        return contextMethods;
      }
    };
    reducerNames.forEach((reducerName) => {
      const reducerDefinition = reducers2[reducerName];
      const reducerDetails = {
        reducerName,
        type: getType(name, reducerName),
        createNotation: typeof options2.reducers === "function"
      };
      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
      } else {
        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
      }
    });
    function buildReducer() {
      if (true) {
        if (typeof options2.extraReducers === "object") {
          throw new Error(false ? formatProdErrorMessage(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
        }
      }
      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options2.extraReducers === "function" ? executeReducerBuilderCallback(options2.extraReducers) : [options2.extraReducers];
      const finalCaseReducers = {
        ...extraReducers,
        ...context.sliceCaseReducersByType
      };
      return createReducer(options2.initialState, (builder) => {
        for (let key2 in finalCaseReducers) {
          builder.addCase(key2, finalCaseReducers[key2]);
        }
        for (let sM of context.sliceMatchers) {
          builder.addMatcher(sM.matcher, sM.reducer);
        }
        for (let m2 of actionMatchers) {
          builder.addMatcher(m2.matcher, m2.reducer);
        }
        if (defaultCaseReducer) {
          builder.addDefaultCase(defaultCaseReducer);
        }
      });
    }
    const selectSelf = (state) => state;
    const injectedSelectorCache = /* @__PURE__ */ new Map();
    const injectedStateCache = /* @__PURE__ */ new WeakMap();
    let _reducer;
    function reducer2(state, action) {
      if (!_reducer) _reducer = buildReducer();
      return _reducer(state, action);
    }
    function getInitialState() {
      if (!_reducer) _reducer = buildReducer();
      return _reducer.getInitialState();
    }
    function makeSelectorProps(reducerPath2, injected = false) {
      function selectSlice(state) {
        let sliceState = state[reducerPath2];
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);
          } else if (true) {
            throw new Error(false ? formatProdErrorMessage(15) : "selectSlice returned undefined for an uninjected slice reducer");
          }
        }
        return sliceState;
      }
      function getSelectors(selectState = selectSelf) {
        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
        return getOrInsertComputed(selectorCache, selectState, () => {
          const map2 = {};
          for (const [name2, selector] of Object.entries(options2.selectors ?? {})) {
            map2[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);
          }
          return map2;
        });
      }
      return {
        reducerPath: reducerPath2,
        getSelectors,
        get selectors() {
          return getSelectors(selectSlice);
        },
        selectSlice
      };
    }
    const slice2 = {
      name,
      reducer: reducer2,
      actions: context.actionCreators,
      caseReducers: context.sliceCaseReducersByName,
      getInitialState,
      ...makeSelectorProps(reducerPath),
      injectInto(injectable, {
        reducerPath: pathOpt,
        ...config
      } = {}) {
        const newReducerPath = pathOpt ?? reducerPath;
        injectable.inject({
          reducerPath: newReducerPath,
          reducer: reducer2
        }, config);
        return {
          ...slice2,
          ...makeSelectorProps(newReducerPath, true)
        };
      }
    };
    return slice2;
  };
}
function wrapSelector(selector, selectState, getInitialState, injected) {
  function wrapper(rootState, ...args) {
    let sliceState = selectState(rootState);
    if (typeof sliceState === "undefined") {
      if (injected) {
        sliceState = getInitialState();
      } else if (true) {
        throw new Error(false ? formatProdErrorMessage(16) : "selectState returned undefined for an uninjected slice reducer");
      }
    }
    return selector(sliceState, ...args);
  }
  wrapper.unwrapped = selector;
  return wrapper;
}
var createSlice = buildCreateSlice();
function buildReducerCreators() {
  function asyncThunk(payloadCreator, config) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator,
      ...config
    };
  }
  asyncThunk.withTypes = () => asyncThunk;
  return {
    reducer(caseReducer) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [caseReducer.name](...args) {
          return caseReducer(...args);
        }
      }[caseReducer.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(prepare, reducer2) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare,
        reducer: reducer2
      };
    },
    asyncThunk
  };
}
function handleNormalReducerDefinition({
  type,
  reducerName,
  createNotation
}, maybeReducerWithPrepare, context) {
  let caseReducer;
  let prepareCallback;
  if ("reducer" in maybeReducerWithPrepare) {
    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
      throw new Error(false ? formatProdErrorMessage(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
    }
    caseReducer = maybeReducerWithPrepare.reducer;
    prepareCallback = maybeReducerWithPrepare.prepare;
  } else {
    caseReducer = maybeReducerWithPrepare;
  }
  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "asyncThunk";
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
}
function handleThunkCaseReducerDefinition({
  type,
  reducerName
}, reducerDefinition, context, cAT) {
  if (!cAT) {
    throw new Error(false ? formatProdErrorMessage(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
  }
  const {
    payloadCreator,
    fulfilled,
    pending,
    rejected,
    settled,
    options: options2
  } = reducerDefinition;
  const thunk2 = cAT(type, payloadCreator, options2);
  context.exposeAction(reducerName, thunk2);
  if (fulfilled) {
    context.addCase(thunk2.fulfilled, fulfilled);
  }
  if (pending) {
    context.addCase(thunk2.pending, pending);
  }
  if (rejected) {
    context.addCase(thunk2.rejected, rejected);
  }
  if (settled) {
    context.addMatcher(thunk2.settled, settled);
  }
  context.exposeCaseReducer(reducerName, {
    fulfilled: fulfilled || noop,
    pending: pending || noop,
    rejected: rejected || noop,
    settled: settled || noop
  });
}
function noop() {
}
var listener = "listener";
var completed = "completed";
var cancelled = "cancelled";
var taskCancelled = `task-${cancelled}`;
var taskCompleted = `task-${completed}`;
var listenerCancelled = `${listener}-${cancelled}`;
var listenerCompleted = `${listener}-${completed}`;
var assertFunction = (func, expected) => {
  if (typeof func !== "function") {
    throw new TypeError(false ? formatProdErrorMessage(32) : `${expected} is not a function`);
  }
};
var {
  assign
} = Object;
var alm = "listenerMiddleware";
var getListenerEntryPropsFrom = (options2) => {
  let {
    type,
    actionCreator,
    matcher,
    predicate,
    effect
  } = options2;
  if (type) {
    predicate = createAction(type).match;
  } else if (actionCreator) {
    type = actionCreator.type;
    predicate = actionCreator.match;
  } else if (matcher) {
    predicate = matcher;
  } else if (predicate) {
  } else {
    throw new Error(false ? formatProdErrorMessage(21) : "Creating or removing a listener requires one of the known fields for matching an action");
  }
  assertFunction(effect, "options.listener");
  return {
    predicate,
    type,
    effect
  };
};
var createListenerEntry = assign((options2) => {
  const {
    type,
    predicate,
    effect
  } = getListenerEntryPropsFrom(options2);
  const entry = {
    id: nanoid2(),
    effect,
    type,
    predicate,
    pending: /* @__PURE__ */ new Set(),
    unsubscribe: () => {
      throw new Error(false ? formatProdErrorMessage(22) : "Unsubscribe not initialized");
    }
  };
  return entry;
}, {
  withTypes: () => createListenerEntry
});
var addListener = assign(createAction(`${alm}/add`), {
  withTypes: () => addListener
});
var clearAllListeners = createAction(`${alm}/removeAll`);
var removeListener = assign(createAction(`${alm}/remove`), {
  withTypes: () => removeListener
});
var ORIGINAL_STATE = Symbol.for("rtk-state-proxy-original");

// node_modules/redux-observable/dist/redux-observable.mjs
var StateObservable = class extends Observable {
  value;
  __notifier = new Subject();
  constructor(input$, initialState4) {
    super((subscriber) => {
      const subscription = this.__notifier.subscribe(subscriber);
      if (subscription && !subscription.closed) {
        subscriber.next(this.value);
      }
      return subscription;
    });
    this.value = initialState4;
    input$.subscribe((value) => {
      if (value !== this.value) {
        this.value = value;
        this.__notifier.next(value);
      }
    });
  }
};
function combineEpics(...epics) {
  const merger = (...args) => merge(
    ...epics.map((epic) => {
      const output$ = epic(...args);
      if (!output$) {
        throw new TypeError(
          `combineEpics: one of the provided Epics "${epic.name || "<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`
        );
      }
      return output$;
    })
  );
  try {
    Object.defineProperty(merger, "name", {
      value: `combineEpics(${epics.map((epic) => epic.name || "<anonymous>").join(", ")})`
    });
  } catch (e2) {
  }
  return merger;
}
var consoleWarn = typeof console === "object" && typeof console.warn === "function" ? console.warn.bind(console) : () => {
};
var warn = (msg) => {
  consoleWarn(`redux-observable | WARNING: ${msg}`);
};
function createEpicMiddleware(options2 = {}) {
  const QueueScheduler = queueScheduler.constructor;
  const uniqueQueueScheduler = new QueueScheduler(
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    queueScheduler.schedulerActionCtor
  );
  if (typeof options2 === "function") {
    throw new TypeError(
      "Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\n\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware"
    );
  }
  const epic$ = new Subject();
  let store;
  const epicMiddleware = (_store) => {
    if (store) {
      warn(
        "this middleware is already associated with a store. createEpicMiddleware should be called for every store.\n\nLearn more: https://goo.gl/2GQ7Da"
      );
    }
    store = _store;
    const actionSubject$ = new Subject();
    const stateSubject$ = new Subject();
    const action$ = actionSubject$.asObservable().pipe(observeOn(uniqueQueueScheduler));
    const state$ = new StateObservable(
      stateSubject$.pipe(observeOn(uniqueQueueScheduler)),
      store.getState()
    );
    const result$ = epic$.pipe(
      map((epic) => {
        const output$ = epic(action$, state$, options2.dependencies);
        if (!output$) {
          throw new TypeError(
            `Your root Epic "${epic.name || "<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`
          );
        }
        return output$;
      }),
      mergeMap(
        (output$) => from(output$).pipe(
          subscribeOn(uniqueQueueScheduler),
          observeOn(uniqueQueueScheduler)
        )
      )
    );
    result$.subscribe(store.dispatch);
    return (next2) => {
      return (action) => {
        const result = next2(action);
        stateSubject$.next(store.getState());
        actionSubject$.next(action);
        return result;
      };
    };
  };
  epicMiddleware.run = (rootEpic2) => {
    if (!store) {
      warn(
        "epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first."
      );
    }
    epic$.next(rootEpic2);
  };
  return epicMiddleware;
}
function ofType(...types) {
  const len = types.length;
  if (true) {
    if (len === 0) {
      warn("ofType was called without any types!");
    }
    if (types.some((key2) => key2 === null || key2 === void 0)) {
      warn("ofType was called with one or more undefined or null values!");
    }
  }
  return filter(
    len === 1 ? (action) => isAction(action) && action.type === types[0] : (action) => {
      if (isAction(action)) {
        for (let i3 = 0; i3 < len; i3++) {
          if (action.type === types[i3]) {
            return true;
          }
        }
      }
      return false;
    }
  );
}

// node_modules/sanity-plugin-media/dist/index.mjs
var import_pluralize = __toESM(require_pluralize(), 1);

// node_modules/@tanem/react-nprogress/dist/react-nprogress.esm.js
var React2 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var clamp3 = function clamp4(num, lower, upper) {
  num = num <= upper ? num : upper;
  num = num >= lower ? num : lower;
  return num;
};
var createQueue = function createQueue2() {
  var isRunning = false;
  var pending = [];
  var _next = function next2() {
    isRunning = true;
    var cb = pending.shift();
    if (cb) {
      return cb(_next);
    }
    isRunning = false;
  };
  var clear = function clear2() {
    isRunning = false;
    pending = [];
  };
  var enqueue = function enqueue2(cb) {
    pending.push(cb);
    if (!isRunning && pending.length === 1) {
      _next();
    }
  };
  return {
    clear,
    enqueue
  };
};
var createTimeout = function createTimeout2() {
  var handle;
  var cancel = function cancel2() {
    if (handle) {
      window.cancelAnimationFrame(handle);
    }
  };
  var schedule = function schedule2(callback, delay2) {
    var deltaTime;
    var start;
    var _frame = function frame(time) {
      start = start || time;
      deltaTime = time - start;
      if (deltaTime > delay2) {
        callback();
        return;
      }
      handle = window.requestAnimationFrame(_frame);
    };
    handle = window.requestAnimationFrame(_frame);
  };
  return {
    cancel,
    schedule
  };
};
var increment = function increment2(progress) {
  var amount = 0;
  if (progress >= 0 && progress < 0.2) {
    amount = 0.1;
  } else if (progress >= 0.2 && progress < 0.5) {
    amount = 0.04;
  } else if (progress >= 0.5 && progress < 0.8) {
    amount = 0.02;
  } else if (progress >= 0.8 && progress < 0.99) {
    amount = 5e-3;
  }
  return clamp3(progress + amount, 0, 0.994);
};
var useEffectOnce = function useEffectOnce2(effect) {
  (0, import_react3.useEffect)(effect, []);
};
var incrementParameter = function incrementParameter2(num) {
  return ++num % 1e6;
};
var useUpdate = function useUpdate2() {
  var _useState = (0, import_react3.useState)(0), setState = _useState[1];
  return (0, import_react3.useCallback)(function() {
    return setState(incrementParameter);
  }, []);
};
var useGetSetState = function useGetSetState2(initialState4) {
  if (initialState4 === void 0) {
    initialState4 = {};
  }
  var update = useUpdate();
  var state = (0, import_react3.useRef)(_extends({}, initialState4));
  var get2 = (0, import_react3.useCallback)(function() {
    return state.current;
  }, []);
  var set2 = (0, import_react3.useCallback)(function(patch) {
    if (!patch) {
      return;
    }
    Object.assign(state.current, patch);
    update();
  }, []);
  return [get2, set2];
};
var useFirstMountState = function useFirstMountState2() {
  var isFirst = (0, import_react3.useRef)(true);
  if (isFirst.current) {
    isFirst.current = false;
    return true;
  }
  return isFirst.current;
};
var useUpdateEffect = function useUpdateEffect2(effect, deps) {
  var isFirstMount = useFirstMountState();
  (0, import_react3.useEffect)(function() {
    if (!isFirstMount) {
      return effect();
    }
  }, deps);
};
var noop2 = function noop3() {
  return void 0;
};
var initialState = {
  isFinished: true,
  progress: 0,
  sideEffect: noop2
};
var useNProgress = function useNProgress2(_temp5) {
  var _ref3 = _temp5 === void 0 ? {} : _temp5, _ref$animationDuratio = _ref3.animationDuration, animationDuration = _ref$animationDuratio === void 0 ? 200 : _ref$animationDuratio, _ref$incrementDuratio = _ref3.incrementDuration, incrementDuration = _ref$incrementDuratio === void 0 ? 800 : _ref$incrementDuratio, _ref$isAnimating = _ref3.isAnimating, isAnimating = _ref$isAnimating === void 0 ? false : _ref$isAnimating, _ref$minimum = _ref3.minimum, minimum = _ref$minimum === void 0 ? 0.08 : _ref$minimum;
  var _useGetSetState = useGetSetState(initialState), get2 = _useGetSetState[0], setState = _useGetSetState[1];
  var queue = (0, import_react3.useRef)(null);
  var timeout = (0, import_react3.useRef)(null);
  useEffectOnce(function() {
    queue.current = createQueue();
    timeout.current = createTimeout();
  });
  var cleanup = (0, import_react3.useCallback)(function() {
    var _timeout$current, _queue$current;
    (_timeout$current = timeout.current) == null || _timeout$current.cancel();
    (_queue$current = queue.current) == null || _queue$current.clear();
  }, []);
  var set2 = (0, import_react3.useCallback)(function(n3) {
    var _queue$current4;
    n3 = clamp3(n3, minimum, 1);
    if (n3 === 1) {
      var _queue$current2, _queue$current3;
      cleanup();
      (_queue$current2 = queue.current) == null || _queue$current2.enqueue(function(next2) {
        setState({
          progress: n3,
          sideEffect: function sideEffect2() {
            var _timeout$current2;
            return (_timeout$current2 = timeout.current) == null ? void 0 : _timeout$current2.schedule(next2, animationDuration);
          }
        });
      });
      (_queue$current3 = queue.current) == null || _queue$current3.enqueue(function() {
        setState({
          isFinished: true,
          sideEffect: cleanup
        });
      });
      return;
    }
    (_queue$current4 = queue.current) == null || _queue$current4.enqueue(function(next2) {
      setState({
        isFinished: false,
        progress: n3,
        sideEffect: function sideEffect2() {
          var _timeout$current3;
          return (_timeout$current3 = timeout.current) == null ? void 0 : _timeout$current3.schedule(next2, animationDuration);
        }
      });
    });
  }, [animationDuration, cleanup, minimum, queue, setState, timeout]);
  var trickle = (0, import_react3.useCallback)(function() {
    set2(increment(get2().progress));
  }, [get2, set2]);
  var start = (0, import_react3.useCallback)(function() {
    var _work = function work() {
      var _queue$current5;
      trickle();
      (_queue$current5 = queue.current) == null || _queue$current5.enqueue(function(next2) {
        var _timeout$current4;
        (_timeout$current4 = timeout.current) == null || _timeout$current4.schedule(function() {
          _work();
          next2();
        }, incrementDuration);
      });
    };
    _work();
  }, [incrementDuration, queue, timeout, trickle]);
  var savedTrickle = (0, import_react3.useRef)(noop2);
  var sideEffect = get2().sideEffect;
  (0, import_react3.useEffect)(function() {
    savedTrickle.current = trickle;
  });
  useEffectOnce(function() {
    if (isAnimating) {
      start();
    }
    return cleanup;
  });
  useUpdateEffect(function() {
    get2().sideEffect();
  }, [get2, sideEffect]);
  useUpdateEffect(function() {
    if (!isAnimating) {
      set2(1);
    } else {
      setState(_extends({}, initialState, {
        sideEffect: start
      }));
    }
  }, [isAnimating, set2, setState, start]);
  return {
    animationDuration,
    isFinished: get2().isFinished,
    progress: get2().progress
  };
};

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e2, r3) {
  var t3 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e2);
    r3 && (o3 = o3.filter(function(r4) {
      return Object.getOwnPropertyDescriptor(e2, r4).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread2(e2) {
  for (var r3 = 1; r3 < arguments.length; r3++) {
    var t3 = null != arguments[r3] ? arguments[r3] : {};
    r3 % 2 ? ownKeys(Object(t3), true).forEach(function(r4) {
      _defineProperty(e2, r4, t3[r4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t3)) : ownKeys(Object(t3)).forEach(function(r4) {
      Object.defineProperty(e2, r4, Object.getOwnPropertyDescriptor(t3, r4));
    });
  }
  return e2;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r3) {
  if (Array.isArray(r3)) return r3;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r3, l2) {
  var t3 = null == r3 ? null : "undefined" != typeof Symbol && r3[Symbol.iterator] || r3["@@iterator"];
  if (null != t3) {
    var e2, n3, i3, u2, a2 = [], f2 = true, o3 = false;
    try {
      if (i3 = (t3 = t3.call(r3)).next, 0 === l2) {
        if (Object(t3) !== t3) return;
        f2 = false;
      } else for (; !(f2 = (e2 = i3.call(t3)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r4) {
      o3 = true, n3 = r4;
    } finally {
      try {
        if (!f2 && null != t3["return"] && (u2 = t3["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o3) throw n3;
      }
    }
    return a2;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r3, e2) {
  return _arrayWithHoles(r3) || _iterableToArrayLimit(r3, e2) || _unsupportedIterableToArray(r3, e2) || _nonIterableRest();
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e2, t3) {
  if (null == e2) return {};
  var o3, r3, i3 = _objectWithoutPropertiesLoose(e2, t3);
  if (Object.getOwnPropertySymbols) {
    var n3 = Object.getOwnPropertySymbols(e2);
    for (r3 = 0; r3 < n3.length; r3++) o3 = n3[r3], -1 === t3.indexOf(o3) && {}.propertyIsEnumerable.call(e2, o3) && (i3[o3] = e2[o3]);
  }
  return i3;
}

// node_modules/react-select/dist/useStateManager-7e1e8489.esm.js
var import_react4 = __toESM(require_react());
var _excluded = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref3) {
  var _ref$defaultInputValu = _ref3.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref3.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref3.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref3.inputValue, propsMenuIsOpen = _ref3.menuIsOpen, propsOnChange = _ref3.onChange, propsOnInputChange = _ref3.onInputChange, propsOnMenuClose = _ref3.onMenuClose, propsOnMenuOpen = _ref3.onMenuOpen, propsValue = _ref3.value, restSelectProps = _objectWithoutProperties(_ref3, _excluded);
  var _useState = (0, import_react4.useState)(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1];
  var _useState3 = (0, import_react4.useState)(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1];
  var _useState5 = (0, import_react4.useState)(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1];
  var onChange2 = (0, import_react4.useCallback)(function(value2, actionMeta) {
    if (typeof propsOnChange === "function") {
      propsOnChange(value2, actionMeta);
    }
    setStateValue(value2);
  }, [propsOnChange]);
  var onInputChange = (0, import_react4.useCallback)(function(value2, actionMeta) {
    var newValue;
    if (typeof propsOnInputChange === "function") {
      newValue = propsOnInputChange(value2, actionMeta);
    }
    setStateInputValue(newValue !== void 0 ? newValue : value2);
  }, [propsOnInputChange]);
  var onMenuOpen = (0, import_react4.useCallback)(function() {
    if (typeof propsOnMenuOpen === "function") {
      propsOnMenuOpen();
    }
    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = (0, import_react4.useCallback)(function() {
    if (typeof propsOnMenuClose === "function") {
      propsOnMenuClose();
    }
    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== void 0 ? propsValue : stateValue;
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    inputValue,
    menuIsOpen,
    onChange: onChange2,
    onInputChange,
    onMenuClose,
    onMenuOpen,
    value
  });
}

// node_modules/react-select/dist/react-select.esm.js
var React7 = __toESM(require_react());
var import_react10 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(r3) {
  if (Array.isArray(r3)) return _arrayLikeToArray(r3);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r3) {
  if ("undefined" != typeof Symbol && null != r3[Symbol.iterator] || null != r3["@@iterator"]) return Array.from(r3);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r3) {
  return _arrayWithoutHoles(r3) || _iterableToArray(r3) || _unsupportedIterableToArray(r3) || _nonIterableSpread();
}

// node_modules/react-select/dist/Select-ef7c0426.esm.js
var React6 = __toESM(require_react());
var import_react8 = __toESM(require_react());

// node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js
var React4 = __toESM(require_react());
var import_react5 = __toESM(require_react());

// node_modules/@emotion/sheet/dist/emotion-sheet.development.esm.js
var isDevelopment = true;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i3 = 0; i3 < document.styleSheets.length; i3++) {
    if (document.styleSheets[i3].ownerNode === tag) {
      return document.styleSheets[i3];
    }
  }
  return void 0;
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = (function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? !isDevelopment : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.insertionPoint = options2.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e2);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
})();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from2 = String.fromCharCode;
var assign2 = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign2(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from2(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference = ruleset(characters2, root, parent, index2, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from2(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset2, rules, points, type, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i3 = 0, j3 = 0, k2 = 0; i3 < index2; ++i3)
    for (var x3 = 0, y2 = substr(value, post + 1, post = abs(j3 = points[i3])), z = value; x3 < size2; ++x3)
      if (z = trim(j3 > 0 ? rule[x3] + " " + y2 : replace(y2, /&\f/g, rule[x3])))
        props[k2++] = z;
  return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from2(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i3 = 0; i3 < length2; i3++)
    output += callback(children[i3], i3, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i3 = 0; i3 < length2; i3++)
      output += collection[i3](element, index2, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func) {
  var cache2 = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache2.has(arg)) {
      return cache2.get(arg);
    }
    var ret = func(arg);
    cache2.set(arg, ret);
    return ret;
  };
};

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn2) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0) cache2[arg] = fn2(arg);
    return cache2[arg];
  };
}

// node_modules/@emotion/cache/dist/emotion-cache.browser.development.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      // fallthrough
      default:
        parsed[index2] += from2(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i3 = 0, k2 = 0; i3 < rules.length; i3++) {
    for (var j3 = 0; j3 < parentRules.length; j3++, k2++) {
      element.props[k2] = points[i3] ? rules[i3].replace(/&\f/g, parentRules[j3]) : parentRules[j3] + " " + rules[i3];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element) {
  return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache2) {
  return function(element, index2, children) {
    if (element.type !== "rule" || cache2.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element.parent;
      var commentContainer = isNested ? element.parent.children : (
        // global rule at the root level
        children
      );
      for (var i3 = commentContainer.length - 1; i3 >= 0; i3--) {
        var node2 = commentContainer[i3];
        if (node2.line < element.line) {
          break;
        }
        if (node2.column < element.column) {
          if (isIgnoringComment(node2)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index2, children) {
  for (var i3 = index2 - 1; i3 >= 0; i3--) {
    if (!isImportRule(children[i3])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element) {
  element.type = "";
  element.value = "";
  element["return"] = "";
  element.children = "";
  element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element, index2, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index2, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
function prefix2(value, length2) {
  switch (hash(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        // (s)tretch
        case 115:
          return ~indexof(value, "stretch") ? prefix2(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix2(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var getSourceMap;
{
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
  getSourceMap = function getSourceMap2(styles) {
    var matches2 = styles.match(sourceMapPattern);
    if (!matches2) return;
    return matches2[matches2.length - 1];
  };
}
var sourceMapPattern;
var createCache = function createCache2(options2) {
  var key2 = options2.key;
  if (!key2) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key2 === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  {
    if (/[^a-z-]/.test(key2)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key2 + '" was passed');
    }
  }
  var inserted = {};
  var container2;
  var nodesToHydrate = [];
  {
    container2 = options2.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key2 + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i3 = 1; i3 < attrib.length; i3++) {
          inserted[attrib[i3]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache2.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    }];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (getSourceMap) {
        var sourceMap = getSourceMap(serialized.styles);
        if (sourceMap) {
          currentSheet = {
            insert: function insert2(rule) {
              sheet.insert(rule + sourceMap);
            }
          };
        }
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key: key2,
    sheet: new StyleSheet({
      key: key2,
      container: container2,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};

// node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current2 = serialized;
    do {
      cache2.insert(serialized === current2 ? "." + className : "", current2, cache2.sheet, true);
      current2 = current2.next;
    } while (current2 !== void 0);
  }
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h2 = 0;
  var k2, i3 = 0, len = str.length;
  for (; len >= 4; ++i3, len -= 4) {
    k2 = str.charCodeAt(i3) & 255 | (str.charCodeAt(++i3) & 255) << 8 | (str.charCodeAt(++i3) & 255) << 16 | (str.charCodeAt(++i3) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i3 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i3 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i3) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js
var isDevelopment2 = true;
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key2, value) {
  switch (key2) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match3, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key2] !== 1 && !isCustomProperty(key2) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
{
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key2, value) {
    if (key2 === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key2, value);
    if (processed !== "" && !isCustomProperty(key2) && key2.indexOf("-") !== -1 && hyphenatedCache[key2] === void 0) {
      hyphenatedCache[key2] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key2.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    if (String(componentSelector) === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = serializedStyles.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(_match, _p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\ncss`" + replaced + "`");
        }
      }
      break;
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i3 = 0; i3 < obj.length; i3++) {
      string += handleInterpolation(mergedProps, registered, obj[i3]) + ";";
    }
  } else {
    for (var key2 in obj) {
      var value = obj[key2];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key2 + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key2) + ":" + processStyleValue(key2, asString) + ";";
        }
      } else {
        if (key2 === "NO_COMPONENT_SELECTOR" && isDevelopment2) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key2) + ":" + processStyleValue(key2, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key2) {
            case "animation":
            case "animationName": {
              string += processStyleName(key2) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (key2 === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += key2 + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings2 = args[0];
  if (strings2 == null || strings2.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings2);
  } else {
    var asTemplateStringsArr = strings2;
    if (asTemplateStringsArr[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += asTemplateStringsArr[0];
  }
  for (var i3 = 1; i3 < args.length; i3++) {
    styles += handleInterpolation(mergedProps, registered, args[i3]);
    if (stringMode) {
      var templateStringsArr = strings2;
      if (templateStringsArr[i3] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += templateStringsArr[i3];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match3;
  while ((match3 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match3[1];
  }
  var name = murmur2(styles) + identifierName;
  {
    var devStyles = {
      name,
      styles,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
    return devStyles;
  }
}

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var React3 = __toESM(require_react());
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect2 = React3["useInsertionEffect"] ? React3["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React3.useLayoutEffect;

// node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js
var EmotionCacheContext = React4.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? createCache({
    key: "css"
  }) : null
);
{
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return (0, import_react5.forwardRef)(function(props, ref) {
    var cache2 = (0, import_react5.useContext)(EmotionCacheContext);
    return func(props, cache2, ref);
  });
};
var ThemeContext2 = React4.createContext({});
{
  ThemeContext2.displayName = "EmotionThemeContext";
}
var getTheme = function getTheme2(outerTheme, theme) {
  if (typeof theme === "function") {
    var mergedTheme = theme(outerTheme);
    if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    }
    return mergedTheme;
  }
  if (theme == null || typeof theme !== "object" || Array.isArray(theme)) {
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  }
  return _extends({}, outerTheme, theme);
};
var createCacheWithTheme = weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme) {
    return getTheme(outerTheme, theme);
  });
});
var hasOwn = {}.hasOwnProperty;
var getLastPart = function getLastPart2(functionName) {
  var parts = functionName.split(".");
  return parts[parts.length - 1];
};
var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine2(line2) {
  var match3 = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line2);
  if (match3) return getLastPart(match3[1]);
  match3 = /^([A-Za-z0-9$.]+)@/.exec(line2);
  if (match3) return getLastPart(match3[1]);
  return void 0;
};
var internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
var sanitizeIdentifier = function sanitizeIdentifier2(identifier2) {
  return identifier2.replace(/\$/g, "-");
};
var getLabelFromStackTrace = function getLabelFromStackTrace2(stackTrace) {
  if (!stackTrace) return void 0;
  var lines = stackTrace.split("\n");
  for (var i3 = 0; i3 < lines.length; i3++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i3]);
    if (!functionName) continue;
    if (internalReactFunctionNames.has(functionName)) break;
    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);
  }
  return void 0;
};
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  if (typeof props.css === "string" && // check if there is a css declaration
  props.css.indexOf(":") !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
  }
  var newProps = {};
  for (var _key in props) {
    if (hasOwn.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type;
  if (typeof globalThis !== "undefined" && !!globalThis.EMOTION_RUNTIME_AUTO_LABEL && !!props.css && (typeof props.css !== "object" || !("name" in props.css) || typeof props.css.name !== "string" || props.css.name.indexOf("-") === -1)) {
    var label = getLabelFromStackTrace(new Error().stack);
    if (label) newProps[labelPropName] = label;
  }
  return newProps;
};
var Insertion = function Insertion2(_ref3) {
  var cache2 = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = withEmotionCache(function(props, cache2, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
    cssProp = cache2.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React4.useContext(ThemeContext2));
  if (serialized.name.indexOf("-") === -1) {
    var labelFromStack = props[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  className += cache2.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && _key2 !== labelPropName) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref) {
    newProps.ref = ref;
  }
  return React4.createElement(React4.Fragment, null, React4.createElement(Insertion, {
    cache: cache2,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), React4.createElement(WrappedComponent, newProps));
});
{
  Emotion.displayName = "EmotionCssPropInternal";
}
var Emotion$1 = Emotion;

// node_modules/@emotion/react/dist/emotion-react.browser.development.esm.js
var React5 = __toESM(require_react());
var import_hoist_non_react_statics3 = __toESM(require_hoist_non_react_statics_cjs());
var isDevelopment3 = true;
var pkg = {
  name: "@emotion/react",
  version: "11.14.0",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  types: "dist/emotion-react.cjs.d.ts",
  exports: {
    ".": {
      types: {
        "import": "./dist/emotion-react.cjs.mjs",
        "default": "./dist/emotion-react.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        worker: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        browser: {
          module: "./dist/emotion-react.browser.development.esm.js",
          "import": "./dist/emotion-react.browser.development.cjs.mjs",
          "default": "./dist/emotion-react.browser.development.cjs.js"
        },
        module: "./dist/emotion-react.development.esm.js",
        "import": "./dist/emotion-react.development.cjs.mjs",
        "default": "./dist/emotion-react.development.cjs.js"
      },
      "edge-light": {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      worker: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      workerd: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      browser: {
        module: "./dist/emotion-react.browser.esm.js",
        "import": "./dist/emotion-react.browser.cjs.mjs",
        "default": "./dist/emotion-react.browser.cjs.js"
      },
      module: "./dist/emotion-react.esm.js",
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      types: {
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.js"
        },
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.js"
      },
      module: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js",
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      types: {
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        worker: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        browser: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.js"
        },
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.js"
      },
      "edge-light": {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      worker: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      workerd: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      browser: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.js"
      },
      module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js",
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      types: {
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.js"
        },
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.js"
      },
      module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js",
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  imports: {
    "#is-development": {
      development: "./src/conditions/true.ts",
      "default": "./src/conditions/false.ts"
    },
    "#is-browser": {
      "edge-light": "./src/conditions/false.ts",
      workerd: "./src/conditions/false.ts",
      worker: "./src/conditions/false.ts",
      browser: "./src/conditions/true.ts",
      "default": "./src/conditions/is-browser.ts"
    }
  },
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/css-prop.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.13.5",
    "@emotion/cache": "^11.14.0",
    "@emotion/serialize": "^1.3.3",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.2.0",
    "@emotion/utils": "^1.4.2",
    "@emotion/weak-memoize": "^0.4.0",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.13.5",
    "@emotion/css-prettifier": "1.2.0",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.14.0",
    "@types/hoist-non-react-statics": "^3.3.5",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^5.4.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.ts",
      "./jsx-runtime.ts",
      "./jsx-dev-runtime.ts",
      "./_isolated-hnrs.ts"
    ],
    umdName: "emotionReact",
    exports: {
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var jsx3 = function jsx4(type, props) {
  var args = arguments;
  if (props == null || !hasOwn.call(props, "css")) {
    return React5.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i3 = 2; i3 < argsLength; i3++) {
    createElementArgArray[i3] = args[i3];
  }
  return React5.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx3 || (jsx3 = {}));
var warnedAboutCssPropForGlobal = false;
var Global = withEmotionCache(function(props, cache2) {
  if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // I don't really want to add it to the type since it shouldn't be used
  ("className" in props && props.className || "css" in props && props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles = props.styles;
  var serialized = serializeStyles([styles], void 0, React5.useContext(ThemeContext2));
  var sheetRef = React5.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key2 = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key: key2,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key2 + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key2);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
{
  Global.displayName = "EmotionGlobal";
}
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var classnames = function classnames2(args) {
  var len = args.length;
  var i3 = 0;
  var cls = "";
  for (; i3 < len; i3++) {
    var arg = args[i3];
    if (arg == null) continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k2 in arg) {
            if (arg[k2] && k2) {
              toAdd && (toAdd += " ");
              toAdd += k2;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge3(registered, css5, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css5(registeredStyles);
}
var Insertion3 = function Insertion4(_ref3) {
  var cache2 = _ref3.cache, serializedArr = _ref3.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i3 = 0; i3 < serializedArr.length; i3++) {
      insertStyles(cache2, serializedArr[i3], false);
    }
  });
  return null;
};
var ClassNames = withEmotionCache(function(props, cache2) {
  var hasRendered = false;
  var serializedArr = [];
  var css5 = function css6() {
    if (hasRendered && isDevelopment3) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache2.registered);
    serializedArr.push(serialized);
    registerStyles(cache2, serialized, false);
    return cache2.key + "-" + serialized.name;
  };
  var cx = function cx2() {
    if (hasRendered && isDevelopment3) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge3(cache2.registered, css5, classnames(args));
  };
  var content2 = {
    css: css5,
    cx,
    theme: React5.useContext(ThemeContext2)
  };
  var ele = props.children(content2);
  hasRendered = true;
  return React5.createElement(React5.Fragment, null, React5.createElement(Insertion3, {
    cache: cache2,
    serializedArr
  }), ele);
});
{
  ClassNames.displayName = "EmotionClassNames";
}
{
  isBrowser2 = typeof document !== "undefined";
  isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser2 && !isTestEnv) {
    globalContext = typeof globalThis !== "undefined" ? globalThis : isBrowser2 ? window : global;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser2;
var isTestEnv;
var globalContext;
var globalKey;

// node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js
function _taggedTemplateLiteral(e2, t3) {
  return t3 || (t3 = e2.slice(0)), Object.freeze(Object.defineProperties(e2, {
    raw: {
      value: Object.freeze(t3)
    }
  }));
}

// node_modules/react-select/dist/index-641ee5b8.esm.js
var import_react7 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());
var _excluded$4 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
var noop4 = function noop5() {
};
function applyPrefixToName(prefix3, name) {
  if (!name) {
    return prefix3;
  } else if (name[0] === "-") {
    return prefix3 + name;
  } else {
    return prefix3 + "__" + name;
  }
}
function classNames(prefix3, state) {
  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    classNameList[_key - 2] = arguments[_key];
  }
  var arr = [].concat(classNameList);
  if (state && prefix3) {
    for (var key2 in state) {
      if (state.hasOwnProperty(key2) && state[key2]) {
        arr.push("".concat(applyPrefixToName(prefix3, key2)));
      }
    }
  }
  return arr.filter(function(i3) {
    return i3;
  }).map(function(i3) {
    return String(i3).trim();
  }).join(" ");
}
var cleanValue = function cleanValue2(value) {
  if (isArray(value)) return value.filter(Boolean);
  if (_typeof(value) === "object" && value !== null) return [value];
  return [];
};
var cleanCommonProps = function cleanCommonProps2(props) {
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getClassNames;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = _objectWithoutProperties(props, _excluded$4);
  return _objectSpread2({}, innerProps);
};
var getStyleProps = function getStyleProps2(props, name, classNamesState) {
  var cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, className = props.className;
  return {
    css: getStyles(name, props),
    className: cx(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name, props), className)
  };
};
function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
}
function normalizedHeight(el) {
  if (isDocumentElement(el)) {
    return window.innerHeight;
  }
  return el.clientHeight;
}
function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }
  return el.scrollTop;
}
function scrollTo(el, top) {
  if (isDocumentElement(el)) {
    window.scrollTo(0, top);
    return;
  }
  el.scrollTop = top;
}
function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === "absolute";
  var overflowRx = /(auto|scroll)/;
  if (style.position === "fixed") return document.documentElement;
  for (var parent = element; parent = parent.parentElement; ) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === "static") {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
}
function easeOutCubic(t3, b2, c4, d2) {
  return c4 * ((t3 = t3 / d2 - 1) * t3 * t3 + 1) + b2;
}
function animatedScrollTo(element, to2) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop4;
  var start = getScrollTop(element);
  var change = to2 - start;
  var increment3 = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment3;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
}
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
function isTouchCapable() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e2) {
    return false;
  }
}
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e2) {
    return false;
  }
}
var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
var w = typeof window !== "undefined" ? window : {};
if (w.addEventListener && w.removeEventListener) {
  w.addEventListener("p", noop4, options);
  w.removeEventListener("p", noop4, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item) {
  return item != null;
}
function isArray(arg) {
  return Array.isArray(arg);
}
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
function singleValueAsValue(singleValue) {
  return singleValue;
}
function multiValueAsValue(multiValue) {
  return multiValue;
}
var removeProps = function removeProps2(propsObj) {
  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    properties[_key2 - 1] = arguments[_key2];
  }
  var propsMap = Object.entries(propsObj).filter(function(_ref3) {
    var _ref23 = _slicedToArray(_ref3, 1), key2 = _ref23[0];
    return !properties.includes(key2);
  });
  return propsMap.reduce(function(newProps, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key2 = _ref4[0], val = _ref4[1];
    newProps[key2] = val;
    return newProps;
  }, {});
};
var _excluded$3 = ["children", "innerProps"];
var _excluded2$1 = ["children", "innerProps"];
function getMenuPlacement(_ref3) {
  var preferredMaxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, preferredPlacement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, controlHeight2 = _ref3.controlHeight;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: "bottom",
    maxHeight: preferredMaxHeight
  };
  if (!menuEl || !menuEl.offsetParent) return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (preferredPlacement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (preferredPlacement === "auto" || isFixedPosition) {
        var _constrainedHeight = preferredMaxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight2, preferredMaxHeight);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (preferredPlacement === "bottom") {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
  }
  return defaultState;
}
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
var coercePlacement = function coercePlacement2(p2) {
  return p2 === "auto" ? "bottom" : p2;
};
var menuCSS = function menuCSS2(_ref23, unstyled) {
  var _objectSpread22;
  var placement = _ref23.placement, _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors3 = _ref2$theme.colors;
  return _objectSpread2((_objectSpread22 = {
    label: "menu"
  }, _defineProperty(_objectSpread22, alignToControl(placement), "100%"), _defineProperty(_objectSpread22, "position", "absolute"), _defineProperty(_objectSpread22, "width", "100%"), _defineProperty(_objectSpread22, "zIndex", 1), _objectSpread22), unstyled ? {} : {
    backgroundColor: colors3.neutral0,
    borderRadius: borderRadius2,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: spacing2.menuGutter,
    marginTop: spacing2.menuGutter
  });
};
var PortalPlacementContext = (0, import_react7.createContext)(null);
var MenuPlacer = function MenuPlacer2(props) {
  var children = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView, theme = props.theme;
  var _ref3 = (0, import_react7.useContext)(PortalPlacementContext) || {}, setPortalPlacement = _ref3.setPortalPlacement;
  var ref = (0, import_react7.useRef)(null);
  var _useState = (0, import_react7.useState)(maxMenuHeight), _useState2 = _slicedToArray(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1];
  var _useState3 = (0, import_react7.useState)(null), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1];
  var controlHeight2 = theme.spacing.controlHeight;
  index(function() {
    var menuEl = ref.current;
    if (!menuEl) return;
    var isFixedPosition = menuPosition === "fixed";
    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
    var state = getMenuPlacement({
      maxHeight: maxMenuHeight,
      menuEl,
      minHeight: minMenuHeight,
      placement: menuPlacement,
      shouldScroll,
      isFixedPosition,
      controlHeight: controlHeight2
    });
    setMaxHeight(state.maxHeight);
    setPlacement(state.placement);
    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state.placement);
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight2]);
  return children({
    ref,
    placerProps: _objectSpread2(_objectSpread2({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight
    })
  });
};
var Menu2 = function Menu3(props) {
  var children = props.children, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx3("div", _extends({}, getStyleProps(props, "menu", {
    menu: true
  }), {
    ref: innerRef
  }, innerProps), children);
};
var Menu$1 = Menu2;
var menuListCSS = function menuListCSS2(_ref4, unstyled) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return _objectSpread2({
    maxHeight,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, unstyled ? {} : {
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2
  });
};
var MenuList = function MenuList2(props) {
  var children = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx3("div", _extends({}, getStyleProps(props, "menuList", {
    "menu-list": true,
    "menu-list--is-multi": isMulti
  }), {
    ref: innerRef
  }, innerProps), children);
};
var noticeCSS = function noticeCSS2(_ref5, unstyled) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors3 = _ref5$theme.colors;
  return _objectSpread2({
    textAlign: "center"
  }, unstyled ? {} : {
    color: colors3.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px")
  });
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage2(_ref6) {
  var _ref6$children = _ref6.children, children = _ref6$children === void 0 ? "No options" : _ref6$children, innerProps = _ref6.innerProps, restProps = _objectWithoutProperties(_ref6, _excluded$3);
  return jsx3("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children,
    innerProps
  }), "noOptionsMessage", {
    "menu-notice": true,
    "menu-notice--no-options": true
  }), innerProps), children);
};
var LoadingMessage = function LoadingMessage2(_ref7) {
  var _ref7$children = _ref7.children, children = _ref7$children === void 0 ? "Loading..." : _ref7$children, innerProps = _ref7.innerProps, restProps = _objectWithoutProperties(_ref7, _excluded2$1);
  return jsx3("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children,
    innerProps
  }), "loadingMessage", {
    "menu-notice": true,
    "menu-notice--loading": true
  }), innerProps), children);
};
var menuPortalCSS = function menuPortalCSS2(_ref8) {
  var rect = _ref8.rect, offset2 = _ref8.offset, position2 = _ref8.position;
  return {
    left: rect.left,
    position: position2,
    top: offset2,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = function MenuPortal2(props) {
  var appendTo = props.appendTo, children = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition;
  var menuPortalRef = (0, import_react7.useRef)(null);
  var cleanupRef = (0, import_react7.useRef)(null);
  var _useState5 = (0, import_react7.useState)(coercePlacement(menuPlacement)), _useState6 = _slicedToArray(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1];
  var portalPlacementContext = (0, import_react7.useMemo)(function() {
    return {
      setPortalPlacement
    };
  }, []);
  var _useState7 = (0, import_react7.useState)(null), _useState8 = _slicedToArray(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1];
  var updateComputedPosition = (0, import_react7.useCallback)(function() {
    if (!controlElement) return;
    var rect = getBoundingClientObj(controlElement);
    var scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset;
    var offset2 = rect[placement] + scrollDistance;
    if (offset2 !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
      setComputedPosition({
        offset: offset2,
        rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
  index(function() {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = (0, import_react7.useCallback)(function() {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (controlElement && menuPortalRef.current) {
      cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
        elementResize: "ResizeObserver" in window
      });
    }
  }, [controlElement, updateComputedPosition]);
  index(function() {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = (0, import_react7.useCallback)(function(menuPortalElement) {
    menuPortalRef.current = menuPortalElement;
    runAutoUpdate();
  }, [runAutoUpdate]);
  if (!appendTo && menuPosition !== "fixed" || !computedPosition) return null;
  var menuWrapper = jsx3("div", _extends({
    ref: setMenuPortalElement
  }, getStyleProps(_objectSpread2(_objectSpread2({}, props), {}, {
    offset: computedPosition.offset,
    position: menuPosition,
    rect: computedPosition.rect
  }), "menuPortal", {
    "menu-portal": true
  }), innerProps), children);
  return jsx3(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? (0, import_react_dom3.createPortal)(menuWrapper, appendTo) : menuWrapper);
};
var containerCSS = function containerCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : void 0,
    pointerEvents: isDisabled ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
};
var SelectContainer = function SelectContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx3("div", _extends({}, getStyleProps(props, "container", {
    "--is-disabled": isDisabled,
    "--is-rtl": isRtl
  }), innerProps), children);
};
var valueContainerCSS = function valueContainerCSS2(_ref23, unstyled) {
  var spacing2 = _ref23.theme.spacing, isMulti = _ref23.isMulti, hasValue = _ref23.hasValue, controlShouldRenderValue = _ref23.selectProps.controlShouldRenderValue;
  return _objectSpread2({
    alignItems: "center",
    display: isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, unstyled ? {} : {
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px")
  });
};
var ValueContainer = function ValueContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue;
  return jsx3("div", _extends({}, getStyleProps(props, "valueContainer", {
    "value-container": true,
    "value-container--is-multi": isMulti,
    "value-container--has-value": hasValue
  }), innerProps), children);
};
var indicatorsContainerCSS = function indicatorsContainerCSS2() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx3("div", _extends({}, getStyleProps(props, "indicatorsContainer", {
    indicators: true
  }), innerProps), children);
};
var _templateObject;
var _excluded$2 = ["size"];
var _excluded2 = ["innerProps", "isRtl", "size"];
function _EMOTION_STRINGIFIED_CSS_ERROR__() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref2 = false ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHtcbiAgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWUsXG4gIENTU09iamVjdFdpdGhMYWJlbCxcbiAgR3JvdXBCYXNlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRTdHlsZVByb3BzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgSWNvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTdmcgPSAoe1xuICBzaXplLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IHR5cGUgQ3Jvc3NJY29uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBDcm9zc0ljb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNMTQuMzQ4IDE0Ljg0OWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMGwtMi42NTEtMy4wMzAtMi42NTEgMy4wMjljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDAtMC40NjktMC40NjktMC40NjktMS4yMjkgMC0xLjY5N2wyLjc1OC0zLjE1LTIuNzU5LTMuMTUyYy0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOCAwLTEuNjk3czEuMjI4LTAuNDY5IDEuNjk3IDBsMi42NTIgMy4wMzEgMi42NTEtMy4wMzFjMC40NjktMC40NjkgMS4yMjgtMC40NjkgMS42OTcgMHMwLjQ2OSAxLjIyOSAwIDEuNjk3bC0yLjc1OCAzLjE1MiAyLjc1OCAzLjE1YzAuNDY5IDAuNDY5IDAuNDY5IDEuMjI5IDAgMS42OTh6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuZXhwb3J0IHR5cGUgRG93bkNoZXZyb25Qcm9wcyA9IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogRG93bkNoZXZyb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J107XG4gIC8qKiBUaGUgZm9jdXNlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGJhc2VDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgdGhlbWU6IHtcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICAgIGNvbG9ycyxcbiAgICB9LFxuICB9OlxuICAgIHwgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuICAgIHwgQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgLi4uKHVuc3R5bGVkXG4gICAgPyB7fVxuICAgIDoge1xuICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnZHJvcGRvd25JbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2Ryb3Bkb3duLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsZWFySW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnY2xlYXJJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGljYXRvclNlcGFyYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpbm5lclByb3BzPzogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ107XG59XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0Rpc2FibGVkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgd2lkdGg6IDEsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICAgICAgICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgICAgIH0pLFxufSk7XG5cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JTZXBhcmF0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgey4uLmdldFN0eWxlUHJvcHMocHJvcHMsICdpbmRpY2F0b3JTZXBhcmF0b3InLCB7XG4gICAgICAgICdpbmRpY2F0b3Itc2VwYXJhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgIC8+XG4gICk7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExvYWRpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBsb2FkaW5nRG90QW5pbWF0aW9ucyA9IGtleWZyYW1lc2BcbiAgMCUsIDgwJSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgNDAlIHsgb3BhY2l0eTogMTsgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmdJbmRpY2F0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgc2l6ZSxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzLFxuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIH0sXG4gIH06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIGFsaWduU2VsZjogJ2NlbnRlcicsXG4gIGZvbnRTaXplOiBzaXplLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBtYXJnaW5SaWdodDogc2l6ZSxcbiAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5pbnRlcmZhY2UgTG9hZGluZ0RvdFByb3BzIHtcbiAgZGVsYXk6IG51bWJlcjtcbiAgb2Zmc2V0OiBib29sZWFuO1xufVxuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogTG9hZGluZ0RvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGluZ0luZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgc2l6ZTogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpbm5lclByb3BzLFxuICBpc1J0bCxcbiAgc2l6ZSA9IDQsXG4gIC4uLnJlc3RQcm9wc1xufTogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgey4uLmdldFN0eWxlUHJvcHMoXG4gICAgICAgIHsgLi4ucmVzdFByb3BzLCBpbm5lclByb3BzLCBpc1J0bCwgc2l6ZSB9LFxuICAgICAgICAnbG9hZGluZ0luZGljYXRvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
var Svg = function Svg2(_ref3) {
  var size2 = _ref3.size, props = _objectWithoutProperties(_ref3, _excluded$2);
  return jsx3("svg", _extends({
    height: size2,
    width: size2,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2
  }, props));
};
var CrossIcon = function CrossIcon2(props) {
  return jsx3(Svg, _extends({
    size: 20
  }, props), jsx3("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron2(props) {
  return jsx3(Svg, _extends({
    size: 20
  }, props), jsx3("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var baseCSS = function baseCSS2(_ref3, unstyled) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors3 = _ref3$theme.colors;
  return _objectSpread2({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, unstyled ? {} : {
    color: isFocused ? colors3.neutral60 : colors3.neutral20,
    padding: baseUnit2 * 2,
    ":hover": {
      color: isFocused ? colors3.neutral80 : colors3.neutral40
    }
  });
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx3("div", _extends({}, getStyleProps(props, "dropdownIndicator", {
    indicator: true,
    "dropdown-indicator": true
  }), innerProps), children || jsx3(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx3("div", _extends({}, getStyleProps(props, "clearIndicator", {
    indicator: true,
    "clear-indicator": true
  }), innerProps), children || jsx3(CrossIcon, null));
};
var indicatorSeparatorCSS = function indicatorSeparatorCSS2(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors3 = _ref4$theme.colors;
  return _objectSpread2({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors3.neutral10 : colors3.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2
  });
};
var IndicatorSeparator = function IndicatorSeparator2(props) {
  var innerProps = props.innerProps;
  return jsx3("span", _extends({}, innerProps, getStyleProps(props, "indicatorSeparator", {
    "indicator-separator": true
  })));
};
var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS2(_ref5, unstyled) {
  var isFocused = _ref5.isFocused, size2 = _ref5.size, _ref5$theme = _ref5.theme, colors3 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return _objectSpread2({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size2,
    lineHeight: 1,
    marginRight: size2,
    textAlign: "center",
    verticalAlign: "middle"
  }, unstyled ? {} : {
    color: isFocused ? colors3.neutral60 : colors3.neutral20,
    padding: baseUnit2 * 2
  });
};
var LoadingDot = function LoadingDot2(_ref6) {
  var delay2 = _ref6.delay, offset2 = _ref6.offset;
  return jsx3("span", {
    css: css({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay2, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset2 ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, false ? "" : ";label:LoadingDot;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1RSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHtcbiAgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWUsXG4gIENTU09iamVjdFdpdGhMYWJlbCxcbiAgR3JvdXBCYXNlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRTdHlsZVByb3BzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgSWNvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTdmcgPSAoe1xuICBzaXplLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IHR5cGUgQ3Jvc3NJY29uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBDcm9zc0ljb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNMTQuMzQ4IDE0Ljg0OWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMGwtMi42NTEtMy4wMzAtMi42NTEgMy4wMjljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDAtMC40NjktMC40NjktMC40NjktMS4yMjkgMC0xLjY5N2wyLjc1OC0zLjE1LTIuNzU5LTMuMTUyYy0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOCAwLTEuNjk3czEuMjI4LTAuNDY5IDEuNjk3IDBsMi42NTIgMy4wMzEgMi42NTEtMy4wMzFjMC40NjktMC40NjkgMS4yMjgtMC40NjkgMS42OTcgMHMwLjQ2OSAxLjIyOSAwIDEuNjk3bC0yLjc1OCAzLjE1MiAyLjc1OCAzLjE1YzAuNDY5IDAuNDY5IDAuNDY5IDEuMjI5IDAgMS42OTh6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuZXhwb3J0IHR5cGUgRG93bkNoZXZyb25Qcm9wcyA9IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogRG93bkNoZXZyb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J107XG4gIC8qKiBUaGUgZm9jdXNlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGJhc2VDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgdGhlbWU6IHtcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICAgIGNvbG9ycyxcbiAgICB9LFxuICB9OlxuICAgIHwgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuICAgIHwgQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgLi4uKHVuc3R5bGVkXG4gICAgPyB7fVxuICAgIDoge1xuICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnZHJvcGRvd25JbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2Ryb3Bkb3duLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsZWFySW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnY2xlYXJJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGljYXRvclNlcGFyYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpbm5lclByb3BzPzogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ107XG59XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0Rpc2FibGVkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgd2lkdGg6IDEsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICAgICAgICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgICAgIH0pLFxufSk7XG5cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JTZXBhcmF0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgey4uLmdldFN0eWxlUHJvcHMocHJvcHMsICdpbmRpY2F0b3JTZXBhcmF0b3InLCB7XG4gICAgICAgICdpbmRpY2F0b3Itc2VwYXJhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgIC8+XG4gICk7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExvYWRpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBsb2FkaW5nRG90QW5pbWF0aW9ucyA9IGtleWZyYW1lc2BcbiAgMCUsIDgwJSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgNDAlIHsgb3BhY2l0eTogMTsgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmdJbmRpY2F0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgc2l6ZSxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzLFxuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIH0sXG4gIH06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIGFsaWduU2VsZjogJ2NlbnRlcicsXG4gIGZvbnRTaXplOiBzaXplLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBtYXJnaW5SaWdodDogc2l6ZSxcbiAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5pbnRlcmZhY2UgTG9hZGluZ0RvdFByb3BzIHtcbiAgZGVsYXk6IG51bWJlcjtcbiAgb2Zmc2V0OiBib29sZWFuO1xufVxuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogTG9hZGluZ0RvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGluZ0luZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgc2l6ZTogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpbm5lclByb3BzLFxuICBpc1J0bCxcbiAgc2l6ZSA9IDQsXG4gIC4uLnJlc3RQcm9wc1xufTogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgey4uLmdldFN0eWxlUHJvcHMoXG4gICAgICAgIHsgLi4ucmVzdFByb3BzLCBpbm5lclByb3BzLCBpc1J0bCwgc2l6ZSB9LFxuICAgICAgICAnbG9hZGluZ0luZGljYXRvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iXX0= */")
  });
};
var LoadingIndicator = function LoadingIndicator2(_ref7) {
  var innerProps = _ref7.innerProps, isRtl = _ref7.isRtl, _ref7$size = _ref7.size, size2 = _ref7$size === void 0 ? 4 : _ref7$size, restProps = _objectWithoutProperties(_ref7, _excluded2);
  return jsx3("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    innerProps,
    isRtl,
    size: size2
  }), "loadingIndicator", {
    indicator: true,
    "loading-indicator": true
  }), innerProps), jsx3(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx3(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx3(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
var css$1 = function css2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors3 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return _objectSpread2({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors3.neutral5 : colors3.neutral0,
    borderColor: isDisabled ? colors3.neutral10 : isFocused ? colors3.primary : colors3.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors3.primary) : void 0,
    "&:hover": {
      borderColor: isFocused ? colors3.primary : colors3.neutral30
    }
  });
};
var Control = function Control2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx3("div", _extends({
    ref: innerRef
  }, getStyleProps(props, "control", {
    control: true,
    "control--is-disabled": isDisabled,
    "control--is-focused": isFocused,
    "control--menu-is-open": menuIsOpen
  }), innerProps, {
    "aria-disabled": isDisabled || void 0
  }), children);
};
var Control$1 = Control;
var _excluded$1 = ["data"];
var groupCSS = function groupCSS2(_ref3, unstyled) {
  var spacing2 = _ref3.theme.spacing;
  return unstyled ? {} : {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
};
var Group = function Group2(props) {
  var children = props.children, cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, Heading2 = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label = props.label, theme = props.theme, selectProps = props.selectProps;
  return jsx3("div", _extends({}, getStyleProps(props, "group", {
    group: true
  }), innerProps), jsx3(Heading2, _extends({}, headingProps, {
    selectProps,
    theme,
    getStyles,
    getClassNames,
    cx
  }), label), jsx3("div", null, children));
};
var groupHeadingCSS = function groupHeadingCSS2(_ref23, unstyled) {
  var _ref2$theme = _ref23.theme, colors3 = _ref2$theme.colors, spacing2 = _ref2$theme.spacing;
  return _objectSpread2({
    label: "group",
    cursor: "default",
    display: "block"
  }, unstyled ? {} : {
    color: colors3.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  });
};
var GroupHeading = function GroupHeading2(props) {
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
  return jsx3("div", _extends({}, getStyleProps(props, "groupHeading", {
    "group-heading": true
  }), innerProps));
};
var Group$1 = Group;
var _excluded3 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var inputCSS = function inputCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, value = _ref3.value, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors3 = _ref$theme.colors;
  return _objectSpread2(_objectSpread2({
    visibility: isDisabled ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? "translateZ(0)" : ""
  }, containerStyle), unstyled ? {} : {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    color: colors3.neutral80
  });
};
var spacingStyle = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": _objectSpread2({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, spacingStyle)
};
var inputStyle2 = function inputStyle3(isHidden) {
  return _objectSpread2({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: "100%"
  }, spacingStyle);
};
var Input2 = function Input3(props) {
  var cx = props.cx, value = props.value;
  var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded3);
  return jsx3("div", _extends({}, getStyleProps(props, "input", {
    "input-container": true
  }), {
    "data-value": value || ""
  }), jsx3("input", _extends({
    className: cx({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle2(isHidden),
    disabled: isDisabled
  }, innerProps)));
};
var Input$12 = Input2;
var multiValueCSS = function multiValueCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors3 = _ref$theme.colors;
  return _objectSpread2({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, unstyled ? {} : {
    backgroundColor: colors3.neutral10,
    borderRadius: borderRadius2 / 2,
    margin: spacing2.baseUnit / 2
  });
};
var multiValueLabelCSS = function multiValueLabelCSS2(_ref23, unstyled) {
  var _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, colors3 = _ref2$theme.colors, cropWithEllipsis = _ref23.cropWithEllipsis;
  return _objectSpread2({
    overflow: "hidden",
    textOverflow: cropWithEllipsis || cropWithEllipsis === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    color: colors3.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
};
var multiValueRemoveCSS = function multiValueRemoveCSS2(_ref3, unstyled) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors3 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return _objectSpread2({
    alignItems: "center",
    display: "flex"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused ? colors3.dangerLight : void 0,
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors3.dangerLight,
      color: colors3.danger
    }
  });
};
var MultiValueGeneric = function MultiValueGeneric2(_ref4) {
  var children = _ref4.children, innerProps = _ref4.innerProps;
  return jsx3("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children, innerProps = _ref5.innerProps;
  return jsx3("div", _extends({
    role: "button"
  }, innerProps), children || jsx3(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue2(props) {
  var children = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps3 = props.removeProps, selectProps = props.selectProps;
  var Container3 = components2.Container, Label2 = components2.Label, Remove = components2.Remove;
  return jsx3(Container3, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValue", {
      "multi-value": true,
      "multi-value--is-disabled": isDisabled
    })), innerProps),
    selectProps
  }, jsx3(Label2, {
    data,
    innerProps: _objectSpread2({}, getStyleProps(props, "multiValueLabel", {
      "multi-value__label": true
    })),
    selectProps
  }, children), jsx3(Remove, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": true
    })), {}, {
      "aria-label": "Remove ".concat(children || "option")
    }, removeProps3),
    selectProps
  }));
};
var MultiValue$1 = MultiValue;
var optionCSS = function optionCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors3 = _ref$theme.colors;
  return _objectSpread2({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, unstyled ? {} : {
    backgroundColor: isSelected ? colors3.primary : isFocused ? colors3.primary25 : "transparent",
    color: isDisabled ? colors3.neutral20 : isSelected ? colors3.neutral0 : "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: !isDisabled ? isSelected ? colors3.primary : colors3.primary50 : void 0
    }
  });
};
var Option = function Option2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx3("div", _extends({}, getStyleProps(props, "option", {
    option: true,
    "option--is-disabled": isDisabled,
    "option--is-focused": isFocused,
    "option--is-selected": isSelected
  }), {
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children);
};
var Option$1 = Option;
var placeholderCSS = function placeholderCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors3 = _ref$theme.colors;
  return _objectSpread2({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, unstyled ? {} : {
    color: colors3.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var Placeholder = function Placeholder2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx3("div", _extends({}, getStyleProps(props, "placeholder", {
    placeholder: true
  }), innerProps), children);
};
var Placeholder$1 = Placeholder;
var css3 = function css4(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors3 = _ref$theme.colors;
  return _objectSpread2({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    color: isDisabled ? colors3.neutral40 : colors3.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var SingleValue = function SingleValue2(props) {
  var children = props.children, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx3("div", _extends({}, getStyleProps(props, "singleValue", {
    "single-value": true,
    "single-value--is-disabled": isDisabled
  }), innerProps), children);
};
var SingleValue$1 = SingleValue;
var components = {
  ClearIndicator,
  Control: Control$1,
  DropdownIndicator,
  DownChevron,
  CrossIcon,
  Group: Group$1,
  GroupHeading,
  IndicatorsContainer,
  IndicatorSeparator,
  Input: Input$12,
  LoadingIndicator,
  Menu: Menu$1,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue: MultiValue$1,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option: Option$1,
  Placeholder: Placeholder$1,
  SelectContainer,
  SingleValue: SingleValue$1,
  ValueContainer
};
var defaultComponents = function defaultComponents2(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
};

// node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first2, second) {
  if (first2 === second) {
    return true;
  }
  if (safeIsNaN(first2) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i3 = 0; i3 < newInputs.length; i3++) {
    if (!isEqual(newInputs[i3], lastInputs[i3])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache2 = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
      return cache2.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache2 = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache2 = null;
  };
  return memoized;
}

// node_modules/react-select/dist/Select-ef7c0426.esm.js
function _EMOTION_STRINGIFIED_CSS_ERROR__$2() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref = false ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFPSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IEpTWCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$2
};
var A11yText = function A11yText2(props) {
  return jsx3("span", _extends({
    css: _ref
  }, props));
};
var A11yText$1 = A11yText;
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, tabSelectsValue = props.tabSelectsValue, context = props.context, isInitialFocus = props.isInitialFocus;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return isInitialFocus ? "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function onChange(props) {
    var action = props.action, _props$label = props.label, label = _props$label === void 0 ? "" : _props$label, labels = props.labels, isDisabled = props.isDisabled;
    switch (action) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(labels.length > 1 ? "s" : "", " ").concat(labels.join(","), ", selected.");
      case "select-option":
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context, focused = props.focused, options2 = props.options, _props$label2 = props.label, label = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected, isAppleDevice2 = props.isAppleDevice;
    var getArrayIndex = function getArrayIndex2(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : "";
    };
    if (context === "value" && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === "menu" && isAppleDevice2) {
      var disabled = isDisabled ? " disabled" : "";
      var status = "".concat(isSelected ? " selected" : "").concat(disabled);
      return "".concat(label).concat(status, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }
};
var LiveRegion = function LiveRegion2(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id = props.id, isAppleDevice2 = props.isAppleDevice;
  var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue, isLoading = selectProps.isLoading;
  var ariaLabel = selectProps["aria-label"];
  var ariaLive = selectProps["aria-live"];
  var messages = (0, import_react8.useMemo)(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);
  var ariaSelected = (0, import_react8.useMemo)(function() {
    var message2 = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value;
      var asOption = function asOption2(val) {
        return !Array.isArray(val) ? val : null;
      };
      var selected = removedValue || option || asOption(value);
      var label = selected ? getOptionLabel4(selected) : "";
      var multiSelected = selectedOptions || removedValues || void 0;
      var labels = multiSelected ? multiSelected.map(getOptionLabel4) : [];
      var onChangeProps = _objectSpread2({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected && isOptionDisabled3(selected, selectValue),
        label,
        labels
      }, ariaSelection);
      message2 = messages.onChange(onChangeProps);
    }
    return message2;
  }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel4]);
  var ariaFocused = (0, import_react8.useMemo)(function() {
    var focusMsg = "";
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused, selectValue),
        isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? "menu" : "value",
        selectValue,
        isAppleDevice: isAppleDevice2
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, focusableOptions, selectValue, isAppleDevice2]);
  var ariaResults = (0, import_react8.useMemo)(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && !isLoading && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2, isLoading]);
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus";
  var ariaGuidance = (0, import_react8.useMemo)(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption, selectValue),
        isMulti,
        isSearchable,
        tabSelectsValue,
        isInitialFocus
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue, isInitialFocus]);
  var ScreenReaderText = jsx3(import_react8.Fragment, null, jsx3("span", {
    id: "aria-selection"
  }, ariaSelected), jsx3("span", {
    id: "aria-focused"
  }, ariaFocused), jsx3("span", {
    id: "aria-results"
  }, ariaResults), jsx3("span", {
    id: "aria-guidance"
  }, ariaGuidance));
  return jsx3(import_react8.Fragment, null, jsx3(A11yText$1, {
    id
  }, isInitialFocus && ScreenReaderText), jsx3(A11yText$1, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};
var LiveRegion$1 = LiveRegion;
var diacritics = [{
  base: "A",
  letters: "AⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ"
}, {
  base: "AA",
  letters: "Ꜳ"
}, {
  base: "AE",
  letters: "ÆǼǢ"
}, {
  base: "AO",
  letters: "Ꜵ"
}, {
  base: "AU",
  letters: "Ꜷ"
}, {
  base: "AV",
  letters: "ꜸꜺ"
}, {
  base: "AY",
  letters: "Ꜽ"
}, {
  base: "B",
  letters: "BⒷＢḂḄḆɃƂƁ"
}, {
  base: "C",
  letters: "CⒸＣĆĈĊČÇḈƇȻꜾ"
}, {
  base: "D",
  letters: "DⒹＤḊĎḌḐḒḎĐƋƊƉꝹ"
}, {
  base: "DZ",
  letters: "ǱǄ"
}, {
  base: "Dz",
  letters: "ǲǅ"
}, {
  base: "E",
  letters: "EⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎ"
}, {
  base: "F",
  letters: "FⒻＦḞƑꝻ"
}, {
  base: "G",
  letters: "GⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾ"
}, {
  base: "H",
  letters: "HⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ"
}, {
  base: "I",
  letters: "IⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ"
}, {
  base: "J",
  letters: "JⒿＪĴɈ"
}, {
  base: "K",
  letters: "KⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ"
}, {
  base: "L",
  letters: "LⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ"
}, {
  base: "LJ",
  letters: "Ǉ"
}, {
  base: "Lj",
  letters: "ǈ"
}, {
  base: "M",
  letters: "MⓂＭḾṀṂⱮƜ"
}, {
  base: "N",
  letters: "NⓃＮǸŃÑṄŇṆŅṊṈȠƝꞐꞤ"
}, {
  base: "NJ",
  letters: "Ǌ"
}, {
  base: "Nj",
  letters: "ǋ"
}, {
  base: "O",
  letters: "OⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ"
}, {
  base: "OI",
  letters: "Ƣ"
}, {
  base: "OO",
  letters: "Ꝏ"
}, {
  base: "OU",
  letters: "Ȣ"
}, {
  base: "P",
  letters: "PⓅＰṔṖƤⱣꝐꝒꝔ"
}, {
  base: "Q",
  letters: "QⓆＱꝖꝘɊ"
}, {
  base: "R",
  letters: "RⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ"
}, {
  base: "S",
  letters: "SⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ"
}, {
  base: "T",
  letters: "TⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ"
}, {
  base: "TZ",
  letters: "Ꜩ"
}, {
  base: "U",
  letters: "UⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ"
}, {
  base: "V",
  letters: "VⓋＶṼṾƲꝞɅ"
}, {
  base: "VY",
  letters: "Ꝡ"
}, {
  base: "W",
  letters: "WⓌＷẀẂŴẆẄẈⱲ"
}, {
  base: "X",
  letters: "XⓍＸẊẌ"
}, {
  base: "Y",
  letters: "YⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ"
}, {
  base: "Z",
  letters: "ZⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ"
}, {
  base: "a",
  letters: "aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐ"
}, {
  base: "aa",
  letters: "ꜳ"
}, {
  base: "ae",
  letters: "æǽǣ"
}, {
  base: "ao",
  letters: "ꜵ"
}, {
  base: "au",
  letters: "ꜷ"
}, {
  base: "av",
  letters: "ꜹꜻ"
}, {
  base: "ay",
  letters: "ꜽ"
}, {
  base: "b",
  letters: "bⓑｂḃḅḇƀƃɓ"
}, {
  base: "c",
  letters: "cⓒｃćĉċčçḉƈȼꜿↄ"
}, {
  base: "d",
  letters: "dⓓｄḋďḍḑḓḏđƌɖɗꝺ"
}, {
  base: "dz",
  letters: "ǳǆ"
}, {
  base: "e",
  letters: "eⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇɛǝ"
}, {
  base: "f",
  letters: "fⓕｆḟƒꝼ"
}, {
  base: "g",
  letters: "gⓖｇǵĝḡğġǧģǥɠꞡᵹꝿ"
}, {
  base: "h",
  letters: "hⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ"
}, {
  base: "hv",
  letters: "ƕ"
}, {
  base: "i",
  letters: "iⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı"
}, {
  base: "j",
  letters: "jⓙｊĵǰɉ"
}, {
  base: "k",
  letters: "kⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ"
}, {
  base: "l",
  letters: "lⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇ"
}, {
  base: "lj",
  letters: "ǉ"
}, {
  base: "m",
  letters: "mⓜｍḿṁṃɱɯ"
}, {
  base: "n",
  letters: "nⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥ"
}, {
  base: "nj",
  letters: "ǌ"
}, {
  base: "o",
  letters: "oⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿɔꝋꝍɵ"
}, {
  base: "oi",
  letters: "ƣ"
}, {
  base: "ou",
  letters: "ȣ"
}, {
  base: "oo",
  letters: "ꝏ"
}, {
  base: "p",
  letters: "pⓟｐṕṗƥᵽꝑꝓꝕ"
}, {
  base: "q",
  letters: "qⓠｑɋꝗꝙ"
}, {
  base: "r",
  letters: "rⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ"
}, {
  base: "s",
  letters: "sⓢｓßśṥŝṡšṧṣṩșşȿꞩꞅẛ"
}, {
  base: "t",
  letters: "tⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ"
}, {
  base: "tz",
  letters: "ꜩ"
}, {
  base: "u",
  letters: "uⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ"
}, {
  base: "v",
  letters: "vⓥｖṽṿʋꝟʌ"
}, {
  base: "vy",
  letters: "ꝡ"
}, {
  base: "w",
  letters: "wⓦｗẁẃŵẇẅẘẉⱳ"
}, {
  base: "x",
  letters: "xⓧｘẋẍ"
}, {
  base: "y",
  letters: "yⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ"
}, {
  base: "z",
  letters: "zⓩｚźẑżžẓẕƶȥɀⱬꝣ"
}];
var anyDiacritic = new RegExp("[" + diacritics.map(function(d2) {
  return d2.letters;
}).join("") + "]", "g");
var diacriticToBase = {};
for (i3 = 0; i3 < diacritics.length; i3++) {
  diacritic = diacritics[i3];
  for (j3 = 0; j3 < diacritic.letters.length; j3++) {
    diacriticToBase[diacritic.letters[j3]] = diacritic.base;
  }
}
var diacritic;
var j3;
var i3;
var stripDiacritics = function stripDiacritics2(str) {
  return str.replace(anyDiacritic, function(match3) {
    return diacriticToBase[match3];
  });
};
var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
var trimString = function trimString2(str) {
  return str.replace(/^\s+|\s+$/g, "");
};
var defaultStringify = function defaultStringify2(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter2(config) {
  return function(option, rawInput) {
    if (option.data.__isNew__) return true;
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: "any"
    }, config), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input = trim2 ? trimString(rawInput) : rawInput;
    var candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input = memoizedStripDiacriticsForInput(input);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === "start" ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};
var _excluded4 = ["innerRef"];
function DummyInput(_ref3) {
  var innerRef = _ref3.innerRef, props = _objectWithoutProperties(_ref3, _excluded4);
  var filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
  return jsx3("input", _extends({
    ref: innerRef
  }, filteredProps, {
    css: css({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, false ? "" : ";label:DummyInput;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgeyByZW1vdmVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRHVtbXlJbnB1dCh7XG4gIGlubmVyUmVmLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydpbnB1dCddICYge1xuICByZWFkb25seSBpbm5lclJlZjogUmVmPEhUTUxJbnB1dEVsZW1lbnQ+O1xufSkge1xuICAvLyBSZW1vdmUgYW5pbWF0aW9uIHByb3BzIG5vdCBtZWFudCBmb3IgSFRNTCBlbGVtZW50c1xuICBjb25zdCBmaWx0ZXJlZFByb3BzID0gcmVtb3ZlUHJvcHMoXG4gICAgcHJvcHMsXG4gICAgJ29uRXhpdGVkJyxcbiAgICAnaW4nLFxuICAgICdlbnRlcicsXG4gICAgJ2V4aXQnLFxuICAgICdhcHBlYXInXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8aW5wdXRcbiAgICAgIHJlZj17aW5uZXJSZWZ9XG4gICAgICB7Li4uZmlsdGVyZWRQcm9wc31cbiAgICAgIGNzcz17e1xuICAgICAgICBsYWJlbDogJ2R1bW15SW5wdXQnLFxuICAgICAgICAvLyBnZXQgcmlkIG9mIGFueSBkZWZhdWx0IHN0eWxlc1xuICAgICAgICBiYWNrZ3JvdW5kOiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgdGhpcyBoaWRlcyB0aGUgZmxhc2hpbmcgY3Vyc29yXG4gICAgICAgIGNhcmV0Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgIGdyaWRBcmVhOiAnMSAvIDEgLyAyIC8gMycsXG4gICAgICAgIG91dGxpbmU6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgd2l0aG91dCBgd2lkdGhgIGJyb3dzZXJzIHdvbid0IGFsbG93IGZvY3VzXG4gICAgICAgIHdpZHRoOiAxLFxuXG4gICAgICAgIC8vIHJlbW92ZSBjdXJzb3Igb24gZGVza3RvcFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIG1vYmlsZSB3aGlsc3QgbWFpbnRhaW5pbmcgXCJzY3JvbGwgaW50byB2aWV3XCIgYmVoYXZpb3VyXG4gICAgICAgIGxlZnQ6IC0xMDAsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSguMDEpJyxcbiAgICAgIH19XG4gICAgLz5cbiAgKTtcbn1cbiJdfQ== */")
  }));
}
var cancelScroll = function cancelScroll2(event) {
  if (event.cancelable) event.preventDefault();
  event.stopPropagation();
};
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var isBottom = (0, import_react8.useRef)(false);
  var isTop = (0, import_react8.useRef)(false);
  var touchStart = (0, import_react8.useRef)(0);
  var scrollTarget = (0, import_react8.useRef)(null);
  var handleEventDelta = (0, import_react8.useCallback)(function(event, delta) {
    if (scrollTarget.current === null) return;
    var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave) onBottomLeave(event);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave) onTopLeave(event);
      isTop.current = false;
    }
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }
    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = (0, import_react8.useCallback)(function(event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = (0, import_react8.useCallback)(function(event) {
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = (0, import_react8.useCallback)(function(event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = (0, import_react8.useCallback)(function(el) {
    if (!el) return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    el.addEventListener("wheel", onWheel, notPassive);
    el.addEventListener("touchstart", onTouchStart, notPassive);
    el.addEventListener("touchmove", onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = (0, import_react8.useCallback)(function(el) {
    if (!el) return;
    el.removeEventListener("wheel", onWheel, false);
    el.removeEventListener("touchstart", onTouchStart, false);
    el.removeEventListener("touchmove", onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  (0, import_react8.useEffect)(function() {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    startListening(element);
    return function() {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var LOCK_STYLES = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e2) {
  if (e2.cancelable) e2.preventDefault();
}
function allowTouchMove(e2) {
  e2.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;
  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var canUseDOM2 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = (0, import_react8.useRef)({});
  var scrollTarget = (0, import_react8.useRef)(null);
  var addScrollLock = (0, import_react8.useCallback)(function(touchScrollTarget) {
    if (!canUseDOM2) return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      STYLE_KEYS.forEach(function(key2) {
        var val = targetStyle && targetStyle[key2];
        originalStyles.current[key2] = val;
      });
    }
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function(key2) {
        var val = LOCK_STYLES[key2];
        if (targetStyle) {
          targetStyle[key2] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }
    if (target && isTouchDevice()) {
      target.addEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = (0, import_react8.useCallback)(function(touchScrollTarget) {
    if (!canUseDOM2) return;
    var target = document.body;
    var targetStyle = target && target.style;
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function(key2) {
        var val = originalStyles.current[key2];
        if (targetStyle) {
          targetStyle[key2] = val;
        }
      });
    }
    if (target && isTouchDevice()) {
      target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  (0, import_react8.useEffect)(function() {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function() {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function(element) {
    scrollTarget.current = element;
  };
}
function _EMOTION_STRINGIFIED_CSS_ERROR__$1() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var blurSelectInput = function blurSelectInput2(event) {
  var element = event.target;
  return element.ownerDocument.activeElement && element.ownerDocument.activeElement.blur();
};
var _ref2$1 = false ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9EVSIsImZpbGUiOiJTY3JvbGxNYW5hZ2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFJlYWN0RWxlbWVudCwgUmVmQ2FsbGJhY2ssIE1vdXNlRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU2Nyb2xsQ2FwdHVyZSBmcm9tICcuL3VzZVNjcm9sbENhcHR1cmUnO1xuaW1wb3J0IHVzZVNjcm9sbExvY2sgZnJvbSAnLi91c2VTY3JvbGxMb2NrJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVhZG9ubHkgY2hpbGRyZW46IChyZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PikgPT4gUmVhY3RFbGVtZW50O1xuICByZWFkb25seSBsb2NrRW5hYmxlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Cb3R0b21MZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IG9uVG9wQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Ub3BMZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGJsdXJTZWxlY3RJbnB1dCA9IChldmVudDogTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgcmV0dXJuIChcbiAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgIChlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuYmx1cigpXG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTY3JvbGxNYW5hZ2VyKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2tFbmFibGVkLFxuICBjYXB0dXJlRW5hYmxlZCA9IHRydWUsXG4gIG9uQm90dG9tQXJyaXZlLFxuICBvbkJvdHRvbUxlYXZlLFxuICBvblRvcEFycml2ZSxcbiAgb25Ub3BMZWF2ZSxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHNldFNjcm9sbENhcHR1cmVUYXJnZXQgPSB1c2VTY3JvbGxDYXB0dXJlKHtcbiAgICBpc0VuYWJsZWQ6IGNhcHR1cmVFbmFibGVkLFxuICAgIG9uQm90dG9tQXJyaXZlLFxuICAgIG9uQm90dG9tTGVhdmUsXG4gICAgb25Ub3BBcnJpdmUsXG4gICAgb25Ub3BMZWF2ZSxcbiAgfSk7XG4gIGNvbnN0IHNldFNjcm9sbExvY2tUYXJnZXQgPSB1c2VTY3JvbGxMb2NrKHsgaXNFbmFibGVkOiBsb2NrRW5hYmxlZCB9KTtcblxuICBjb25zdCB0YXJnZXRSZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PiA9IChlbGVtZW50KSA9PiB7XG4gICAgc2V0U2Nyb2xsQ2FwdHVyZVRhcmdldChlbGVtZW50KTtcbiAgICBzZXRTY3JvbGxMb2NrVGFyZ2V0KGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAge2xvY2tFbmFibGVkICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e2JsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHtjaGlsZHJlbih0YXJnZXRSZWYpfVxuICAgIDwvRnJhZ21lbnQ+XG4gICk7XG59XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$1
};
function ScrollManager(_ref3) {
  var children = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef2(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx3(import_react8.Fragment, null, lockEnabled && jsx3("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children(targetRef));
}
function _EMOTION_STRINGIFIED_CSS_ERROR__2() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref22 = false ? {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} : {
  name: "5kkxb2-requiredInput-RequiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%;label:RequiredInput;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVpcmVkSW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNJIiwiZmlsZSI6IlJlcXVpcmVkSW5wdXQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBGb2N1c0V2ZW50SGFuZGxlciwgRnVuY3Rpb25Db21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmNvbnN0IFJlcXVpcmVkSW5wdXQ6IEZ1bmN0aW9uQ29tcG9uZW50PHtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgb25Gb2N1czogRm9jdXNFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59PiA9ICh7IG5hbWUsIG9uRm9jdXMgfSkgPT4gKFxuICA8aW5wdXRcbiAgICByZXF1aXJlZFxuICAgIG5hbWU9e25hbWV9XG4gICAgdGFiSW5kZXg9ey0xfVxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAncmVxdWlyZWRJbnB1dCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH19XG4gICAgLy8gUHJldmVudCBgU3dpdGNoaW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWRgIGVycm9yXG4gICAgdmFsdWU9XCJcIlxuICAgIG9uQ2hhbmdlPXsoKSA9PiB7fX1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFJlcXVpcmVkSW5wdXQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__2
};
var RequiredInput = function RequiredInput2(_ref3) {
  var name = _ref3.name, onFocus2 = _ref3.onFocus;
  return jsx3("input", {
    required: true,
    name,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: onFocus2,
    css: _ref22,
    value: "",
    onChange: function onChange2() {
    }
  });
};
var RequiredInput$1 = RequiredInput;
function testPlatform(re2) {
  var _window$navigator$use;
  return typeof window !== "undefined" && window.navigator != null ? re2.test(((_window$navigator$use = window.navigator["userAgentData"]) === null || _window$navigator$use === void 0 ? void 0 : _window$navigator$use.platform) || window.navigator.platform) : false;
}
function isIPhone() {
  return testPlatform(/^iPhone/i);
}
function isMac() {
  return testPlatform(/^Mac/i);
}
function isIPad() {
  return testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
  return isIPhone() || isIPad();
}
function isAppleDevice() {
  return isMac() || isIOS();
}
var formatGroupLabel = function formatGroupLabel2(group) {
  return group.label;
};
var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled2(option) {
  return !!option.isDisabled;
};
var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css3,
  valueContainer: valueContainerCSS
};
var colors2 = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var borderRadius = 4;
var baseUnit = 4;
var controlHeight = 38;
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit,
  controlHeight,
  menuGutter
};
var defaultTheme = {
  borderRadius,
  colors: colors2,
  spacing
};
var defaultProps = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function screenReaderStatus(_ref3) {
    var count = _ref3.count;
    return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true,
  unstyled: false
};
function toCategorizedOption(props, option, selectValue, index2) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label = getOptionLabel2(props, option);
  var value = getOptionValue2(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label,
    value,
    index: index2
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if ("options" in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable2(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable2(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(notNullish);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptionsWithIds(categorizedOptions, optionId) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return {
          data: option.data,
          id: "".concat(optionId, "-").concat(categorizedOption.index, "-").concat(option.index)
        };
      })));
    } else {
      optionsAccumulator.push({
        data: categorizedOption.data,
        id: "".concat(optionId, "-").concat(categorizedOption.index)
      });
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable2(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
  var data = categorizedOption.data, isSelected = categorizedOption.isSelected, label = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label,
    value,
    data
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue, lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options2) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
var getFocusedOptionId = function getFocusedOptionId2(focusableOptionsWithIds, focusedOption) {
  var _focusableOptionsWith;
  var focusedOptionId = (_focusableOptionsWith = focusableOptionsWithIds.find(function(option) {
    return option.data === focusedOption;
  })) === null || _focusableOptionsWith === void 0 ? void 0 : _focusableOptionsWith.id;
  return focusedOptionId || null;
};
var getOptionLabel2 = function getOptionLabel3(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue2 = function getOptionValue3(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1) return true;
  if (typeof props.isOptionSelected === "function") {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue2(props, option);
  return selectValue.some(function(i3) {
    return getOptionValue2(props, i3) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  if (hideSelectedOptions === void 0) return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select2 = (function(_Component) {
  _inherits(Select3, _Component);
  var _super = _createSuper(Select3);
  function Select3(_props) {
    var _this;
    _classCallCheck(this, Select3);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: "",
      isAppleDevice: false
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;
    _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name = _this$props.name;
      actionMeta.name = name;
      _this.ariaOnChange(newValue, actionMeta);
      onChange2(newValue, actionMeta);
    };
    _this.setValue = function(newValue, action, option) {
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
      _this.onInputChange("", {
        action: "set-value",
        prevInputValue: inputValue
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action,
        option
      });
    };
    _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(multiValueAsValue(selectValue.filter(function(i3) {
          return _this.getOptionValue(i3) !== candidate;
        })), "deselect-option", newValue);
      } else if (!isDisabled) {
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), "select-option", newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), "select-option");
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: "select-option",
          option: newValue,
          name
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function(i3) {
        return _this.getOptionValue(i3) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: "clear",
        removedValues: selectValue
      });
    };
    _this.popValue = function() {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      if (lastSelectedValue) {
        _this.onChange(newValue, {
          action: "pop-value",
          removedValue: lastSelectedValue
        });
      }
    };
    _this.getFocusedOptionId = function(focusedOption) {
      return getFocusedOptionId(_this.state.focusableOptionsWithIds, focusedOption);
    };
    _this.getFocusableOptionsWithIds = function() {
      return buildFocusableOptionsWithIds(buildCategorizedOptions(_this.props, _this.state.selectValue), _this.getElementId("option"));
    };
    _this.getValue = function() {
      return _this.state.selectValue;
    };
    _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function(data) {
      return getOptionLabel2(_this.props, data);
    };
    _this.getOptionValue = function(data) {
      return getOptionValue2(_this.props, data);
    };
    _this.getStyles = function(key2, props) {
      var unstyled = _this.props.unstyled;
      var base = defaultStyles[key2](props, unstyled);
      base.boxSizing = "border-box";
      var custom = _this.props.styles[key2];
      return custom ? custom(base, props) : base;
    };
    _this.getClassNames = function(key2, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key2]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    };
    _this.getElementId = function(element) {
      return "".concat(_this.state.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function() {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function(event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function(event) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function(event) {
      if (event.defaultPrevented) {
        return;
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu("first");
        }
      } else {
        if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
        event.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled) return;
      var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu("first");
      }
      event.preventDefault();
    };
    _this.onClearIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.preventDefault();
      _this.openAfterFocus = false;
      if (event.type === "touchend") {
        _this.focusInput();
      } else {
        setTimeout(function() {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function(event) {
      if (typeof _this.props.closeMenuOnScroll === "boolean") {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === "function") {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function() {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function() {
      _this.isComposing = false;
    };
    _this.onTouchStart = function(_ref23) {
      var touches = _ref23.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      }
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      _this.onControlMouseDown(event);
    };
    _this.onClearIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      _this.onClearIndicatorMouseDown(event);
    };
    _this.onDropdownIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      _this.onDropdownIndicatorMouseDown(event);
    };
    _this.handleInputChange = function(event) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: "input-change",
        prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function(event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu("first");
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function(event) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange("", {
        action: "input-blur",
        prevInputValue
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function(focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      var options2 = _this.getFocusableOptions();
      var focusedOptionIndex = options2.indexOf(focusedOption);
      _this.setState({
        focusedOption,
        focusedOptionId: focusedOptionIndex > -1 ? _this.getFocusedOptionId(focusedOption) : null
      });
    };
    _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onValueInputFocus = function(e2) {
      e2.preventDefault();
      e2.stopPropagation();
      _this.focus();
    };
    _this.onKeyDown = function(event) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (isDisabled) return;
      if (typeof onKeyDown === "function") {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      }
      _this.blockOptionHover = true;
      switch (event.key) {
        case "ArrowLeft":
          if (!isMulti || inputValue) return;
          _this.focusValue("previous");
          break;
        case "ArrowRight":
          if (!isMulti || inputValue) return;
          _this.focusValue("next");
          break;
        case "Delete":
        case "Backspace":
          if (inputValue) return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue) return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case "Tab":
          if (_this.isComposing) return;
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case "Enter":
          if (event.keyCode === 229) {
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption) return;
            if (_this.isComposing) return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case "Escape":
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange("", {
              action: "menu-close",
              prevInputValue: inputValue
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case " ":
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu("first");
            break;
          }
          if (!focusedOption) return;
          _this.selectOption(focusedOption);
          break;
        case "ArrowUp":
          if (menuIsOpen) {
            _this.focusOption("up");
          } else {
            _this.openMenu("last");
          }
          break;
        case "ArrowDown":
          if (menuIsOpen) {
            _this.focusOption("down");
          } else {
            _this.openMenu("first");
          }
          break;
        case "PageUp":
          if (!menuIsOpen) return;
          _this.focusOption("pageup");
          break;
        case "PageDown":
          if (!menuIsOpen) return;
          _this.focusOption("pagedown");
          break;
        case "Home":
          if (!menuIsOpen) return;
          _this.focusOption("first");
          break;
        case "End":
          if (!menuIsOpen) return;
          _this.focusOption("last");
          break;
        default:
          return;
      }
      event.preventDefault();
    };
    _this.state.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    if (_props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptionsWithIds = _this.getFocusableOptionsWithIds();
      var focusableOptions = _this.buildFocusableOptions();
      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusableOptionsWithIds = focusableOptionsWithIds;
      _this.state.focusedOption = focusableOptions[optionIndex];
      _this.state.focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusableOptions[optionIndex]);
    }
    return _this;
  }
  _createClass(Select3, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        document.addEventListener("scroll", this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
      }
      if (isAppleDevice()) {
        this.setState({
          isAppleDevice: true
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
        // ensure focus is restored correctly when the control becomes enabled
        isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
        isFocused && menuIsOpen && !prevProps.menuIsOpen
      ) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
        this.setState({
          isFocused: true
        });
      }
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener("scroll", this.onScroll, true);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef) return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef) return;
      this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex],
        focusedOptionId: this.getFocusedOptionId(focusableOptions[openAtIndex])
      }, function() {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (!this.props.isMulti) return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length) return;
      switch (direction) {
        case "previous":
          if (focusedIndex === 0) {
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case "next":
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options2 = this.getFocusableOptions();
      if (!options2.length) return;
      var nextFocus = 0;
      var focusedIndex = options2.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === "up") {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1;
      } else if (direction === "down") {
        nextFocus = (focusedIndex + 1) % options2.length;
      } else if (direction === "pageup") {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0) nextFocus = 0;
      } else if (direction === "pagedown") {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options2.length - 1) nextFocus = options2.length - 1;
      } else if (direction === "last") {
        nextFocus = options2.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options2[nextFocus],
        focusedValue: null,
        focusedOptionId: this.getFocusedOptionId(options2[nextFocus])
      });
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function getTheme3() {
        if (!this.props.theme) {
          return defaultTheme;
        }
        if (typeof this.props.theme === "function") {
          return this.props.theme(defaultTheme);
        }
        return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
      }
    )
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue, cx = this.cx, getStyles = this.getStyles, getClassNames = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
      var isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles,
        getClassNames,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      if (isClearable2 === void 0) return isMulti;
      return isClearable2;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled3(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === "function") {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel3(data) {
      return this.props.formatGroupLabel(data);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function startListeningComposition() {
        if (document && document.addEventListener) {
          document.addEventListener("compositionstart", this.onCompositionStart, false);
          document.addEventListener("compositionend", this.onCompositionEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener("compositionstart", this.onCompositionStart);
        document.removeEventListener("compositionend", this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function startListeningToTouch() {
        if (document && document.addEventListener) {
          document.addEventListener("touchstart", this.onTouchStart, false);
          document.addEventListener("touchmove", this.onTouchMove, false);
          document.addEventListener("touchend", this.onTouchEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener("touchstart", this.onTouchStart);
        document.removeEventListener("touchmove", this.onTouchMove);
        document.removeEventListener("touchend", this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function renderInput() {
        var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required;
        var _this$getComponents = this.getComponents(), Input4 = _this$getComponents.Input;
        var _this$state4 = this.state, inputIsHidden = _this$state4.inputIsHidden, ariaSelection = _this$state4.ariaSelection;
        var commonProps = this.commonProps;
        var id = inputId || this.getElementId("input");
        var ariaAttributes = _objectSpread2(_objectSpread2(_objectSpread2({
          "aria-autocomplete": "list",
          "aria-expanded": menuIsOpen,
          "aria-haspopup": true,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": required,
          role: "combobox",
          "aria-activedescendant": this.state.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, menuIsOpen && {
          "aria-controls": this.getElementId("listbox")
        }), !isSearchable && {
          "aria-readonly": true
        }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        if (!isSearchable) {
          return React6.createElement(DummyInput, _extends({
            id,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: noop4,
            onFocus: this.onInputFocus,
            disabled: isDisabled,
            tabIndex,
            inputMode: "none",
            form,
            value: ""
          }, ariaAttributes));
        }
        return React6.createElement(Input4, _extends({}, commonProps, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id,
          innerRef: this.getInputRef,
          isDisabled,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex,
          form,
          type: "text",
          value: inputValue
        }, ariaAttributes));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel3 = _this$getComponents2.MultiValueLabel, MultiValueRemove3 = _this$getComponents2.MultiValueRemove, SingleValue4 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder;
      var _this$state5 = this.state, selectValue = _this$state5.selectValue, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : React6.createElement(Placeholder3, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), placeholder);
      }
      if (isMulti) {
        return selectValue.map(function(opt, index2) {
          var isOptionFocused = opt === focusedValue;
          var key2 = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return React6.createElement(MultiValue3, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel3,
              Remove: MultiValueRemove3
            },
            isFocused: isOptionFocused,
            isDisabled,
            key: key2,
            index: index2,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e2) {
                e2.preventDefault();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return React6.createElement(SingleValue4, _extends({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator4 = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator4 || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return React6.createElement(ClearIndicator4, _extends({}, commonProps, {
        innerProps,
        isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading) return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return React6.createElement(LoadingIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator4 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator4 || !IndicatorSeparator3) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return React6.createElement(IndicatorSeparator3, _extends({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator4 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator4) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return React6.createElement(DropdownIndicator4, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(), Group3 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu5 = _this$getComponents7.Menu, MenuList4 = _this$getComponents7.MenuList, MenuPortal3 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage4 = _this$getComponents7.NoOptionsMessage, Option4 = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen) return null;
      var render = function render2(props, id) {
        var type = props.type, data = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label = props.label, value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId("option"), "-").concat(id);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1,
          role: "option",
          "aria-selected": _this4.state.isAppleDevice ? void 0 : isSelected
          // is not supported on Apple devices
        };
        return React6.createElement(Option4, _extends({}, commonProps, {
          innerProps,
          data,
          isDisabled,
          isSelected,
          key: optionId,
          label,
          type,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function(item) {
          if (item.type === "group") {
            var _data = item.data, options2 = item.options, groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return React6.createElement(Group3, _extends({}, commonProps, {
              key: groupId,
              data: _data,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function(option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === "option") {
            return render(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message2 = loadingMessage2({
          inputValue
        });
        if (message2 === null) return null;
        menuUI = React6.createElement(LoadingMessage3, commonProps, message2);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null) return null;
        menuUI = React6.createElement(NoOptionsMessage4, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      };
      var menuElement = React6.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return React6.createElement(Menu5, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove
          },
          isLoading,
          placement
        }), React6.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return React6.createElement(MenuList4, _extends({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);
              scrollTargetRef(instance);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": commonProps.isMulti,
              id: _this4.getElementId("listbox")
            },
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? React6.createElement(MenuPortal3, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name = _this$props13.name, required = _this$props13.required;
      var selectValue = this.state.selectValue;
      if (required && !this.hasValue() && !isDisabled) {
        return React6.createElement(RequiredInput$1, {
          name,
          onFocus: this.onValueInputFocus
        });
      }
      if (!name || isDisabled) return;
      if (isMulti) {
        if (delimiter2) {
          var value = selectValue.map(function(opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter2);
          return React6.createElement("input", {
            name,
            type: "hidden",
            value
          });
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function(opt, i3) {
            return React6.createElement("input", {
              key: "i-".concat(i3),
              name,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : React6.createElement("input", {
            name,
            type: "hidden",
            value: ""
          });
          return React6.createElement("div", null, input);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
        return React6.createElement("input", {
          name,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state, ariaSelection = _this$state6.ariaSelection, focusedOption = _this$state6.focusedOption, focusedValue = _this$state6.focusedValue, isFocused = _this$state6.isFocused, selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return React6.createElement(LiveRegion$1, _extends({}, commonProps, {
        id: this.getElementId("live-region"),
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions,
        isAppleDevice: this.state.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props, className = _this$props14.className, id = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return React6.createElement(SelectContainer3, _extends({}, commonProps, {
        className,
        innerProps: {
          id,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), React6.createElement(Control3, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), React6.createElement(ValueContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), React6.createElement(IndicatorsContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate, ariaSelection = state.ariaSelection, isFocused = state.isFocused, prevWasFocused = state.prevWasFocused, instancePrefix = state.instancePrefix;
      var options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusableOptionsWithIds = menuIsOpen ? buildFocusableOptionsWithIds(buildCategorizedOptions(props, selectValue), "".concat(instancePrefix, "-option")) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        var focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusedOption);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedOptionId,
          focusableOptionsWithIds,
          focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: "initial-input-focus"
        };
        hasKeptFocus = !prevWasFocused;
      }
      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus") {
        newAriaSelection = null;
      }
      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
  return Select3;
})(import_react8.Component);
Select2.defaultProps = defaultProps;

// node_modules/react-select/dist/react-select.esm.js
var import_react_dom4 = __toESM(require_react_dom());
var StateManagedSelect = (0, import_react10.forwardRef)(function(props, ref) {
  var baseSelectProps = useStateManager(props);
  return React7.createElement(Select2, _extends({
    ref
  }, baseSelectProps));
});
var StateManagedSelect$1 = StateManagedSelect;

// node_modules/react-virtuoso/dist/index.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);
var we = 0;
var zt = 1;
var qt = 2;
var kn = 4;
function un(t3) {
  return () => t3;
}
function fo(t3) {
  t3();
}
function ne(t3, e2) {
  return (n3) => t3(e2(n3));
}
function an(t3, e2) {
  return () => t3(e2);
}
function mo(t3, e2) {
  return (n3) => t3(e2, n3);
}
function We(t3) {
  return t3 !== void 0;
}
function po(...t3) {
  return () => {
    t3.map(fo);
  };
}
function Yt() {
}
function ve(t3, e2) {
  return e2(t3), t3;
}
function ho(t3, e2) {
  return e2(t3);
}
function X(...t3) {
  return t3;
}
function K(t3, e2) {
  return t3(zt, e2);
}
function G(t3, e2) {
  t3(we, e2);
}
function Ge(t3) {
  t3(qt);
}
function ot2(t3) {
  return t3(kn);
}
function O(t3, e2) {
  return K(t3, mo(e2, we));
}
function Tt(t3, e2) {
  const n3 = t3(zt, (o3) => {
    n3(), e2(o3);
  });
  return n3;
}
function dn(t3) {
  let e2, n3;
  return (o3) => (r3) => {
    e2 = r3, n3 && clearTimeout(n3), n3 = setTimeout(() => {
      o3(e2);
    }, t3);
  };
}
function Fn(t3, e2) {
  return t3 === e2;
}
function Z(t3 = Fn) {
  let e2;
  return (n3) => (o3) => {
    t3(e2, o3) || (e2 = o3, n3(o3));
  };
}
function A(t3) {
  return (e2) => (n3) => {
    t3(n3) && e2(n3);
  };
}
function E(t3) {
  return (e2) => ne(e2, t3);
}
function Rt(t3) {
  return (e2) => () => {
    e2(t3);
  };
}
function x(t3, ...e2) {
  const n3 = go(...e2);
  return (o3, r3) => {
    switch (o3) {
      case qt:
        Ge(t3);
        return;
      case zt:
        return K(t3, n3(r3));
    }
  };
}
function bt(t3, e2) {
  return (n3) => (o3) => {
    n3(e2 = t3(e2, o3));
  };
}
function Dt(t3) {
  return (e2) => (n3) => {
    t3 > 0 ? t3-- : e2(n3);
  };
}
function kt(t3) {
  let e2 = null, n3;
  return (o3) => (r3) => {
    e2 = r3, !n3 && (n3 = setTimeout(() => {
      n3 = void 0, o3(e2);
    }, t3));
  };
}
function N(...t3) {
  const e2 = new Array(t3.length);
  let n3 = 0, o3 = null;
  const r3 = Math.pow(2, t3.length) - 1;
  return t3.forEach((s3, i3) => {
    const l2 = Math.pow(2, i3);
    K(s3, (c4) => {
      const a2 = n3;
      n3 = n3 | l2, e2[i3] = c4, a2 !== r3 && n3 === r3 && o3 && (o3(), o3 = null);
    });
  }), (s3) => (i3) => {
    const l2 = () => {
      s3([i3].concat(e2));
    };
    n3 === r3 ? l2() : o3 = l2;
  };
}
function go(...t3) {
  return (e2) => t3.reduceRight(ho, e2);
}
function Io(t3) {
  let e2, n3;
  const o3 = () => e2 == null ? void 0 : e2();
  return function(r3, s3) {
    switch (r3) {
      case zt:
        return s3 ? n3 === s3 ? void 0 : (o3(), n3 = s3, e2 = K(t3, s3), e2) : (o3(), Yt);
      case qt:
        o3(), n3 = null;
        return;
    }
  };
}
function C(t3) {
  let e2 = t3;
  const n3 = $();
  return (o3, r3) => {
    switch (o3) {
      case we:
        e2 = r3;
        break;
      case zt: {
        r3(e2);
        break;
      }
      case kn:
        return e2;
    }
    return n3(o3, r3);
  };
}
function ct(t3, e2) {
  return ve(C(e2), (n3) => O(t3, n3));
}
function $() {
  const t3 = [];
  return (e2, n3) => {
    switch (e2) {
      case we:
        t3.slice().forEach((o3) => {
          o3(n3);
        });
        return;
      case qt:
        t3.splice(0, t3.length);
        return;
      case zt:
        return t3.push(n3), () => {
          const o3 = t3.indexOf(n3);
          o3 > -1 && t3.splice(o3, 1);
        };
    }
  };
}
function ht(t3) {
  return ve($(), (e2) => O(t3, e2));
}
function U(t3, e2 = [], { singleton: n3 } = { singleton: true }) {
  return {
    constructor: t3,
    dependencies: e2,
    id: So(),
    singleton: n3
  };
}
var So = () => Symbol();
function xo(t3) {
  const e2 = /* @__PURE__ */ new Map(), n3 = ({ constructor: o3, dependencies: r3, id: s3, singleton: i3 }) => {
    if (i3 && e2.has(s3))
      return e2.get(s3);
    const l2 = o3(r3.map((c4) => n3(c4)));
    return i3 && e2.set(s3, l2), l2;
  };
  return n3(t3);
}
function rt(...t3) {
  const e2 = $(), n3 = new Array(t3.length);
  let o3 = 0;
  const r3 = Math.pow(2, t3.length) - 1;
  return t3.forEach((s3, i3) => {
    const l2 = Math.pow(2, i3);
    K(s3, (c4) => {
      n3[i3] = c4, o3 = o3 | l2, o3 === r3 && G(e2, n3);
    });
  }), function(s3, i3) {
    switch (s3) {
      case qt: {
        Ge(e2);
        return;
      }
      case zt:
        return o3 === r3 && i3(n3), K(e2, i3);
    }
  };
}
function V(t3, e2 = Fn) {
  return x(t3, Z(e2));
}
function Le(...t3) {
  return function(e2, n3) {
    switch (e2) {
      case qt:
        return;
      case zt:
        return po(...t3.map((o3) => K(o3, n3)));
    }
  };
}
var mt2 = ((t3) => (t3[t3.DEBUG = 0] = "DEBUG", t3[t3.INFO = 1] = "INFO", t3[t3.WARN = 2] = "WARN", t3[t3.ERROR = 3] = "ERROR", t3))(mt2 || {});
var To = {
  0: "debug",
  3: "error",
  1: "log",
  2: "warn"
};
var Co = () => typeof globalThis > "u" ? window : globalThis;
var Vt = U(
  () => {
    const t3 = C(
      3
      /* ERROR */
    );
    return {
      log: C((n3, o3, r3 = 1) => {
        var i3;
        const s3 = (i3 = Co().VIRTUOSO_LOG_LEVEL) != null ? i3 : ot2(t3);
        r3 >= s3 && console[To[r3]](
          "%creact-virtuoso: %c%s %o",
          "color: #0253b3; font-weight: bold",
          "color: initial",
          n3,
          o3
        );
      }),
      logLevel: t3
    };
  },
  [],
  { singleton: true }
);
function Ht(t3, e2, n3) {
  return _e(t3, e2, n3).callbackRef;
}
function _e(t3, e2, n3) {
  const o3 = import_react12.default.useRef(null);
  let r3 = (i3) => {
  };
  const s3 = import_react12.default.useMemo(() => typeof ResizeObserver < "u" ? new ResizeObserver((i3) => {
    const l2 = () => {
      const c4 = i3[0].target;
      c4.offsetParent !== null && t3(c4);
    };
    n3 ? l2() : requestAnimationFrame(l2);
  }) : null, [t3, n3]);
  return r3 = (i3) => {
    i3 && e2 ? (s3 == null || s3.observe(i3), o3.current = i3) : (o3.current && (s3 == null || s3.unobserve(o3.current)), o3.current = null);
  }, { callbackRef: r3, ref: o3 };
}
function On(t3, e2, n3, o3, r3, s3, i3, l2, c4) {
  const a2 = import_react12.default.useCallback(
    (m2) => {
      const S3 = wo(m2.children, e2, l2 ? "offsetWidth" : "offsetHeight", r3);
      let g2 = m2.parentElement;
      for (; !g2.dataset.virtuosoScroller; )
        g2 = g2.parentElement;
      const I = g2.lastElementChild.dataset.viewportType === "window";
      let w3;
      I && (w3 = g2.ownerDocument.defaultView);
      const v2 = i3 ? l2 ? i3.scrollLeft : i3.scrollTop : I ? l2 ? w3.scrollX || w3.document.documentElement.scrollLeft : w3.scrollY || w3.document.documentElement.scrollTop : l2 ? g2.scrollLeft : g2.scrollTop, h2 = i3 ? l2 ? i3.scrollWidth : i3.scrollHeight : I ? l2 ? w3.document.documentElement.scrollWidth : w3.document.documentElement.scrollHeight : l2 ? g2.scrollWidth : g2.scrollHeight, p2 = i3 ? l2 ? i3.offsetWidth : i3.offsetHeight : I ? l2 ? w3.innerWidth : w3.innerHeight : l2 ? g2.offsetWidth : g2.offsetHeight;
      o3({
        scrollHeight: h2,
        scrollTop: Math.max(v2, 0),
        viewportHeight: p2
      }), s3 == null || s3(
        l2 ? fn("column-gap", getComputedStyle(m2).columnGap, r3) : fn("row-gap", getComputedStyle(m2).rowGap, r3)
      ), S3 !== null && t3(S3);
    },
    [t3, e2, r3, s3, i3, o3, l2]
  );
  return _e(a2, n3, c4);
}
function wo(t3, e2, n3, o3) {
  const r3 = t3.length;
  if (r3 === 0)
    return null;
  const s3 = [];
  for (let i3 = 0; i3 < r3; i3++) {
    const l2 = t3.item(i3);
    if (l2.dataset.index === void 0)
      continue;
    const c4 = parseInt(l2.dataset.index), a2 = parseFloat(l2.dataset.knownSize), m2 = e2(l2, n3);
    if (m2 === 0 && o3("Zero-sized element, this should not happen", { child: l2 }, mt2.ERROR), m2 === a2)
      continue;
    const S3 = s3[s3.length - 1];
    s3.length === 0 || S3.size !== m2 || S3.endIndex !== c4 - 1 ? s3.push({ endIndex: c4, size: m2, startIndex: c4 }) : s3[s3.length - 1].endIndex++;
  }
  return s3;
}
function fn(t3, e2, n3) {
  return e2 !== "normal" && !(e2 != null && e2.endsWith("px")) && n3(`${t3} was not resolved to pixel value correctly`, e2, mt2.WARN), e2 === "normal" ? 0 : parseInt(e2 != null ? e2 : "0", 10);
}
function Ne(t3, e2, n3) {
  const o3 = import_react12.default.useRef(null), r3 = import_react12.default.useCallback(
    (c4) => {
      if (!(c4 != null && c4.offsetParent))
        return;
      const a2 = c4.getBoundingClientRect(), m2 = a2.width;
      let S3, g2;
      if (e2) {
        const I = e2.getBoundingClientRect(), w3 = a2.top - I.top;
        g2 = I.height - Math.max(0, w3), S3 = w3 + e2.scrollTop;
      } else {
        const I = i3.current.ownerDocument.defaultView;
        g2 = I.innerHeight - Math.max(0, a2.top), S3 = a2.top + I.scrollY;
      }
      o3.current = {
        offsetTop: S3,
        visibleHeight: g2,
        visibleWidth: m2
      }, t3(o3.current);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t3, e2]
  ), { callbackRef: s3, ref: i3 } = _e(r3, true, n3), l2 = import_react12.default.useCallback(() => {
    r3(i3.current);
  }, [r3, i3]);
  return import_react12.default.useEffect(() => {
    var c4;
    if (e2) {
      e2.addEventListener("scroll", l2);
      const a2 = new ResizeObserver(() => {
        requestAnimationFrame(l2);
      });
      return a2.observe(e2), () => {
        e2.removeEventListener("scroll", l2), a2.unobserve(e2);
      };
    } else {
      const a2 = (c4 = i3.current) == null ? void 0 : c4.ownerDocument.defaultView;
      return a2 == null || a2.addEventListener("scroll", l2), a2 == null || a2.addEventListener("resize", l2), () => {
        a2 == null || a2.removeEventListener("scroll", l2), a2 == null || a2.removeEventListener("resize", l2);
      };
    }
  }, [l2, e2, i3]), s3;
}
var at = U(
  () => {
    const t3 = $(), e2 = $(), n3 = C(0), o3 = $(), r3 = C(0), s3 = $(), i3 = $(), l2 = C(0), c4 = C(0), a2 = C(0), m2 = C(0), S3 = $(), g2 = $(), I = C(false), w3 = C(false), v2 = C(false);
    return O(
      x(
        t3,
        E(({ scrollTop: h2 }) => h2)
      ),
      e2
    ), O(
      x(
        t3,
        E(({ scrollHeight: h2 }) => h2)
      ),
      i3
    ), O(e2, r3), {
      deviation: n3,
      fixedFooterHeight: a2,
      fixedHeaderHeight: c4,
      footerHeight: m2,
      headerHeight: l2,
      horizontalDirection: w3,
      scrollBy: g2,
      // input
      scrollContainerState: t3,
      scrollHeight: i3,
      scrollingInProgress: I,
      // signals
      scrollTo: S3,
      scrollTop: e2,
      skipAnimationFrameInResizeObserver: v2,
      smoothScrollTargetReached: o3,
      // state
      statefulScrollTop: r3,
      viewportHeight: s3
    };
  },
  [],
  { singleton: true }
);
var oe = { lvl: 0 };
function Ln(t3, e2) {
  const n3 = t3.length;
  if (n3 === 0)
    return [];
  let { index: o3, value: r3 } = e2(t3[0]);
  const s3 = [];
  for (let i3 = 1; i3 < n3; i3++) {
    const { index: l2, value: c4 } = e2(t3[i3]);
    s3.push({ end: l2 - 1, start: o3, value: r3 }), o3 = l2, r3 = c4;
  }
  return s3.push({ end: 1 / 0, start: o3, value: r3 }), s3;
}
function j(t3) {
  return t3 === oe;
}
function re(t3, e2) {
  if (!j(t3))
    return e2 === t3.k ? t3.v : e2 < t3.k ? re(t3.l, e2) : re(t3.r, e2);
}
function wt(t3, e2, n3 = "k") {
  if (j(t3))
    return [-1 / 0, void 0];
  if (Number(t3[n3]) === e2)
    return [t3.k, t3.v];
  if (Number(t3[n3]) < e2) {
    const o3 = wt(t3.r, e2, n3);
    return o3[0] === -1 / 0 ? [t3.k, t3.v] : o3;
  }
  return wt(t3.l, e2, n3);
}
function pt(t3, e2, n3) {
  return j(t3) ? Pn(e2, n3, 1) : e2 === t3.k ? st(t3, { k: e2, v: n3 }) : e2 < t3.k ? mn(st(t3, { l: pt(t3.l, e2, n3) })) : mn(st(t3, { r: pt(t3.r, e2, n3) }));
}
function jt() {
  return oe;
}
function ye(t3, e2, n3) {
  if (j(t3))
    return [];
  const o3 = wt(t3, e2)[0];
  return vo(Ve(t3, o3, n3));
}
function ze(t3, e2) {
  if (j(t3)) return oe;
  const { k: n3, l: o3, r: r3 } = t3;
  if (e2 === n3) {
    if (j(o3))
      return r3;
    if (j(r3))
      return o3;
    {
      const [s3, i3] = Vn(o3);
      return ge(st(t3, { k: s3, l: zn(o3), v: i3 }));
    }
  } else return e2 < n3 ? ge(st(t3, { l: ze(o3, e2) })) : ge(st(t3, { r: ze(r3, e2) }));
}
function Gt(t3) {
  return j(t3) ? [] : [...Gt(t3.l), { k: t3.k, v: t3.v }, ...Gt(t3.r)];
}
function Ve(t3, e2, n3) {
  if (j(t3))
    return [];
  const { k: o3, l: r3, r: s3, v: i3 } = t3;
  let l2 = [];
  return o3 > e2 && (l2 = l2.concat(Ve(r3, e2, n3))), o3 >= e2 && o3 <= n3 && l2.push({ k: o3, v: i3 }), o3 <= n3 && (l2 = l2.concat(Ve(s3, e2, n3))), l2;
}
function ge(t3) {
  const { l: e2, lvl: n3, r: o3 } = t3;
  if (o3.lvl >= n3 - 1 && e2.lvl >= n3 - 1)
    return t3;
  if (n3 > o3.lvl + 1) {
    if (Ee(e2))
      return An(st(t3, { lvl: n3 - 1 }));
    if (!j(e2) && !j(e2.r))
      return st(e2.r, {
        l: st(e2, { r: e2.r.l }),
        lvl: n3,
        r: st(t3, {
          l: e2.r.r,
          lvl: n3 - 1
        })
      });
    throw new Error("Unexpected empty nodes");
  } else {
    if (Ee(t3))
      return Pe(st(t3, { lvl: n3 - 1 }));
    if (!j(o3) && !j(o3.l)) {
      const r3 = o3.l, s3 = Ee(r3) ? o3.lvl - 1 : o3.lvl;
      return st(r3, {
        l: st(t3, {
          lvl: n3 - 1,
          r: r3.l
        }),
        lvl: r3.lvl + 1,
        r: Pe(st(o3, { l: r3.r, lvl: s3 }))
      });
    } else
      throw new Error("Unexpected empty nodes");
  }
}
function st(t3, e2) {
  return Pn(
    e2.k !== void 0 ? e2.k : t3.k,
    e2.v !== void 0 ? e2.v : t3.v,
    e2.lvl !== void 0 ? e2.lvl : t3.lvl,
    e2.l !== void 0 ? e2.l : t3.l,
    e2.r !== void 0 ? e2.r : t3.r
  );
}
function zn(t3) {
  return j(t3.r) ? t3.l : ge(st(t3, { r: zn(t3.r) }));
}
function Ee(t3) {
  return j(t3) || t3.lvl > t3.r.lvl;
}
function Vn(t3) {
  return j(t3.r) ? [t3.k, t3.v] : Vn(t3.r);
}
function Pn(t3, e2, n3, o3 = oe, r3 = oe) {
  return { k: t3, l: o3, lvl: n3, r: r3, v: e2 };
}
function mn(t3) {
  return Pe(An(t3));
}
function An(t3) {
  const { l: e2 } = t3;
  return !j(e2) && e2.lvl === t3.lvl ? st(e2, { r: st(t3, { l: e2.r }) }) : t3;
}
function Pe(t3) {
  const { lvl: e2, r: n3 } = t3;
  return !j(n3) && !j(n3.r) && n3.lvl === e2 && n3.r.lvl === e2 ? st(n3, { l: st(t3, { r: n3.l }), lvl: e2 + 1 }) : t3;
}
function vo(t3) {
  return Ln(t3, ({ k: e2, v: n3 }) => ({ index: e2, value: n3 }));
}
function Mn(t3, e2) {
  return !!(t3 && t3.startIndex === e2.startIndex && t3.endIndex === e2.endIndex);
}
function se(t3, e2) {
  return !!(t3 && t3[0] === e2[0] && t3[1] === e2[1]);
}
var De = U(
  () => ({ recalcInProgress: C(false) }),
  [],
  { singleton: true }
);
function Wn(t3, e2, n3) {
  return t3[Se(t3, e2, n3)];
}
function Se(t3, e2, n3, o3 = 0) {
  let r3 = t3.length - 1;
  for (; o3 <= r3; ) {
    const s3 = Math.floor((o3 + r3) / 2), i3 = t3[s3], l2 = n3(i3, e2);
    if (l2 === 0)
      return s3;
    if (l2 === -1) {
      if (r3 - o3 < 2)
        return s3 - 1;
      r3 = s3 - 1;
    } else {
      if (r3 === o3)
        return s3;
      o3 = s3 + 1;
    }
  }
  throw new Error(`Failed binary finding record in array - ${t3.join(",")}, searched for ${e2}`);
}
function yo(t3, e2, n3, o3) {
  const r3 = Se(t3, e2, o3), s3 = Se(t3, n3, o3, r3);
  return t3.slice(r3, s3 + 1);
}
function vt(t3, e2) {
  return Math.round(t3.getBoundingClientRect()[e2]);
}
function Re(t3) {
  return !j(t3.groupOffsetTree);
}
function $e({ index: t3 }, e2) {
  return e2 === t3 ? 0 : e2 < t3 ? -1 : 1;
}
function Ro() {
  return {
    groupIndices: [],
    groupOffsetTree: jt(),
    lastIndex: 0,
    lastOffset: 0,
    lastSize: 0,
    offsetTree: [],
    sizeTree: jt()
  };
}
function bo(t3, e2) {
  let n3 = j(t3) ? 0 : 1 / 0;
  for (const o3 of e2) {
    const { endIndex: r3, size: s3, startIndex: i3 } = o3;
    if (n3 = Math.min(n3, i3), j(t3)) {
      t3 = pt(t3, 0, s3);
      continue;
    }
    const l2 = ye(t3, i3 - 1, r3 + 1);
    if (l2.some(Lo(o3)))
      continue;
    let c4 = false, a2 = false;
    for (const { end: m2, start: S3, value: g2 } of l2)
      c4 ? (r3 >= S3 || s3 === g2) && (t3 = ze(t3, S3)) : (a2 = g2 !== s3, c4 = true), m2 > r3 && r3 >= S3 && g2 !== s3 && (t3 = pt(t3, r3 + 1, g2));
    a2 && (t3 = pt(t3, i3, s3));
  }
  return [t3, n3];
}
function Ho(t3) {
  return typeof t3.groupIndex < "u";
}
function Eo({ offset: t3 }, e2) {
  return e2 === t3 ? 0 : e2 < t3 ? -1 : 1;
}
function ie(t3, e2, n3) {
  if (e2.length === 0)
    return 0;
  const { index: o3, offset: r3, size: s3 } = Wn(e2, t3, $e), i3 = t3 - o3, l2 = s3 * i3 + (i3 - 1) * n3 + r3;
  return l2 > 0 ? l2 + n3 : l2;
}
function Gn(t3, e2) {
  if (!Re(e2))
    return t3;
  let n3 = 0;
  for (; e2.groupIndices[n3] <= t3 + n3; )
    n3++;
  return t3 + n3;
}
function _n(t3, e2, n3) {
  if (Ho(t3))
    return e2.groupIndices[t3.groupIndex] + 1;
  {
    const o3 = t3.index === "LAST" ? n3 : t3.index;
    let r3 = Gn(o3, e2);
    return r3 = Math.max(0, r3, Math.min(n3, r3)), r3;
  }
}
function Bo(t3, e2, n3, o3 = 0) {
  return o3 > 0 && (e2 = Math.max(e2, Wn(t3, o3, $e).offset)), Ln(yo(t3, e2, n3, Eo), Oo);
}
function ko(t3, [e2, n3, o3, r3]) {
  e2.length > 0 && o3("received item sizes", e2, mt2.DEBUG);
  const s3 = t3.sizeTree;
  let i3 = s3, l2 = 0;
  if (n3.length > 0 && j(s3) && e2.length === 2) {
    const g2 = e2[0].size, I = e2[1].size;
    i3 = n3.reduce((w3, v2) => pt(pt(w3, v2, g2), v2 + 1, I), i3);
  } else
    [i3, l2] = bo(i3, e2);
  if (i3 === s3)
    return t3;
  const { lastIndex: c4, lastOffset: a2, lastSize: m2, offsetTree: S3 } = Ae(t3.offsetTree, l2, i3, r3);
  return {
    groupIndices: n3,
    groupOffsetTree: n3.reduce((g2, I) => pt(g2, I, ie(I, S3, r3)), jt()),
    lastIndex: c4,
    lastOffset: a2,
    lastSize: m2,
    offsetTree: S3,
    sizeTree: i3
  };
}
function Fo(t3) {
  return Gt(t3).map(({ k: e2, v: n3 }, o3, r3) => {
    const s3 = r3[o3 + 1];
    return { endIndex: s3 ? s3.k - 1 : 1 / 0, size: n3, startIndex: e2 };
  });
}
function pn(t3, e2) {
  let n3 = 0, o3 = 0;
  for (; n3 < t3; )
    n3 += e2[o3 + 1] - e2[o3] - 1, o3++;
  return o3 - (n3 === t3 ? 0 : 1);
}
function Ae(t3, e2, n3, o3) {
  let r3 = t3, s3 = 0, i3 = 0, l2 = 0, c4 = 0;
  if (e2 !== 0) {
    c4 = Se(r3, e2 - 1, $e), l2 = r3[c4].offset;
    const m2 = wt(n3, e2 - 1);
    s3 = m2[0], i3 = m2[1], r3.length && r3[c4].size === wt(n3, e2)[1] && (c4 -= 1), r3 = r3.slice(0, c4 + 1);
  } else
    r3 = [];
  for (const { start: a2, value: m2 } of ye(n3, e2, 1 / 0)) {
    const S3 = a2 - s3, g2 = S3 * i3 + l2 + S3 * o3;
    r3.push({
      index: a2,
      offset: g2,
      size: m2
    }), s3 = a2, l2 = g2, i3 = m2;
  }
  return {
    lastIndex: s3,
    lastOffset: l2,
    lastSize: i3,
    offsetTree: r3
  };
}
function Oo(t3) {
  return { index: t3.index, value: t3 };
}
function Lo(t3) {
  const { endIndex: e2, size: n3, startIndex: o3 } = t3;
  return (r3) => r3.start === o3 && (r3.end === e2 || r3.end === 1 / 0) && r3.value === n3;
}
var zo = {
  offsetHeight: "height",
  offsetWidth: "width"
};
var Et = U(
  ([{ log: t3 }, { recalcInProgress: e2 }]) => {
    const n3 = $(), o3 = $(), r3 = ct(o3, 0), s3 = $(), i3 = $(), l2 = C(0), c4 = C([]), a2 = C(void 0), m2 = C(void 0), S3 = C((f2, d2) => vt(f2, zo[d2])), g2 = C(void 0), I = C(0), w3 = Ro(), v2 = ct(
      x(n3, N(c4, t3, I), bt(ko, w3), Z()),
      w3
    ), h2 = ct(
      x(
        c4,
        Z(),
        bt((f2, d2) => ({ current: d2, prev: f2.current }), {
          current: [],
          prev: []
        }),
        E(({ prev: f2 }) => f2)
      ),
      []
    );
    O(
      x(
        c4,
        A((f2) => f2.length > 0),
        N(v2, I),
        E(([f2, d2, y2]) => {
          const B = f2.reduce((k2, L, z) => pt(k2, L, ie(L, d2.offsetTree, y2) || z), jt());
          return {
            ...d2,
            groupIndices: f2,
            groupOffsetTree: B
          };
        })
      ),
      v2
    ), O(
      x(
        o3,
        N(v2),
        A(([f2, { lastIndex: d2 }]) => f2 < d2),
        E(([f2, { lastIndex: d2, lastSize: y2 }]) => [
          {
            endIndex: d2,
            size: y2,
            startIndex: f2
          }
        ])
      ),
      n3
    ), O(a2, m2);
    const p2 = ct(
      x(
        a2,
        E((f2) => f2 === void 0)
      ),
      true
    );
    O(
      x(
        m2,
        A((f2) => f2 !== void 0 && j(ot2(v2).sizeTree)),
        E((f2) => [{ endIndex: 0, size: f2, startIndex: 0 }])
      ),
      n3
    );
    const u2 = ht(
      x(
        n3,
        N(v2),
        bt(
          ({ sizes: f2 }, [d2, y2]) => ({
            changed: y2 !== f2,
            sizes: y2
          }),
          { changed: false, sizes: w3 }
        ),
        E((f2) => f2.changed)
      )
    );
    K(
      x(
        l2,
        bt(
          (f2, d2) => ({ diff: f2.prev - d2, prev: d2 }),
          { diff: 0, prev: 0 }
        ),
        E((f2) => f2.diff)
      ),
      (f2) => {
        const { groupIndices: d2 } = ot2(v2);
        if (f2 > 0)
          G(e2, true), G(s3, f2 + pn(f2, d2));
        else if (f2 < 0) {
          const y2 = ot2(h2);
          y2.length > 0 && (f2 -= pn(-f2, y2)), G(i3, f2);
        }
      }
    ), K(x(l2, N(t3)), ([f2, d2]) => {
      f2 < 0 && d2(
        "`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value",
        { firstItemIndex: l2 },
        mt2.ERROR
      );
    });
    const T = ht(s3);
    O(
      x(
        s3,
        N(v2),
        E(([f2, d2]) => {
          const y2 = d2.groupIndices.length > 0, B = [], k2 = d2.lastSize;
          if (y2) {
            const L = re(d2.sizeTree, 0);
            let z = 0, _ = 0;
            for (; z < f2; ) {
              const F = d2.groupIndices[_], Y = d2.groupIndices.length === _ + 1 ? 1 / 0 : d2.groupIndices[_ + 1] - F - 1;
              B.push({
                endIndex: F,
                size: L,
                startIndex: F
              }), B.push({
                endIndex: F + 1 + Y - 1,
                size: k2,
                startIndex: F + 1
              }), _++, z += Y + 1;
            }
            const J = Gt(d2.sizeTree);
            return z !== f2 && J.shift(), J.reduce(
              (F, { k: Y, v: it }) => {
                let dt2 = F.ranges;
                return F.prevSize !== 0 && (dt2 = [
                  ...F.ranges,
                  {
                    endIndex: Y + f2 - 1,
                    size: F.prevSize,
                    startIndex: F.prevIndex
                  }
                ]), {
                  prevIndex: Y + f2,
                  prevSize: it,
                  ranges: dt2
                };
              },
              {
                prevIndex: f2,
                prevSize: 0,
                ranges: B
              }
            ).ranges;
          }
          return Gt(d2.sizeTree).reduce(
            (L, { k: z, v: _ }) => ({
              prevIndex: z + f2,
              prevSize: _,
              ranges: [...L.ranges, { endIndex: z + f2 - 1, size: L.prevSize, startIndex: L.prevIndex }]
            }),
            {
              prevIndex: 0,
              prevSize: k2,
              ranges: []
            }
          ).ranges;
        })
      ),
      n3
    );
    const b2 = ht(
      x(
        i3,
        N(v2, I),
        E(([f2, { offsetTree: d2 }, y2]) => {
          const B = -f2;
          return ie(B, d2, y2);
        })
      )
    );
    return O(
      x(
        i3,
        N(v2, I),
        E(([f2, d2, y2]) => {
          if (d2.groupIndices.length > 0) {
            if (j(d2.sizeTree))
              return d2;
            let k2 = jt();
            const L = ot2(h2);
            let z = 0, _ = 0, J = 0;
            for (; z < -f2; ) {
              J = L[_];
              const F = L[_ + 1] - J - 1;
              _++, z += F + 1;
            }
            if (k2 = Gt(d2.sizeTree).reduce((F, { k: Y, v: it }) => pt(F, Math.max(0, Y + f2), it), k2), z !== -f2) {
              const F = re(d2.sizeTree, J);
              k2 = pt(k2, 0, F);
              const Y = wt(d2.sizeTree, -f2 + 1)[1];
              k2 = pt(k2, 1, Y);
            }
            return {
              ...d2,
              sizeTree: k2,
              ...Ae(d2.offsetTree, 0, k2, y2)
            };
          } else {
            const k2 = Gt(d2.sizeTree).reduce((L, { k: z, v: _ }) => pt(L, Math.max(0, z + f2), _), jt());
            return {
              ...d2,
              sizeTree: k2,
              ...Ae(d2.offsetTree, 0, k2, y2)
            };
          }
        })
      ),
      v2
    ), {
      beforeUnshiftWith: T,
      // input
      data: g2,
      defaultItemSize: m2,
      firstItemIndex: l2,
      fixedItemSize: a2,
      gap: I,
      groupIndices: c4,
      itemSize: S3,
      listRefresh: u2,
      shiftWith: i3,
      shiftWithOffset: b2,
      sizeRanges: n3,
      // output
      sizes: v2,
      statefulTotalCount: r3,
      totalCount: o3,
      trackItemSizes: p2,
      unshiftWith: s3
    };
  },
  X(Vt, De),
  { singleton: true }
);
function Vo(t3) {
  return t3.reduce(
    (e2, n3) => (e2.groupIndices.push(e2.totalCount), e2.totalCount += n3 + 1, e2),
    {
      groupIndices: [],
      totalCount: 0
    }
  );
}
var Nn = U(
  ([{ groupIndices: t3, sizes: e2, totalCount: n3 }, { headerHeight: o3, scrollTop: r3 }]) => {
    const s3 = $(), i3 = $(), l2 = ht(x(s3, E(Vo)));
    return O(
      x(
        l2,
        E((c4) => c4.totalCount)
      ),
      n3
    ), O(
      x(
        l2,
        E((c4) => c4.groupIndices)
      ),
      t3
    ), O(
      x(
        rt(r3, e2, o3),
        A(([c4, a2]) => Re(a2)),
        E(([c4, a2, m2]) => wt(a2.groupOffsetTree, Math.max(c4 - m2, 0), "v")[0]),
        Z(),
        E((c4) => [c4])
      ),
      i3
    ), { groupCounts: s3, topItemsIndexes: i3 };
  },
  X(Et, at)
);
var Pt = U(
  ([{ log: t3 }]) => {
    const e2 = C(false), n3 = ht(
      x(
        e2,
        A((o3) => o3),
        Z()
      )
    );
    return K(e2, (o3) => {
      o3 && ot2(t3)("props updated", {}, mt2.DEBUG);
    }), { didMount: n3, propsReady: e2 };
  },
  X(Vt),
  { singleton: true }
);
var Po = typeof document < "u" && "scrollBehavior" in document.documentElement.style;
function Dn(t3) {
  const e2 = typeof t3 == "number" ? { index: t3 } : t3;
  return e2.align || (e2.align = "start"), (!e2.behavior || !Po) && (e2.behavior = "auto"), e2.offset || (e2.offset = 0), e2;
}
var ce = U(
  ([
    { gap: t3, listRefresh: e2, sizes: n3, totalCount: o3 },
    {
      fixedFooterHeight: r3,
      fixedHeaderHeight: s3,
      footerHeight: i3,
      headerHeight: l2,
      scrollingInProgress: c4,
      scrollTo: a2,
      smoothScrollTargetReached: m2,
      viewportHeight: S3
    },
    { log: g2 }
  ]) => {
    const I = $(), w3 = $(), v2 = C(0);
    let h2 = null, p2 = null, u2 = null;
    function T() {
      h2 && (h2(), h2 = null), u2 && (u2(), u2 = null), p2 && (clearTimeout(p2), p2 = null), G(c4, false);
    }
    return O(
      x(
        I,
        N(n3, S3, o3, v2, l2, i3, g2),
        N(t3, s3, r3),
        E(
          ([
            [b2, f2, d2, y2, B, k2, L, z],
            _,
            J,
            nt2
          ]) => {
            const F = Dn(b2), { align: Y, behavior: it, offset: dt2 } = F, St = y2 - 1, ft2 = _n(F, f2, St);
            let ut = ie(ft2, f2.offsetTree, _) + k2;
            Y === "end" ? (ut += J + wt(f2.sizeTree, ft2)[1] - d2 + nt2, ft2 === St && (ut += L)) : Y === "center" ? ut += (J + wt(f2.sizeTree, ft2)[1] - d2 + nt2) / 2 : ut -= B, dt2 && (ut += dt2);
            const At = (xt) => {
              T(), xt ? (z("retrying to scroll to", { location: b2 }, mt2.DEBUG), G(I, b2)) : (G(w3, true), z("list did not change, scroll successful", {}, mt2.DEBUG));
            };
            if (T(), it === "smooth") {
              let xt = false;
              u2 = K(e2, (Xt) => {
                xt = xt || Xt;
              }), h2 = Tt(m2, () => {
                At(xt);
              });
            } else
              h2 = Tt(x(e2, Ao(150)), At);
            return p2 = setTimeout(() => {
              T();
            }, 1200), G(c4, true), z("scrolling from index to", { behavior: it, index: ft2, top: ut }, mt2.DEBUG), { behavior: it, top: ut };
          }
        )
      ),
      a2
    ), {
      scrollTargetReached: w3,
      scrollToIndex: I,
      topListHeight: v2
    };
  },
  X(Et, at, Vt),
  { singleton: true }
);
function Ao(t3) {
  return (e2) => {
    const n3 = setTimeout(() => {
      e2(false);
    }, t3);
    return (o3) => {
      o3 && (e2(true), clearTimeout(n3));
    };
  };
}
function Ue(t3, e2) {
  t3 == 0 ? e2() : requestAnimationFrame(() => {
    Ue(t3 - 1, e2);
  });
}
function Ke(t3, e2) {
  const n3 = e2 - 1;
  return typeof t3 == "number" ? t3 : t3.index === "LAST" ? n3 : t3.index;
}
var ue = U(
  ([{ defaultItemSize: t3, listRefresh: e2, sizes: n3 }, { scrollTop: o3 }, { scrollTargetReached: r3, scrollToIndex: s3 }, { didMount: i3 }]) => {
    const l2 = C(true), c4 = C(0), a2 = C(true);
    return O(
      x(
        i3,
        N(c4),
        A(([m2, S3]) => !!S3),
        Rt(false)
      ),
      l2
    ), O(
      x(
        i3,
        N(c4),
        A(([m2, S3]) => !!S3),
        Rt(false)
      ),
      a2
    ), K(
      x(
        rt(e2, i3),
        N(l2, n3, t3, a2),
        A(([[, m2], S3, { sizeTree: g2 }, I, w3]) => m2 && (!j(g2) || We(I)) && !S3 && !w3),
        N(c4)
      ),
      ([, m2]) => {
        Tt(r3, () => {
          G(a2, true);
        }), Ue(4, () => {
          Tt(o3, () => {
            G(l2, true);
          }), G(s3, m2);
        });
      }
    ), {
      initialItemFinalLocationReached: a2,
      initialTopMostItemIndex: c4,
      scrolledToInitialItem: l2
    };
  },
  X(Et, at, ce, Pt),
  { singleton: true }
);
function $n(t3, e2) {
  return Math.abs(t3 - e2) < 1.01;
}
var le = "up";
var te = "down";
var Mo = "none";
var Wo = {
  atBottom: false,
  notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
  state: {
    offsetBottom: 0,
    scrollHeight: 0,
    scrollTop: 0,
    viewportHeight: 0
  }
};
var Go = 0;
var ae = U(([{ footerHeight: t3, headerHeight: e2, scrollBy: n3, scrollContainerState: o3, scrollTop: r3, viewportHeight: s3 }]) => {
  const i3 = C(false), l2 = C(true), c4 = $(), a2 = $(), m2 = C(4), S3 = C(Go), g2 = ct(
    x(
      Le(x(V(r3), Dt(1), Rt(true)), x(V(r3), Dt(1), Rt(false), dn(100))),
      Z()
    ),
    false
  ), I = ct(
    x(Le(x(n3, Rt(true)), x(n3, Rt(false), dn(200))), Z()),
    false
  );
  O(
    x(
      rt(V(r3), V(S3)),
      E(([u2, T]) => u2 <= T),
      Z()
    ),
    l2
  ), O(x(l2, kt(50)), a2);
  const w3 = ht(
    x(
      rt(o3, V(s3), V(e2), V(t3), V(m2)),
      bt((u2, [{ scrollHeight: T, scrollTop: b2 }, f2, d2, y2, B]) => {
        const k2 = b2 + f2 - T > -B, L = {
          scrollHeight: T,
          scrollTop: b2,
          viewportHeight: f2
        };
        if (k2) {
          let _, J;
          return b2 > u2.state.scrollTop ? (_ = "SCROLLED_DOWN", J = u2.state.scrollTop - b2) : (_ = "SIZE_DECREASED", J = u2.state.scrollTop - b2 || u2.scrollTopDelta), {
            atBottom: true,
            atBottomBecause: _,
            scrollTopDelta: J,
            state: L
          };
        }
        let z;
        return L.scrollHeight > u2.state.scrollHeight ? z = "SIZE_INCREASED" : f2 < u2.state.viewportHeight ? z = "VIEWPORT_HEIGHT_DECREASING" : b2 < u2.state.scrollTop ? z = "SCROLLING_UPWARDS" : z = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM", {
          atBottom: false,
          notAtBottomBecause: z,
          state: L
        };
      }, Wo),
      Z((u2, T) => u2 && u2.atBottom === T.atBottom)
    )
  ), v2 = ct(
    x(
      o3,
      bt(
        (u2, { scrollHeight: T, scrollTop: b2, viewportHeight: f2 }) => {
          if ($n(u2.scrollHeight, T))
            return {
              changed: false,
              jump: 0,
              scrollHeight: T,
              scrollTop: b2
            };
          {
            const d2 = T - (b2 + f2) < 1;
            return u2.scrollTop !== b2 && d2 ? {
              changed: true,
              jump: u2.scrollTop - b2,
              scrollHeight: T,
              scrollTop: b2
            } : {
              changed: true,
              jump: 0,
              scrollHeight: T,
              scrollTop: b2
            };
          }
        },
        { changed: false, jump: 0, scrollHeight: 0, scrollTop: 0 }
      ),
      A((u2) => u2.changed),
      E((u2) => u2.jump)
    ),
    0
  );
  O(
    x(
      w3,
      E((u2) => u2.atBottom)
    ),
    i3
  ), O(x(i3, kt(50)), c4);
  const h2 = C(te);
  O(
    x(
      o3,
      E(({ scrollTop: u2 }) => u2),
      Z(),
      bt(
        (u2, T) => ot2(I) ? { direction: u2.direction, prevScrollTop: T } : { direction: T < u2.prevScrollTop ? le : te, prevScrollTop: T },
        { direction: te, prevScrollTop: 0 }
      ),
      E((u2) => u2.direction)
    ),
    h2
  ), O(x(o3, kt(50), Rt(Mo)), h2);
  const p2 = C(0);
  return O(
    x(
      g2,
      A((u2) => !u2),
      Rt(0)
    ),
    p2
  ), O(
    x(
      r3,
      kt(100),
      N(g2),
      A(([u2, T]) => !!T),
      bt(([u2, T], [b2]) => [T, b2], [0, 0]),
      E(([u2, T]) => T - u2)
    ),
    p2
  ), {
    atBottomState: w3,
    atBottomStateChange: c4,
    atBottomThreshold: m2,
    atTopStateChange: a2,
    atTopThreshold: S3,
    isAtBottom: i3,
    isAtTop: l2,
    isScrolling: g2,
    lastJumpDueToItemResize: v2,
    scrollDirection: h2,
    scrollVelocity: p2
  };
}, X(at));
var xe = "top";
var Te = "bottom";
var hn = "none";
function gn(t3, e2, n3) {
  return typeof t3 == "number" ? n3 === le && e2 === xe || n3 === te && e2 === Te ? t3 : 0 : n3 === le ? e2 === xe ? t3.main : t3.reverse : e2 === Te ? t3.main : t3.reverse;
}
function In(t3, e2) {
  var n3;
  return typeof t3 == "number" ? t3 : (n3 = t3[e2]) != null ? n3 : 0;
}
var je = U(
  ([{ deviation: t3, fixedHeaderHeight: e2, headerHeight: n3, scrollTop: o3, viewportHeight: r3 }]) => {
    const s3 = $(), i3 = C(0), l2 = C(0), c4 = C(0), a2 = ct(
      x(
        rt(
          V(o3),
          V(r3),
          V(n3),
          V(s3, se),
          V(c4),
          V(i3),
          V(e2),
          V(t3),
          V(l2)
        ),
        E(
          ([
            m2,
            S3,
            g2,
            [I, w3],
            v2,
            h2,
            p2,
            u2,
            T
          ]) => {
            const b2 = m2 - u2, f2 = h2 + p2, d2 = Math.max(g2 - b2, 0);
            let y2 = hn;
            const B = In(T, xe), k2 = In(T, Te);
            return I -= u2, I += g2 + p2, w3 += g2 + p2, w3 -= u2, I > m2 + f2 - B && (y2 = le), w3 < m2 - d2 + S3 + k2 && (y2 = te), y2 !== hn ? [
              Math.max(b2 - g2 - gn(v2, xe, y2) - B, 0),
              b2 - d2 - p2 + S3 + gn(v2, Te, y2) + k2
            ] : null;
          }
        ),
        A((m2) => m2 != null),
        Z(se)
      ),
      [0, 0]
    );
    return {
      increaseViewportBy: l2,
      // input
      listBoundary: s3,
      overscan: c4,
      topListHeight: i3,
      // output
      visibleRange: a2
    };
  },
  X(at),
  { singleton: true }
);
function _o(t3, e2, n3) {
  if (Re(e2)) {
    const o3 = Gn(t3, e2);
    return [
      { index: wt(e2.groupOffsetTree, o3)[0], offset: 0, size: 0 },
      { data: n3 == null ? void 0 : n3[0], index: o3, offset: 0, size: 0 }
    ];
  }
  return [{ data: n3 == null ? void 0 : n3[0], index: t3, offset: 0, size: 0 }];
}
var Be = {
  bottom: 0,
  firstItemIndex: 0,
  items: [],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  topItems: [],
  topListHeight: 0,
  totalCount: 0
};
function Ie(t3, e2, n3, o3, r3, s3) {
  const { lastIndex: i3, lastOffset: l2, lastSize: c4 } = r3;
  let a2 = 0, m2 = 0;
  if (t3.length > 0) {
    a2 = t3[0].offset;
    const v2 = t3[t3.length - 1];
    m2 = v2.offset + v2.size;
  }
  const S3 = n3 - i3, g2 = l2 + S3 * c4 + (S3 - 1) * o3, I = a2, w3 = g2 - m2;
  return {
    bottom: m2,
    firstItemIndex: s3,
    items: Sn(t3, r3, s3),
    offsetBottom: w3,
    offsetTop: a2,
    top: I,
    topItems: Sn(e2, r3, s3),
    topListHeight: e2.reduce((v2, h2) => h2.size + v2, 0),
    totalCount: n3
  };
}
function Un(t3, e2, n3, o3, r3, s3) {
  let i3 = 0;
  if (n3.groupIndices.length > 0)
    for (const m2 of n3.groupIndices) {
      if (m2 - i3 >= t3)
        break;
      i3++;
    }
  const l2 = t3 + i3, c4 = Ke(e2, l2), a2 = Array.from({ length: l2 }).map((m2, S3) => ({
    data: s3[S3 + c4],
    index: S3 + c4,
    offset: 0,
    size: 0
  }));
  return Ie(a2, [], l2, r3, n3, o3);
}
function Sn(t3, e2, n3) {
  if (t3.length === 0)
    return [];
  if (!Re(e2))
    return t3.map((a2) => ({ ...a2, index: a2.index + n3, originalIndex: a2.index }));
  const o3 = t3[0].index, r3 = t3[t3.length - 1].index, s3 = [], i3 = ye(e2.groupOffsetTree, o3, r3);
  let l2, c4 = 0;
  for (const a2 of t3) {
    (!l2 || l2.end < a2.index) && (l2 = i3.shift(), c4 = e2.groupIndices.indexOf(l2.start));
    let m2;
    a2.index === l2.start ? m2 = {
      index: c4,
      type: "group"
    } : m2 = {
      groupIndex: c4,
      index: a2.index - (c4 + 1) + n3
    }, s3.push({
      ...m2,
      data: a2.data,
      offset: a2.offset,
      originalIndex: a2.index,
      size: a2.size
    });
  }
  return s3;
}
var $t = U(
  ([
    { data: t3, firstItemIndex: e2, gap: n3, sizes: o3, totalCount: r3 },
    s3,
    { listBoundary: i3, topListHeight: l2, visibleRange: c4 },
    { initialTopMostItemIndex: a2, scrolledToInitialItem: m2 },
    { topListHeight: S3 },
    g2,
    { didMount: I },
    { recalcInProgress: w3 }
  ]) => {
    const v2 = C([]), h2 = C(0), p2 = $();
    O(s3.topItemsIndexes, v2);
    const u2 = ct(
      x(
        rt(
          I,
          w3,
          V(c4, se),
          V(r3),
          V(o3),
          V(a2),
          m2,
          V(v2),
          V(e2),
          V(n3),
          t3
        ),
        A(([d2, y2, , B, , , , , , , k2]) => {
          const L = k2 && k2.length !== B;
          return d2 && !y2 && !L;
        }),
        E(
          ([
            ,
            ,
            [d2, y2],
            B,
            k2,
            L,
            z,
            _,
            J,
            nt2,
            F
          ]) => {
            const Y = k2, { offsetTree: it, sizeTree: dt2 } = Y, St = ot2(h2);
            if (B === 0)
              return { ...Be, totalCount: B };
            if (d2 === 0 && y2 === 0)
              return St === 0 ? { ...Be, totalCount: B } : Un(St, L, k2, J, nt2, F || []);
            if (j(dt2))
              return St > 0 ? null : Ie(
                _o(Ke(L, B), Y, F),
                [],
                B,
                nt2,
                Y,
                J
              );
            const ft2 = [];
            if (_.length > 0) {
              const Mt = _[0], yt = _[_.length - 1];
              let Bt = 0;
              for (const R of ye(dt2, Mt, yt)) {
                const D = R.value, Q = Math.max(R.start, Mt), lt2 = Math.min(R.end, yt);
                for (let tt = Q; tt <= lt2; tt++)
                  ft2.push({ data: F == null ? void 0 : F[tt], index: tt, offset: Bt, size: D }), Bt += D;
              }
            }
            if (!z)
              return Ie([], ft2, B, nt2, Y, J);
            const ut = _.length > 0 ? _[_.length - 1] + 1 : 0, At = Bo(it, d2, y2, ut);
            if (At.length === 0)
              return null;
            const xt = B - 1, Xt = ve([], (Mt) => {
              for (const yt of At) {
                const Bt = yt.value;
                let R = Bt.offset, D = yt.start;
                const Q = Bt.size;
                if (Bt.offset < d2) {
                  D += Math.floor((d2 - Bt.offset + nt2) / (Q + nt2));
                  const tt = D - yt.start;
                  R += tt * Q + tt * nt2;
                }
                D < ut && (R += (ut - D) * Q, D = ut);
                const lt2 = Math.min(yt.end, xt);
                for (let tt = D; tt <= lt2 && !(R >= y2); tt++)
                  Mt.push({ data: F == null ? void 0 : F[tt], index: tt, offset: R, size: Q }), R += Q + nt2;
              }
            });
            return Ie(Xt, ft2, B, nt2, Y, J);
          }
        ),
        //@ts-expect-error filter needs to be fixed
        A((d2) => d2 !== null),
        Z()
      ),
      Be
    );
    O(
      x(
        t3,
        A(We),
        E((d2) => d2 == null ? void 0 : d2.length)
      ),
      r3
    ), O(
      x(
        u2,
        E((d2) => d2.topListHeight)
      ),
      S3
    ), O(S3, l2), O(
      x(
        u2,
        E((d2) => [d2.top, d2.bottom])
      ),
      i3
    ), O(
      x(
        u2,
        E((d2) => d2.items)
      ),
      p2
    );
    const T = ht(
      x(
        u2,
        A(({ items: d2 }) => d2.length > 0),
        N(r3, t3),
        A(([{ items: d2 }, y2]) => d2[d2.length - 1].originalIndex === y2 - 1),
        E(([, d2, y2]) => [d2 - 1, y2]),
        Z(se),
        E(([d2]) => d2)
      )
    ), b2 = ht(
      x(
        u2,
        kt(200),
        A(({ items: d2, topItems: y2 }) => d2.length > 0 && d2[0].originalIndex === y2.length),
        E(({ items: d2 }) => d2[0].index),
        Z()
      )
    ), f2 = ht(
      x(
        u2,
        A(({ items: d2 }) => d2.length > 0),
        E(({ items: d2 }) => {
          let y2 = 0, B = d2.length - 1;
          for (; d2[y2].type === "group" && y2 < B; )
            y2++;
          for (; d2[B].type === "group" && B > y2; )
            B--;
          return {
            endIndex: d2[B].index,
            startIndex: d2[y2].index
          };
        }),
        Z(Mn)
      )
    );
    return { endReached: T, initialItemCount: h2, itemsRendered: p2, listState: u2, rangeChanged: f2, startReached: b2, topItemsIndexes: v2, ...g2 };
  },
  X(
    Et,
    Nn,
    je,
    ue,
    ce,
    ae,
    Pt,
    De
  ),
  { singleton: true }
);
var Kn = U(
  ([{ fixedFooterHeight: t3, fixedHeaderHeight: e2, footerHeight: n3, headerHeight: o3 }, { listState: r3 }]) => {
    const s3 = $(), i3 = ct(
      x(
        rt(n3, t3, o3, e2, r3),
        E(([l2, c4, a2, m2, S3]) => l2 + c4 + a2 + m2 + S3.offsetBottom + S3.bottom)
      ),
      0
    );
    return O(V(i3), s3), { totalListHeight: i3, totalListHeightChanged: s3 };
  },
  X(at, $t),
  { singleton: true }
);
var No = U(
  ([{ viewportHeight: t3 }, { totalListHeight: e2 }]) => {
    const n3 = C(false), o3 = ct(
      x(
        rt(n3, t3, e2),
        A(([r3]) => r3),
        E(([, r3, s3]) => Math.max(0, r3 - s3)),
        kt(0),
        Z()
      ),
      0
    );
    return { alignToBottom: n3, paddingTopAddition: o3 };
  },
  X(at, Kn),
  { singleton: true }
);
var jn = U(() => ({
  context: C(null)
}));
var Do = ({
  itemBottom: t3,
  itemTop: e2,
  locationParams: { align: n3, behavior: o3, ...r3 },
  viewportBottom: s3,
  viewportTop: i3
}) => e2 < i3 ? { ...r3, align: n3 != null ? n3 : "start", behavior: o3 } : t3 > s3 ? { ...r3, align: n3 != null ? n3 : "end", behavior: o3 } : null;
var qn = U(
  ([
    { gap: t3, sizes: e2, totalCount: n3 },
    { fixedFooterHeight: o3, fixedHeaderHeight: r3, headerHeight: s3, scrollingInProgress: i3, scrollTop: l2, viewportHeight: c4 },
    { scrollToIndex: a2 }
  ]) => {
    const m2 = $();
    return O(
      x(
        m2,
        N(e2, c4, n3, s3, r3, o3, l2),
        N(t3),
        E(([[S3, g2, I, w3, v2, h2, p2, u2], T]) => {
          const { align: b2, behavior: f2, calculateViewLocation: d2 = Do, done: y2, ...B } = S3, k2 = _n(S3, g2, w3 - 1), L = ie(k2, g2.offsetTree, T) + v2 + h2, z = L + wt(g2.sizeTree, k2)[1], _ = u2 + h2, J = u2 + I - p2, nt2 = d2({
            itemBottom: z,
            itemTop: L,
            locationParams: { align: b2, behavior: f2, ...B },
            viewportBottom: J,
            viewportTop: _
          });
          return nt2 ? y2 && Tt(
            x(
              i3,
              A((F) => !F),
              // skips the initial publish of false, and the cleanup call.
              // but if scrollingInProgress is true, we skip the initial publish.
              Dt(ot2(i3) ? 1 : 2)
            ),
            y2
          ) : y2 && y2(), nt2;
        }),
        A((S3) => S3 !== null)
      ),
      a2
    ), {
      scrollIntoView: m2
    };
  },
  X(Et, at, ce, $t, Vt),
  { singleton: true }
);
function xn(t3) {
  return t3 ? t3 === "smooth" ? "smooth" : "auto" : false;
}
var $o = (t3, e2) => typeof t3 == "function" ? xn(t3(e2)) : e2 && xn(t3);
var Uo = U(
  ([
    { listRefresh: t3, totalCount: e2, fixedItemSize: n3, data: o3 },
    { atBottomState: r3, isAtBottom: s3 },
    { scrollToIndex: i3 },
    { scrolledToInitialItem: l2 },
    { didMount: c4, propsReady: a2 },
    { log: m2 },
    { scrollingInProgress: S3 },
    { context: g2 },
    { scrollIntoView: I }
  ]) => {
    const w3 = C(false), v2 = $();
    let h2 = null;
    function p2(f2) {
      G(i3, {
        align: "end",
        behavior: f2,
        index: "LAST"
      });
    }
    K(
      x(
        rt(x(V(e2), Dt(1)), c4),
        N(V(w3), s3, l2, S3),
        E(([[f2, d2], y2, B, k2, L]) => {
          let z = d2 && k2, _ = "auto";
          return z && (_ = $o(y2, B || L), z = z && !!_), { followOutputBehavior: _, shouldFollow: z, totalCount: f2 };
        }),
        A(({ shouldFollow: f2 }) => f2)
      ),
      ({ followOutputBehavior: f2, totalCount: d2 }) => {
        h2 && (h2(), h2 = null), ot2(n3) ? requestAnimationFrame(() => {
          ot2(m2)("following output to ", { totalCount: d2 }, mt2.DEBUG), p2(f2);
        }) : h2 = Tt(t3, () => {
          ot2(m2)("following output to ", { totalCount: d2 }, mt2.DEBUG), p2(f2), h2 = null;
        });
      }
    );
    function u2(f2) {
      const d2 = Tt(r3, (y2) => {
        f2 && !y2.atBottom && y2.notAtBottomBecause === "SIZE_INCREASED" && !h2 && (ot2(m2)("scrolling to bottom due to increased size", {}, mt2.DEBUG), p2("auto"));
      });
      setTimeout(d2, 100);
    }
    K(
      x(
        rt(V(w3), e2, a2),
        A(([f2, , d2]) => f2 && d2),
        bt(
          ({ value: f2 }, [, d2]) => ({ refreshed: f2 === d2, value: d2 }),
          { refreshed: false, value: 0 }
        ),
        A(({ refreshed: f2 }) => f2),
        N(w3, e2)
      ),
      ([, f2]) => {
        ot2(l2) && u2(f2 !== false);
      }
    ), K(v2, () => {
      u2(ot2(w3) !== false);
    }), K(rt(V(w3), r3), ([f2, d2]) => {
      f2 && !d2.atBottom && d2.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && p2("auto");
    });
    const T = C(null), b2 = $();
    return O(
      Le(
        x(
          V(o3),
          E((f2) => {
            var d2;
            return (d2 = f2 == null ? void 0 : f2.length) != null ? d2 : 0;
          })
        ),
        x(V(e2))
      ),
      b2
    ), K(
      x(
        rt(x(b2, Dt(1)), c4),
        N(V(T), l2, S3, g2),
        E(([[f2, d2], y2, B, k2, L]) => d2 && B && (y2 == null ? void 0 : y2({ context: L, totalCount: f2, scrollingInProgress: k2 }))),
        A((f2) => !!f2),
        kt(0)
      ),
      (f2) => {
        h2 && (h2(), h2 = null), ot2(n3) ? requestAnimationFrame(() => {
          ot2(m2)("scrolling into view", {}), G(I, f2);
        }) : h2 = Tt(t3, () => {
          ot2(m2)("scrolling into view", {}), G(I, f2), h2 = null;
        });
      }
    ), { autoscrollToBottom: v2, followOutput: w3, scrollIntoViewOnChange: T };
  },
  X(
    Et,
    ae,
    ce,
    ue,
    Pt,
    Vt,
    at,
    jn,
    qn
  )
);
var Ko = U(
  ([{ data: t3, firstItemIndex: e2, gap: n3, sizes: o3 }, { initialTopMostItemIndex: r3 }, { initialItemCount: s3, listState: i3 }, { didMount: l2 }]) => (O(
    x(
      l2,
      N(s3),
      A(([, c4]) => c4 !== 0),
      N(r3, o3, e2, n3, t3),
      E(([[, c4], a2, m2, S3, g2, I = []]) => Un(c4, a2, m2, S3, g2, I))
    ),
    i3
  ), {}),
  X(Et, ue, $t, Pt),
  { singleton: true }
);
var jo = U(
  ([{ didMount: t3 }, { scrollTo: e2 }, { listState: n3 }]) => {
    const o3 = C(0);
    return K(
      x(
        t3,
        N(o3),
        A(([, r3]) => r3 !== 0),
        E(([, r3]) => ({ top: r3 }))
      ),
      (r3) => {
        Tt(
          x(
            n3,
            Dt(1),
            A((s3) => s3.items.length > 1)
          ),
          () => {
            requestAnimationFrame(() => {
              G(e2, r3);
            });
          }
        );
      }
    ), {
      initialScrollTop: o3
    };
  },
  X(Pt, at, $t),
  { singleton: true }
);
var Yn = U(
  ([{ scrollVelocity: t3 }]) => {
    const e2 = C(false), n3 = $(), o3 = C(false);
    return O(
      x(
        t3,
        N(o3, e2, n3),
        A(([r3, s3]) => !!s3),
        E(([r3, s3, i3, l2]) => {
          const { enter: c4, exit: a2 } = s3;
          if (i3) {
            if (a2(r3, l2))
              return false;
          } else if (c4(r3, l2))
            return true;
          return i3;
        }),
        Z()
      ),
      e2
    ), K(
      x(rt(e2, t3, n3), N(o3)),
      ([[r3, s3, i3], l2]) => {
        r3 && l2 && l2.change && l2.change(s3, i3);
      }
    ), { isSeeking: e2, scrollSeekConfiguration: o3, scrollSeekRangeChanged: n3, scrollVelocity: t3 };
  },
  X(ae),
  { singleton: true }
);
var qe = U(([{ scrollContainerState: t3, scrollTo: e2 }]) => {
  const n3 = $(), o3 = $(), r3 = $(), s3 = C(false), i3 = C(void 0);
  return O(
    x(
      rt(n3, o3),
      E(([{ scrollHeight: l2, scrollTop: c4, viewportHeight: a2 }, { offsetTop: m2 }]) => ({
        scrollHeight: l2,
        scrollTop: Math.max(0, c4 - m2),
        viewportHeight: a2
      }))
    ),
    t3
  ), O(
    x(
      e2,
      N(o3),
      E(([l2, { offsetTop: c4 }]) => ({
        ...l2,
        top: l2.top + c4
      }))
    ),
    r3
  ), {
    customScrollParent: i3,
    // config
    useWindowScroll: s3,
    // input
    windowScrollContainerState: n3,
    // signals
    windowScrollTo: r3,
    windowViewportRect: o3
  };
}, X(at));
var qo = U(
  ([
    { sizeRanges: t3, sizes: e2 },
    { headerHeight: n3, scrollTop: o3 },
    { initialTopMostItemIndex: r3 },
    { didMount: s3 },
    { useWindowScroll: i3, windowScrollContainerState: l2, windowViewportRect: c4 }
  ]) => {
    const a2 = $(), m2 = C(void 0), S3 = C(null), g2 = C(null);
    return O(l2, S3), O(c4, g2), K(
      x(
        a2,
        N(e2, o3, i3, S3, g2, n3)
      ),
      ([I, w3, v2, h2, p2, u2, T]) => {
        const b2 = Fo(w3.sizeTree);
        h2 && p2 !== null && u2 !== null && (v2 = p2.scrollTop - u2.offsetTop), v2 -= T, I({ ranges: b2, scrollTop: v2 });
      }
    ), O(x(m2, A(We), E(Yo)), r3), O(
      x(
        s3,
        N(m2),
        A(([, I]) => I !== void 0),
        Z(),
        E(([, I]) => I.ranges)
      ),
      t3
    ), {
      getState: a2,
      restoreStateFrom: m2
    };
  },
  X(Et, at, ue, Pt, qe)
);
function Yo(t3) {
  return { align: "start", index: 0, offset: t3.scrollTop };
}
var Zo = U(([{ topItemsIndexes: t3 }]) => {
  const e2 = C(0);
  return O(
    x(
      e2,
      A((n3) => n3 >= 0),
      E((n3) => Array.from({ length: n3 }).map((o3, r3) => r3))
    ),
    t3
  ), { topItemCount: e2 };
}, X($t));
function Zn(t3) {
  let e2 = false, n3;
  return () => (e2 || (e2 = true, n3 = t3()), n3);
}
var Xo = Zn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent));
var Jo = U(
  ([
    { deviation: t3, scrollBy: e2, scrollingInProgress: n3, scrollTop: o3 },
    { isAtBottom: r3, isScrolling: s3, lastJumpDueToItemResize: i3, scrollDirection: l2 },
    { listState: c4 },
    { beforeUnshiftWith: a2, gap: m2, shiftWithOffset: S3, sizes: g2 },
    { log: I },
    { recalcInProgress: w3 }
  ]) => {
    const v2 = ht(
      x(
        c4,
        N(i3),
        bt(
          ([, p2, u2, T], [{ bottom: b2, items: f2, offsetBottom: d2, totalCount: y2 }, B]) => {
            const k2 = b2 + d2;
            let L = 0;
            return u2 === y2 && p2.length > 0 && f2.length > 0 && (f2[0].originalIndex === 0 && p2[0].originalIndex === 0 || (L = k2 - T, L !== 0 && (L += B))), [L, f2, y2, k2];
          },
          [0, [], 0, 0]
        ),
        A(([p2]) => p2 !== 0),
        N(o3, l2, n3, r3, I, w3),
        A(([, p2, u2, T, , , b2]) => !b2 && !T && p2 !== 0 && u2 === le),
        E(([[p2], , , , , u2]) => (u2("Upward scrolling compensation", { amount: p2 }, mt2.DEBUG), p2))
      )
    );
    function h2(p2) {
      p2 > 0 ? (G(e2, { behavior: "auto", top: -p2 }), G(t3, 0)) : (G(t3, 0), G(e2, { behavior: "auto", top: -p2 }));
    }
    return K(x(v2, N(t3, s3)), ([p2, u2, T]) => {
      T && Xo() ? G(t3, u2 - p2) : h2(-p2);
    }), K(
      x(
        rt(ct(s3, false), t3, w3),
        A(([p2, u2, T]) => !p2 && !T && u2 !== 0),
        E(([p2, u2]) => u2),
        kt(1)
      ),
      h2
    ), O(
      x(
        S3,
        E((p2) => ({ top: -p2 }))
      ),
      e2
    ), K(
      x(
        a2,
        N(g2, m2),
        E(([p2, { groupIndices: u2, lastSize: T, sizeTree: b2 }, f2]) => {
          function d2(y2) {
            return y2 * (T + f2);
          }
          if (u2.length === 0)
            return d2(p2);
          {
            let y2 = 0;
            const B = re(b2, 0);
            let k2 = 0, L = 0;
            for (; k2 < p2; ) {
              k2++, y2 += B;
              let z = u2.length === L + 1 ? 1 / 0 : u2[L + 1] - u2[L] - 1;
              k2 + z > p2 && (y2 -= B, z = p2 - k2 + 1), k2 += z, y2 += d2(z), L++;
            }
            return y2;
          }
        })
      ),
      (p2) => {
        G(t3, p2), requestAnimationFrame(() => {
          G(e2, { top: p2 }), requestAnimationFrame(() => {
            G(t3, 0), G(w3, false);
          });
        });
      }
    ), { deviation: t3 };
  },
  X(at, ae, $t, Et, Vt, De)
);
var Qo = U(
  ([
    t3,
    e2,
    n3,
    o3,
    r3,
    s3,
    i3,
    l2,
    c4,
    a2,
    m2
  ]) => ({
    ...t3,
    ...e2,
    ...n3,
    ...o3,
    ...r3,
    ...s3,
    ...i3,
    ...l2,
    ...c4,
    ...a2,
    ...m2
  }),
  X(
    je,
    Ko,
    Pt,
    Yn,
    Kn,
    jo,
    No,
    qe,
    qn,
    Vt,
    jn
  )
);
var Xn = U(
  ([
    {
      data: t3,
      defaultItemSize: e2,
      firstItemIndex: n3,
      fixedItemSize: o3,
      gap: r3,
      groupIndices: s3,
      itemSize: i3,
      sizeRanges: l2,
      sizes: c4,
      statefulTotalCount: a2,
      totalCount: m2,
      trackItemSizes: S3
    },
    { initialItemFinalLocationReached: g2, initialTopMostItemIndex: I, scrolledToInitialItem: w3 },
    v2,
    h2,
    p2,
    { listState: u2, topItemsIndexes: T, ...b2 },
    { scrollToIndex: f2 },
    d2,
    { topItemCount: y2 },
    { groupCounts: B },
    k2
  ]) => (O(b2.rangeChanged, k2.scrollSeekRangeChanged), O(
    x(
      k2.windowViewportRect,
      E((L) => L.visibleHeight)
    ),
    v2.viewportHeight
  ), {
    data: t3,
    defaultItemHeight: e2,
    firstItemIndex: n3,
    fixedItemHeight: o3,
    gap: r3,
    groupCounts: B,
    initialItemFinalLocationReached: g2,
    initialTopMostItemIndex: I,
    scrolledToInitialItem: w3,
    sizeRanges: l2,
    topItemCount: y2,
    topItemsIndexes: T,
    // input
    totalCount: m2,
    ...p2,
    groupIndices: s3,
    itemSize: i3,
    listState: u2,
    scrollToIndex: f2,
    // output
    statefulTotalCount: a2,
    trackItemSizes: S3,
    // exported from stateFlagsSystem
    ...b2,
    // the bag of IO from featureGroup1System
    ...k2,
    ...v2,
    sizes: c4,
    ...h2
  }),
  X(
    Et,
    ue,
    at,
    qo,
    Uo,
    $t,
    ce,
    Jo,
    Zo,
    Nn,
    Qo
  )
);
function tr(t3, e2) {
  const n3 = {}, o3 = {};
  let r3 = 0;
  const s3 = t3.length;
  for (; r3 < s3; )
    o3[t3[r3]] = 1, r3 += 1;
  for (const i3 in e2)
    Object.hasOwn(o3, i3) || (n3[i3] = e2[i3]);
  return n3;
}
var pe = typeof document < "u" ? import_react12.default.useLayoutEffect : import_react12.default.useEffect;
function Ye(t3, e2, n3) {
  const o3 = Object.keys(e2.required || {}), r3 = Object.keys(e2.optional || {}), s3 = Object.keys(e2.methods || {}), i3 = Object.keys(e2.events || {}), l2 = import_react12.default.createContext({});
  function c4(p2, u2) {
    p2.propsReady && G(p2.propsReady, false);
    for (const T of o3) {
      const b2 = p2[e2.required[T]];
      G(b2, u2[T]);
    }
    for (const T of r3)
      if (T in u2) {
        const b2 = p2[e2.optional[T]];
        G(b2, u2[T]);
      }
    p2.propsReady && G(p2.propsReady, true);
  }
  function a2(p2) {
    return s3.reduce((u2, T) => (u2[T] = (b2) => {
      const f2 = p2[e2.methods[T]];
      G(f2, b2);
    }, u2), {});
  }
  function m2(p2) {
    return i3.reduce((u2, T) => (u2[T] = Io(p2[e2.events[T]]), u2), {});
  }
  const S3 = import_react12.default.forwardRef((p2, u2) => {
    const { children: T, ...b2 } = p2, [f2] = import_react12.default.useState(() => ve(xo(t3), (B) => {
      c4(B, b2);
    })), [d2] = import_react12.default.useState(an(m2, f2));
    pe(() => {
      for (const B of i3)
        B in b2 && K(d2[B], b2[B]);
      return () => {
        Object.values(d2).map(Ge);
      };
    }, [b2, d2, f2]), pe(() => {
      c4(f2, b2);
    }), import_react12.default.useImperativeHandle(u2, un(a2(f2)));
    const y2 = n3;
    return (0, import_jsx_runtime3.jsx)(l2.Provider, { value: f2, children: n3 ? (0, import_jsx_runtime3.jsx)(y2, { ...tr([...o3, ...r3, ...i3], b2), children: T }) : T });
  }), g2 = (p2) => {
    const u2 = import_react12.default.useContext(l2);
    return import_react12.default.useCallback(
      (T) => {
        G(u2[p2], T);
      },
      [u2, p2]
    );
  }, I = (p2) => {
    const T = import_react12.default.useContext(l2)[p2], b2 = import_react12.default.useCallback(
      (f2) => K(T, f2),
      [T]
    );
    return import_react12.default.useSyncExternalStore(
      b2,
      () => ot2(T),
      () => ot2(T)
    );
  }, w3 = (p2) => {
    const T = import_react12.default.useContext(l2)[p2], [b2, f2] = import_react12.default.useState(an(ot2, T));
    return pe(
      () => K(T, (d2) => {
        d2 !== b2 && f2(un(d2));
      }),
      [T, b2]
    ), b2;
  }, v2 = import_react12.default.version.startsWith("18") ? I : w3;
  return {
    Component: S3,
    useEmitter: (p2, u2) => {
      const b2 = import_react12.default.useContext(l2)[p2];
      pe(() => K(b2, u2), [u2, b2]);
    },
    useEmitterValue: v2,
    usePublisher: g2
  };
}
var be = import_react12.default.createContext(void 0);
var Jn = import_react12.default.createContext(void 0);
var Qn = typeof document < "u" ? import_react12.default.useLayoutEffect : import_react12.default.useEffect;
function ke(t3) {
  return "self" in t3;
}
function er(t3) {
  return "body" in t3;
}
function to(t3, e2, n3, o3 = Yt, r3, s3) {
  const i3 = import_react12.default.useRef(null), l2 = import_react12.default.useRef(null), c4 = import_react12.default.useRef(null), a2 = import_react12.default.useCallback(
    (g2) => {
      let I, w3, v2;
      const h2 = g2.target;
      if (er(h2) || ke(h2)) {
        const u2 = ke(h2) ? h2 : h2.defaultView;
        v2 = s3 ? u2.scrollX : u2.scrollY, I = s3 ? u2.document.documentElement.scrollWidth : u2.document.documentElement.scrollHeight, w3 = s3 ? u2.innerWidth : u2.innerHeight;
      } else
        v2 = s3 ? h2.scrollLeft : h2.scrollTop, I = s3 ? h2.scrollWidth : h2.scrollHeight, w3 = s3 ? h2.offsetWidth : h2.offsetHeight;
      const p2 = () => {
        t3({
          scrollHeight: I,
          scrollTop: Math.max(v2, 0),
          viewportHeight: w3
        });
      };
      g2.suppressFlushSync ? p2() : import_react_dom5.default.flushSync(p2), l2.current !== null && (v2 === l2.current || v2 <= 0 || v2 === I - w3) && (l2.current = null, e2(true), c4.current && (clearTimeout(c4.current), c4.current = null));
    },
    [t3, e2, s3]
  );
  import_react12.default.useEffect(() => {
    const g2 = r3 || i3.current;
    return o3(r3 || i3.current), a2({ suppressFlushSync: true, target: g2 }), g2.addEventListener("scroll", a2, { passive: true }), () => {
      o3(null), g2.removeEventListener("scroll", a2);
    };
  }, [i3, a2, n3, o3, r3]);
  function m2(g2) {
    const I = i3.current;
    if (!I || (s3 ? "offsetWidth" in I && I.offsetWidth === 0 : "offsetHeight" in I && I.offsetHeight === 0))
      return;
    const w3 = g2.behavior === "smooth";
    let v2, h2, p2;
    ke(I) ? (h2 = Math.max(
      vt(I.document.documentElement, s3 ? "width" : "height"),
      s3 ? I.document.documentElement.scrollWidth : I.document.documentElement.scrollHeight
    ), v2 = s3 ? I.innerWidth : I.innerHeight, p2 = s3 ? window.scrollX : window.scrollY) : (h2 = I[s3 ? "scrollWidth" : "scrollHeight"], v2 = vt(I, s3 ? "width" : "height"), p2 = I[s3 ? "scrollLeft" : "scrollTop"]);
    const u2 = h2 - v2;
    if (g2.top = Math.ceil(Math.max(Math.min(u2, g2.top), 0)), $n(v2, h2) || g2.top === p2) {
      t3({ scrollHeight: h2, scrollTop: p2, viewportHeight: v2 }), w3 && e2(true);
      return;
    }
    w3 ? (l2.current = g2.top, c4.current && clearTimeout(c4.current), c4.current = setTimeout(() => {
      c4.current = null, l2.current = null, e2(true);
    }, 1e3)) : l2.current = null, s3 && (g2 = { behavior: g2.behavior, left: g2.top }), I.scrollTo(g2);
  }
  function S3(g2) {
    s3 && (g2 = { behavior: g2.behavior, left: g2.top }), i3.current.scrollBy(g2);
  }
  return { scrollByCallback: S3, scrollerRef: i3, scrollToCallback: m2 };
}
var Fe = "-webkit-sticky";
var Tn = "sticky";
var Ze = Zn(() => {
  if (typeof document > "u")
    return Tn;
  const t3 = document.createElement("div");
  return t3.style.position = Fe, t3.style.position === Fe ? Fe : Tn;
});
function Xe(t3) {
  return t3;
}
var nr = U(() => {
  const t3 = C((l2) => `Item ${l2}`), e2 = C((l2) => `Group ${l2}`), n3 = C({}), o3 = C(Xe), r3 = C("div"), s3 = C(Yt), i3 = (l2, c4 = null) => ct(
    x(
      n3,
      E((a2) => a2[l2]),
      Z()
    ),
    c4
  );
  return {
    components: n3,
    computeItemKey: o3,
    EmptyPlaceholder: i3("EmptyPlaceholder"),
    FooterComponent: i3("Footer"),
    GroupComponent: i3("Group", "div"),
    groupContent: e2,
    HeaderComponent: i3("Header"),
    HeaderFooterTag: r3,
    ItemComponent: i3("Item", "div"),
    itemContent: t3,
    ListComponent: i3("List", "div"),
    ScrollerComponent: i3("Scroller", "div"),
    scrollerRef: s3,
    ScrollSeekPlaceholder: i3("ScrollSeekPlaceholder"),
    TopItemListComponent: i3("TopItemList")
  };
});
var or = U(
  ([t3, e2]) => ({ ...t3, ...e2 }),
  X(Xn, nr)
);
var rr = ({ height: t3 }) => (0, import_jsx_runtime3.jsx)("div", { style: { height: t3 } });
var sr = { overflowAnchor: "none", position: Ze(), zIndex: 1 };
var eo = { overflowAnchor: "none" };
var ir = { ...eo, display: "inline-block", height: "100%" };
var Cn = import_react12.default.memo(function({ showTopList: e2 = false }) {
  const n3 = M("listState"), o3 = gt("sizeRanges"), r3 = M("useWindowScroll"), s3 = M("customScrollParent"), i3 = gt("windowScrollContainerState"), l2 = gt("scrollContainerState"), c4 = s3 || r3 ? i3 : l2, a2 = M("itemContent"), m2 = M("context"), S3 = M("groupContent"), g2 = M("trackItemSizes"), I = M("itemSize"), w3 = M("log"), v2 = gt("gap"), h2 = M("horizontalDirection"), { callbackRef: p2 } = On(
    o3,
    I,
    g2,
    e2 ? Yt : c4,
    w3,
    v2,
    s3,
    h2,
    M("skipAnimationFrameInResizeObserver")
  ), [u2, T] = import_react12.default.useState(0);
  tn("deviation", (F) => {
    u2 !== F && T(F);
  });
  const b2 = M("EmptyPlaceholder"), f2 = M("ScrollSeekPlaceholder") || rr, d2 = M("ListComponent"), y2 = M("ItemComponent"), B = M("GroupComponent"), k2 = M("computeItemKey"), L = M("isSeeking"), z = M("groupIndices").length > 0, _ = M("alignToBottom"), J = M("initialItemFinalLocationReached"), nt2 = e2 ? {} : {
    boxSizing: "border-box",
    ...h2 ? {
      display: "inline-block",
      height: "100%",
      marginLeft: u2 !== 0 ? u2 : _ ? "auto" : 0,
      paddingLeft: n3.offsetTop,
      paddingRight: n3.offsetBottom,
      whiteSpace: "nowrap"
    } : {
      marginTop: u2 !== 0 ? u2 : _ ? "auto" : 0,
      paddingBottom: n3.offsetBottom,
      paddingTop: n3.offsetTop
    },
    ...J ? {} : { visibility: "hidden" }
  };
  return !e2 && n3.totalCount === 0 && b2 ? (0, import_jsx_runtime3.jsx)(b2, { ...q(b2, m2) }) : (0, import_jsx_runtime3.jsx)(
    d2,
    {
      ...q(d2, m2),
      "data-testid": e2 ? "virtuoso-top-item-list" : "virtuoso-item-list",
      ref: p2,
      style: nt2,
      children: (e2 ? n3.topItems : n3.items).map((F) => {
        const Y = F.originalIndex, it = k2(Y + n3.firstItemIndex, F.data, m2);
        return L ? (0, import_react12.createElement)(
          f2,
          {
            ...q(f2, m2),
            height: F.size,
            index: F.index,
            key: it,
            type: F.type || "item",
            ...F.type === "group" ? {} : { groupIndex: F.groupIndex }
          }
        ) : F.type === "group" ? (0, import_react12.createElement)(
          B,
          {
            ...q(B, m2),
            "data-index": Y,
            "data-item-index": F.index,
            "data-known-size": F.size,
            key: it,
            style: sr
          },
          S3(F.index, m2)
        ) : (0, import_react12.createElement)(
          y2,
          {
            ...q(y2, m2),
            ...no(y2, F.data),
            "data-index": Y,
            "data-item-group-index": F.groupIndex,
            "data-item-index": F.index,
            "data-known-size": F.size,
            key: it,
            style: h2 ? ir : eo
          },
          z ? a2(F.index, F.groupIndex, F.data, m2) : a2(F.index, F.data, m2)
        );
      })
    }
  );
});
var lr = {
  height: "100%",
  outline: "none",
  overflowY: "auto",
  position: "relative",
  WebkitOverflowScrolling: "touch"
};
var cr = {
  outline: "none",
  overflowX: "auto",
  position: "relative"
};
var Zt = (t3) => ({
  height: "100%",
  position: "absolute",
  top: 0,
  width: "100%",
  ...t3 ? { display: "flex", flexDirection: "column" } : {}
});
var ur = {
  position: Ze(),
  top: 0,
  width: "100%",
  zIndex: 1
};
function q(t3, e2) {
  if (typeof t3 != "string")
    return { context: e2 };
}
function no(t3, e2) {
  return { item: typeof t3 == "string" ? void 0 : e2 };
}
var ar = import_react12.default.memo(function() {
  const e2 = M("HeaderComponent"), n3 = gt("headerHeight"), o3 = M("HeaderFooterTag"), r3 = Ht(
    import_react12.default.useMemo(
      () => (i3) => {
        n3(vt(i3, "height"));
      },
      [n3]
    ),
    true,
    M("skipAnimationFrameInResizeObserver")
  ), s3 = M("context");
  return e2 ? (0, import_jsx_runtime3.jsx)(o3, { ref: r3, children: (0, import_jsx_runtime3.jsx)(e2, { ...q(e2, s3) }) }) : null;
});
var dr = import_react12.default.memo(function() {
  const e2 = M("FooterComponent"), n3 = gt("footerHeight"), o3 = M("HeaderFooterTag"), r3 = Ht(
    import_react12.default.useMemo(
      () => (i3) => {
        n3(vt(i3, "height"));
      },
      [n3]
    ),
    true,
    M("skipAnimationFrameInResizeObserver")
  ), s3 = M("context");
  return e2 ? (0, import_jsx_runtime3.jsx)(o3, { ref: r3, children: (0, import_jsx_runtime3.jsx)(e2, { ...q(e2, s3) }) }) : null;
});
function Je({ useEmitter: t3, useEmitterValue: e2, usePublisher: n3 }) {
  return import_react12.default.memo(function({ children: s3, style: i3, ...l2 }) {
    const c4 = n3("scrollContainerState"), a2 = e2("ScrollerComponent"), m2 = n3("smoothScrollTargetReached"), S3 = e2("scrollerRef"), g2 = e2("context"), I = e2("horizontalDirection") || false, { scrollByCallback: w3, scrollerRef: v2, scrollToCallback: h2 } = to(
      c4,
      m2,
      a2,
      S3,
      void 0,
      I
    );
    return t3("scrollTo", h2), t3("scrollBy", w3), (0, import_jsx_runtime3.jsx)(
      a2,
      {
        "data-testid": "virtuoso-scroller",
        "data-virtuoso-scroller": true,
        ref: v2,
        style: { ...I ? cr : lr, ...i3 },
        tabIndex: 0,
        ...l2,
        ...q(a2, g2),
        children: s3
      }
    );
  });
}
function Qe({ useEmitter: t3, useEmitterValue: e2, usePublisher: n3 }) {
  return import_react12.default.memo(function({ children: s3, style: i3, ...l2 }) {
    const c4 = n3("windowScrollContainerState"), a2 = e2("ScrollerComponent"), m2 = n3("smoothScrollTargetReached"), S3 = e2("totalListHeight"), g2 = e2("deviation"), I = e2("customScrollParent"), w3 = e2("context"), v2 = import_react12.default.useRef(null), h2 = e2("scrollerRef"), { scrollByCallback: p2, scrollerRef: u2, scrollToCallback: T } = to(
      c4,
      m2,
      a2,
      h2,
      I
    );
    return Qn(() => {
      var b2;
      return u2.current = I || ((b2 = v2.current) == null ? void 0 : b2.ownerDocument.defaultView), () => {
        u2.current = null;
      };
    }, [u2, I]), t3("windowScrollTo", T), t3("scrollBy", p2), (0, import_jsx_runtime3.jsx)(
      a2,
      {
        ref: v2,
        "data-virtuoso-scroller": true,
        style: { position: "relative", ...i3, ...S3 !== 0 ? { height: S3 + g2 } : {} },
        ...l2,
        ...q(a2, w3),
        children: s3
      }
    );
  });
}
var fr = ({ children: t3 }) => {
  const e2 = import_react12.default.useContext(be), n3 = gt("viewportHeight"), o3 = gt("fixedItemHeight"), r3 = M("alignToBottom"), s3 = M("horizontalDirection"), i3 = import_react12.default.useMemo(
    () => ne(n3, (c4) => vt(c4, s3 ? "width" : "height")),
    [n3, s3]
  ), l2 = Ht(i3, true, M("skipAnimationFrameInResizeObserver"));
  return import_react12.default.useEffect(() => {
    e2 && (n3(e2.viewportHeight), o3(e2.itemHeight));
  }, [e2, n3, o3]), (0, import_jsx_runtime3.jsx)("div", { "data-viewport-type": "element", ref: l2, style: Zt(r3), children: t3 });
};
var mr = ({ children: t3 }) => {
  const e2 = import_react12.default.useContext(be), n3 = gt("windowViewportRect"), o3 = gt("fixedItemHeight"), r3 = M("customScrollParent"), s3 = Ne(
    n3,
    r3,
    M("skipAnimationFrameInResizeObserver")
  ), i3 = M("alignToBottom");
  return import_react12.default.useEffect(() => {
    e2 && (o3(e2.itemHeight), n3({ offsetTop: 0, visibleHeight: e2.viewportHeight, visibleWidth: 100 }));
  }, [e2, n3, o3]), (0, import_jsx_runtime3.jsx)("div", { "data-viewport-type": "window", ref: s3, style: Zt(i3), children: t3 });
};
var pr = ({ children: t3 }) => {
  const e2 = M("TopItemListComponent") || "div", n3 = M("headerHeight"), o3 = { ...ur, marginTop: `${n3}px` }, r3 = M("context");
  return (0, import_jsx_runtime3.jsx)(e2, { style: o3, ...q(e2, r3), children: t3 });
};
var hr = import_react12.default.memo(function(e2) {
  const n3 = M("useWindowScroll"), o3 = M("topItemsIndexes").length > 0, r3 = M("customScrollParent"), s3 = M("context"), i3 = r3 || n3 ? Ir : gr, l2 = r3 || n3 ? mr : fr;
  return (0, import_jsx_runtime3.jsxs)(i3, { ...e2, ...q(i3, s3), children: [
    o3 && (0, import_jsx_runtime3.jsx)(pr, { children: (0, import_jsx_runtime3.jsx)(Cn, { showTopList: true }) }),
    (0, import_jsx_runtime3.jsxs)(l2, { children: [
      (0, import_jsx_runtime3.jsx)(ar, {}),
      (0, import_jsx_runtime3.jsx)(Cn, {}),
      (0, import_jsx_runtime3.jsx)(dr, {})
    ] })
  ] });
});
var {
  Component: oo,
  useEmitter: tn,
  useEmitterValue: M,
  usePublisher: gt
} = Ye(
  or,
  {
    required: {},
    optional: {
      restoreStateFrom: "restoreStateFrom",
      context: "context",
      followOutput: "followOutput",
      scrollIntoViewOnChange: "scrollIntoViewOnChange",
      itemContent: "itemContent",
      groupContent: "groupContent",
      overscan: "overscan",
      increaseViewportBy: "increaseViewportBy",
      totalCount: "totalCount",
      groupCounts: "groupCounts",
      topItemCount: "topItemCount",
      firstItemIndex: "firstItemIndex",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      components: "components",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      computeItemKey: "computeItemKey",
      defaultItemHeight: "defaultItemHeight",
      fixedItemHeight: "fixedItemHeight",
      itemSize: "itemSize",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "HeaderFooterTag",
      data: "data",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      alignToBottom: "alignToBottom",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      horizontalDirection: "horizontalDirection",
      skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver"
    },
    methods: {
      scrollToIndex: "scrollToIndex",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      autoscrollToBottom: "autoscrollToBottom",
      getState: "getState"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      totalListHeightChanged: "totalListHeightChanged",
      itemsRendered: "itemsRendered",
      groupIndices: "groupIndices"
    }
  },
  hr
);
var gr = Je({ useEmitter: tn, useEmitterValue: M, usePublisher: gt });
var Ir = Qe({ useEmitter: tn, useEmitterValue: M, usePublisher: gt });
var qr = oo;
var Yr = oo;
var Sr = U(() => {
  const t3 = C((a2) => (0, import_jsx_runtime3.jsxs)("td", { children: [
    "Item $",
    a2
  ] })), e2 = C(null), n3 = C((a2) => (0, import_jsx_runtime3.jsxs)("td", { colSpan: 1e3, children: [
    "Group ",
    a2
  ] })), o3 = C(null), r3 = C(null), s3 = C({}), i3 = C(Xe), l2 = C(Yt), c4 = (a2, m2 = null) => ct(
    x(
      s3,
      E((S3) => S3[a2]),
      Z()
    ),
    m2
  );
  return {
    components: s3,
    computeItemKey: i3,
    context: e2,
    EmptyPlaceholder: c4("EmptyPlaceholder"),
    FillerRow: c4("FillerRow"),
    fixedFooterContent: r3,
    fixedHeaderContent: o3,
    itemContent: t3,
    groupContent: n3,
    ScrollerComponent: c4("Scroller", "div"),
    scrollerRef: l2,
    ScrollSeekPlaceholder: c4("ScrollSeekPlaceholder"),
    TableBodyComponent: c4("TableBody", "tbody"),
    TableComponent: c4("Table", "table"),
    TableFooterComponent: c4("TableFoot", "tfoot"),
    TableHeadComponent: c4("TableHead", "thead"),
    TableRowComponent: c4("TableRow", "tr"),
    GroupComponent: c4("Group", "tr")
  };
});
var xr = U(
  ([t3, e2]) => ({ ...t3, ...e2 }),
  X(Xn, Sr)
);
var Tr = ({ height: t3 }) => (0, import_jsx_runtime3.jsx)("tr", { children: (0, import_jsx_runtime3.jsx)("td", { style: { height: t3 } }) });
var Cr = ({ height: t3 }) => (0, import_jsx_runtime3.jsx)("tr", { children: (0, import_jsx_runtime3.jsx)("td", { style: { border: 0, height: t3, padding: 0 } }) });
var wr = { overflowAnchor: "none" };
var wn = { position: Ze(), zIndex: 2, overflowAnchor: "none" };
var vn = import_react12.default.memo(function({ showTopList: e2 = false }) {
  const n3 = W("listState"), o3 = W("computeItemKey"), r3 = W("firstItemIndex"), s3 = W("context"), i3 = W("isSeeking"), l2 = W("fixedHeaderHeight"), c4 = W("groupIndices").length > 0, a2 = W("itemContent"), m2 = W("groupContent"), S3 = W("ScrollSeekPlaceholder") || Tr, g2 = W("GroupComponent"), I = W("TableRowComponent"), w3 = (e2 ? n3.topItems : []).reduce((h2, p2, u2) => (u2 === 0 ? h2.push(p2.size) : h2.push(h2[u2 - 1] + p2.size), h2), []), v2 = (e2 ? n3.topItems : n3.items).map((h2) => {
    const p2 = h2.originalIndex, u2 = o3(p2 + r3, h2.data, s3), T = e2 ? p2 === 0 ? 0 : w3[p2 - 1] : 0;
    return i3 ? (0, import_react12.createElement)(
      S3,
      {
        ...q(S3, s3),
        height: h2.size,
        index: h2.index,
        key: u2,
        type: h2.type || "item"
      }
    ) : h2.type === "group" ? (0, import_react12.createElement)(
      g2,
      {
        ...q(g2, s3),
        "data-index": p2,
        "data-item-index": h2.index,
        "data-known-size": h2.size,
        key: u2,
        style: {
          ...wn,
          top: l2
        }
      },
      m2(h2.index, s3)
    ) : (0, import_react12.createElement)(
      I,
      {
        ...q(I, s3),
        ...no(I, h2.data),
        "data-index": p2,
        "data-item-index": h2.index,
        "data-known-size": h2.size,
        "data-item-group-index": h2.groupIndex,
        key: u2,
        style: e2 ? { ...wn, top: l2 + T } : wr
      },
      c4 ? a2(h2.index, h2.groupIndex, h2.data, s3) : a2(h2.index, h2.data, s3)
    );
  });
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: v2 });
});
var vr = import_react12.default.memo(function() {
  const e2 = W("listState"), n3 = W("topItemsIndexes").length > 0, o3 = Ct("sizeRanges"), r3 = W("useWindowScroll"), s3 = W("customScrollParent"), i3 = Ct("windowScrollContainerState"), l2 = Ct("scrollContainerState"), c4 = s3 || r3 ? i3 : l2, a2 = W("trackItemSizes"), m2 = W("itemSize"), S3 = W("log"), { callbackRef: g2, ref: I } = On(
    o3,
    m2,
    a2,
    c4,
    S3,
    void 0,
    s3,
    false,
    W("skipAnimationFrameInResizeObserver")
  ), [w3, v2] = import_react12.default.useState(0);
  en("deviation", (z) => {
    w3 !== z && (I.current.style.marginTop = `${z}px`, v2(z));
  });
  const h2 = W("EmptyPlaceholder"), p2 = W("FillerRow") || Cr, u2 = W("TableBodyComponent"), T = W("paddingTopAddition"), b2 = W("statefulTotalCount"), f2 = W("context");
  if (b2 === 0 && h2)
    return (0, import_jsx_runtime3.jsx)(h2, { ...q(h2, f2) });
  const d2 = (n3 ? e2.topItems : []).reduce((z, _) => z + _.size, 0), y2 = e2.offsetTop + T + w3 - d2, B = e2.offsetBottom, k2 = y2 > 0 ? (0, import_jsx_runtime3.jsx)(p2, { context: f2, height: y2 }, "padding-top") : null, L = B > 0 ? (0, import_jsx_runtime3.jsx)(p2, { context: f2, height: B }, "padding-bottom") : null;
  return (0, import_jsx_runtime3.jsxs)(u2, { "data-testid": "virtuoso-item-list", ref: g2, ...q(u2, f2), children: [
    k2,
    n3 && (0, import_jsx_runtime3.jsx)(vn, { showTopList: true }),
    (0, import_jsx_runtime3.jsx)(vn, {}),
    L
  ] });
});
var yr = ({ children: t3 }) => {
  const e2 = import_react12.default.useContext(be), n3 = Ct("viewportHeight"), o3 = Ct("fixedItemHeight"), r3 = Ht(
    import_react12.default.useMemo(() => ne(n3, (s3) => vt(s3, "height")), [n3]),
    true,
    W("skipAnimationFrameInResizeObserver")
  );
  return import_react12.default.useEffect(() => {
    e2 && (n3(e2.viewportHeight), o3(e2.itemHeight));
  }, [e2, n3, o3]), (0, import_jsx_runtime3.jsx)("div", { "data-viewport-type": "element", ref: r3, style: Zt(false), children: t3 });
};
var Rr = ({ children: t3 }) => {
  const e2 = import_react12.default.useContext(be), n3 = Ct("windowViewportRect"), o3 = Ct("fixedItemHeight"), r3 = W("customScrollParent"), s3 = Ne(
    n3,
    r3,
    W("skipAnimationFrameInResizeObserver")
  );
  return import_react12.default.useEffect(() => {
    e2 && (o3(e2.itemHeight), n3({ offsetTop: 0, visibleHeight: e2.viewportHeight, visibleWidth: 100 }));
  }, [e2, n3, o3]), (0, import_jsx_runtime3.jsx)("div", { "data-viewport-type": "window", ref: s3, style: Zt(false), children: t3 });
};
var br = import_react12.default.memo(function(e2) {
  const n3 = W("useWindowScroll"), o3 = W("customScrollParent"), r3 = Ct("fixedHeaderHeight"), s3 = Ct("fixedFooterHeight"), i3 = W("fixedHeaderContent"), l2 = W("fixedFooterContent"), c4 = W("context"), a2 = Ht(
    import_react12.default.useMemo(() => ne(r3, (u2) => vt(u2, "height")), [r3]),
    true,
    W("skipAnimationFrameInResizeObserver")
  ), m2 = Ht(
    import_react12.default.useMemo(() => ne(s3, (u2) => vt(u2, "height")), [s3]),
    true,
    W("skipAnimationFrameInResizeObserver")
  ), S3 = o3 || n3 ? Er : Hr, g2 = o3 || n3 ? Rr : yr, I = W("TableComponent"), w3 = W("TableHeadComponent"), v2 = W("TableFooterComponent"), h2 = i3 ? (0, import_jsx_runtime3.jsx)(
    w3,
    {
      ref: a2,
      style: { position: "sticky", top: 0, zIndex: 2 },
      ...q(w3, c4),
      children: i3()
    },
    "TableHead"
  ) : null, p2 = l2 ? (0, import_jsx_runtime3.jsx)(
    v2,
    {
      ref: m2,
      style: { bottom: 0, position: "sticky", zIndex: 1 },
      ...q(v2, c4),
      children: l2()
    },
    "TableFoot"
  ) : null;
  return (0, import_jsx_runtime3.jsx)(S3, { ...e2, ...q(S3, c4), children: (0, import_jsx_runtime3.jsx)(g2, { children: (0, import_jsx_runtime3.jsxs)(I, { style: { borderSpacing: 0, overflowAnchor: "none" }, ...q(I, c4), children: [
    h2,
    (0, import_jsx_runtime3.jsx)(vr, {}, "TableBody"),
    p2
  ] }) }) });
});
var {
  Component: ro,
  useEmitter: en,
  useEmitterValue: W,
  usePublisher: Ct
} = Ye(
  xr,
  {
    required: {},
    optional: {
      restoreStateFrom: "restoreStateFrom",
      context: "context",
      followOutput: "followOutput",
      firstItemIndex: "firstItemIndex",
      itemContent: "itemContent",
      groupContent: "groupContent",
      fixedHeaderContent: "fixedHeaderContent",
      fixedFooterContent: "fixedFooterContent",
      overscan: "overscan",
      increaseViewportBy: "increaseViewportBy",
      totalCount: "totalCount",
      topItemCount: "topItemCount",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      components: "components",
      groupCounts: "groupCounts",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      computeItemKey: "computeItemKey",
      defaultItemHeight: "defaultItemHeight",
      fixedItemHeight: "fixedItemHeight",
      itemSize: "itemSize",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      data: "data",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      alignToBottom: "alignToBottom",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel"
    },
    methods: {
      scrollToIndex: "scrollToIndex",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      getState: "getState"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      totalListHeightChanged: "totalListHeightChanged",
      itemsRendered: "itemsRendered",
      groupIndices: "groupIndices"
    }
  },
  br
);
var Hr = Je({ useEmitter: en, useEmitterValue: W, usePublisher: Ct });
var Er = Qe({ useEmitter: en, useEmitterValue: W, usePublisher: Ct });
var yn = {
  bottom: 0,
  itemHeight: 0,
  items: [],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
};
var Br = {
  bottom: 0,
  itemHeight: 0,
  items: [{ index: 0 }],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
};
var { ceil: Rn, floor: Ce, max: ee, min: Oe, round: bn } = Math;
function Hn(t3, e2, n3) {
  return Array.from({ length: e2 - t3 + 1 }).map((o3, r3) => ({ data: n3 === null ? null : n3[r3 + t3], index: r3 + t3 }));
}
function kr(t3) {
  return {
    ...Br,
    items: t3
  };
}
function he(t3, e2) {
  return t3 && t3.width === e2.width && t3.height === e2.height;
}
function Fr(t3, e2) {
  return t3 && t3.column === e2.column && t3.row === e2.row;
}
var Or = U(
  ([
    { increaseViewportBy: t3, listBoundary: e2, overscan: n3, visibleRange: o3 },
    { footerHeight: r3, headerHeight: s3, scrollBy: i3, scrollContainerState: l2, scrollTo: c4, scrollTop: a2, smoothScrollTargetReached: m2, viewportHeight: S3 },
    g2,
    I,
    { didMount: w3, propsReady: v2 },
    { customScrollParent: h2, useWindowScroll: p2, windowScrollContainerState: u2, windowScrollTo: T, windowViewportRect: b2 },
    f2
  ]) => {
    const d2 = C(0), y2 = C(0), B = C(yn), k2 = C({ height: 0, width: 0 }), L = C({ height: 0, width: 0 }), z = $(), _ = $(), J = C(0), nt2 = C(null), F = C({ column: 0, row: 0 }), Y = $(), it = $(), dt2 = C(false), St = C(0), ft2 = C(true), ut = C(false), At = C(false);
    K(
      x(
        w3,
        N(St),
        A(([R, D]) => !!D)
      ),
      () => {
        G(ft2, false);
      }
    ), K(
      x(
        rt(w3, ft2, L, k2, St, ut),
        A(([R, D, Q, lt2, , tt]) => R && !D && Q.height !== 0 && lt2.height !== 0 && !tt)
      ),
      ([, , , , R]) => {
        G(ut, true), Ue(1, () => {
          G(z, R);
        }), Tt(x(a2), () => {
          G(e2, [0, 0]), G(ft2, true);
        });
      }
    ), O(
      x(
        it,
        A((R) => R != null && R.scrollTop > 0),
        Rt(0)
      ),
      y2
    ), K(
      x(
        w3,
        N(it),
        A(([, R]) => R != null)
      ),
      ([, R]) => {
        R && (G(k2, R.viewport), G(L, R.item), G(F, R.gap), R.scrollTop > 0 && (G(dt2, true), Tt(x(a2, Dt(1)), (D) => {
          G(dt2, false);
        }), G(c4, { top: R.scrollTop })));
      }
    ), O(
      x(
        k2,
        E(({ height: R }) => R)
      ),
      S3
    ), O(
      x(
        rt(
          V(k2, he),
          V(L, he),
          V(F, (R, D) => R && R.column === D.column && R.row === D.row),
          V(a2)
        ),
        E(([R, D, Q, lt2]) => ({
          gap: Q,
          item: D,
          scrollTop: lt2,
          viewport: R
        }))
      ),
      Y
    ), O(
      x(
        rt(
          V(d2),
          o3,
          V(F, Fr),
          V(L, he),
          V(k2, he),
          V(nt2),
          V(y2),
          V(dt2),
          V(ft2),
          V(St)
        ),
        A(([, , , , , , , R]) => !R),
        E(
          ([
            R,
            [D, Q],
            lt2,
            tt,
            Ft,
            Jt,
            Ut,
            ,
            de,
            Ot
          ]) => {
            const { column: Lt, row: Qt } = lt2, { height: fe, width: He } = tt, { width: nn } = Ft;
            if (Ut === 0 && (R === 0 || nn === 0))
              return yn;
            if (He === 0) {
              const cn = Ke(Ot, R), co = cn + Math.max(Ut - 1, 0);
              return kr(Hn(cn, co, Jt));
            }
            const me = so(nn, He, Lt);
            let Kt, Wt;
            de ? D === 0 && Q === 0 && Ut > 0 ? (Kt = 0, Wt = Ut - 1) : (Kt = me * Ce((D + Qt) / (fe + Qt)), Wt = me * Rn((Q + Qt) / (fe + Qt)) - 1, Wt = Oe(R - 1, ee(Wt, me - 1)), Kt = Oe(Wt, ee(0, Kt))) : (Kt = 0, Wt = -1);
            const on = Hn(Kt, Wt, Jt), { bottom: rn, top: sn } = En(Ft, lt2, tt, on), ln = Rn(R / me), lo = ln * fe + (ln - 1) * Qt - rn;
            return { bottom: rn, itemHeight: fe, items: on, itemWidth: He, offsetBottom: lo, offsetTop: sn, top: sn };
          }
        )
      ),
      B
    ), O(
      x(
        nt2,
        A((R) => R !== null),
        E((R) => R.length)
      ),
      d2
    ), O(
      x(
        rt(k2, L, B, F),
        A(([R, D, { items: Q }]) => Q.length > 0 && D.height !== 0 && R.height !== 0),
        E(([R, D, { items: Q }, lt2]) => {
          const { bottom: tt, top: Ft } = En(R, lt2, D, Q);
          return [Ft, tt];
        }),
        Z(se)
      ),
      e2
    );
    const xt = C(false);
    O(
      x(
        a2,
        N(xt),
        E(([R, D]) => D || R !== 0)
      ),
      xt
    );
    const Xt = ht(
      x(
        rt(B, d2),
        A(([{ items: R }]) => R.length > 0),
        N(xt),
        A(([[R, D], Q]) => {
          const tt = R.items[R.items.length - 1].index === D - 1;
          return (Q || R.bottom > 0 && R.itemHeight > 0 && R.offsetBottom === 0 && R.items.length === D) && tt;
        }),
        E(([[, R]]) => R - 1),
        Z()
      )
    ), Mt = ht(
      x(
        V(B),
        A(({ items: R }) => R.length > 0 && R[0].index === 0),
        Rt(0),
        Z()
      )
    ), yt = ht(
      x(
        V(B),
        N(dt2),
        A(([{ items: R }, D]) => R.length > 0 && !D),
        E(([{ items: R }]) => ({
          endIndex: R[R.length - 1].index,
          startIndex: R[0].index
        })),
        Z(Mn),
        kt(0)
      )
    );
    O(yt, I.scrollSeekRangeChanged), O(
      x(
        z,
        N(k2, L, d2, F),
        E(([R, D, Q, lt2, tt]) => {
          const Ft = Dn(R), { align: Jt, behavior: Ut, offset: de } = Ft;
          let Ot = Ft.index;
          Ot === "LAST" && (Ot = lt2 - 1), Ot = ee(0, Ot, Oe(lt2 - 1, Ot));
          let Lt = Me(D, tt, Q, Ot);
          return Jt === "end" ? Lt = bn(Lt - D.height + Q.height) : Jt === "center" && (Lt = bn(Lt - D.height / 2 + Q.height / 2)), de && (Lt += de), { behavior: Ut, top: Lt };
        })
      ),
      c4
    );
    const Bt = ct(
      x(
        B,
        E((R) => R.offsetBottom + R.bottom)
      ),
      0
    );
    return O(
      x(
        b2,
        E((R) => ({ height: R.visibleHeight, width: R.visibleWidth }))
      ),
      k2
    ), {
      customScrollParent: h2,
      // input
      data: nt2,
      deviation: J,
      footerHeight: r3,
      gap: F,
      headerHeight: s3,
      increaseViewportBy: t3,
      initialItemCount: y2,
      itemDimensions: L,
      overscan: n3,
      restoreStateFrom: it,
      scrollBy: i3,
      scrollContainerState: l2,
      scrollHeight: _,
      scrollTo: c4,
      scrollToIndex: z,
      scrollTop: a2,
      smoothScrollTargetReached: m2,
      totalCount: d2,
      useWindowScroll: p2,
      viewportDimensions: k2,
      windowScrollContainerState: u2,
      windowScrollTo: T,
      windowViewportRect: b2,
      ...I,
      // output
      gridState: B,
      horizontalDirection: At,
      initialTopMostItemIndex: St,
      totalListHeight: Bt,
      ...g2,
      endReached: Xt,
      propsReady: v2,
      rangeChanged: yt,
      startReached: Mt,
      stateChanged: Y,
      stateRestoreInProgress: dt2,
      ...f2
    };
  },
  X(je, at, ae, Yn, Pt, qe, Vt)
);
function so(t3, e2, n3) {
  return ee(1, Ce((t3 + n3) / (Ce(e2) + n3)));
}
function En(t3, e2, n3, o3) {
  const { height: r3 } = n3;
  if (r3 === void 0 || o3.length === 0)
    return { bottom: 0, top: 0 };
  const s3 = Me(t3, e2, n3, o3[0].index);
  return { bottom: Me(t3, e2, n3, o3[o3.length - 1].index) + r3, top: s3 };
}
function Me(t3, e2, n3, o3) {
  const r3 = so(t3.width, n3.width, e2.column), s3 = Ce(o3 / r3), i3 = s3 * n3.height + ee(0, s3 - 1) * e2.row;
  return i3 > 0 ? i3 + e2.row : i3;
}
var Lr = U(() => {
  const t3 = C((S3) => `Item ${S3}`), e2 = C({}), n3 = C(null), o3 = C("virtuoso-grid-item"), r3 = C("virtuoso-grid-list"), s3 = C(Xe), i3 = C("div"), l2 = C(Yt), c4 = (S3, g2 = null) => ct(
    x(
      e2,
      E((I) => I[S3]),
      Z()
    ),
    g2
  ), a2 = C(false), m2 = C(false);
  return O(V(m2), a2), {
    components: e2,
    computeItemKey: s3,
    context: n3,
    FooterComponent: c4("Footer"),
    HeaderComponent: c4("Header"),
    headerFooterTag: i3,
    itemClassName: o3,
    ItemComponent: c4("Item", "div"),
    itemContent: t3,
    listClassName: r3,
    ListComponent: c4("List", "div"),
    readyStateChanged: a2,
    reportReadyState: m2,
    ScrollerComponent: c4("Scroller", "div"),
    scrollerRef: l2,
    ScrollSeekPlaceholder: c4("ScrollSeekPlaceholder", "div")
  };
});
var zr = U(
  ([t3, e2]) => ({ ...t3, ...e2 }),
  X(Or, Lr)
);
var Vr = import_react12.default.memo(function() {
  const e2 = et("gridState"), n3 = et("listClassName"), o3 = et("itemClassName"), r3 = et("itemContent"), s3 = et("computeItemKey"), i3 = et("isSeeking"), l2 = It("scrollHeight"), c4 = et("ItemComponent"), a2 = et("ListComponent"), m2 = et("ScrollSeekPlaceholder"), S3 = et("context"), g2 = It("itemDimensions"), I = It("gap"), w3 = et("log"), v2 = et("stateRestoreInProgress"), h2 = It("reportReadyState"), p2 = Ht(
    import_react12.default.useMemo(
      () => (u2) => {
        const T = u2.parentElement.parentElement.scrollHeight;
        l2(T);
        const b2 = u2.firstChild;
        if (b2) {
          const { height: f2, width: d2 } = b2.getBoundingClientRect();
          g2({ height: f2, width: d2 });
        }
        I({
          column: Bn("column-gap", getComputedStyle(u2).columnGap, w3),
          row: Bn("row-gap", getComputedStyle(u2).rowGap, w3)
        });
      },
      [l2, g2, I, w3]
    ),
    true,
    false
  );
  return Qn(() => {
    e2.itemHeight > 0 && e2.itemWidth > 0 && h2(true);
  }, [e2]), v2 ? null : (0, import_jsx_runtime3.jsx)(
    a2,
    {
      className: n3,
      ref: p2,
      ...q(a2, S3),
      "data-testid": "virtuoso-item-list",
      style: { paddingBottom: e2.offsetBottom, paddingTop: e2.offsetTop },
      children: e2.items.map((u2) => {
        const T = s3(u2.index, u2.data, S3);
        return i3 ? (0, import_jsx_runtime3.jsx)(
          m2,
          {
            ...q(m2, S3),
            height: e2.itemHeight,
            index: u2.index,
            width: e2.itemWidth
          },
          T
        ) : (0, import_react12.createElement)(
          c4,
          {
            ...q(c4, S3),
            className: o3,
            "data-index": u2.index,
            key: T
          },
          r3(u2.index, u2.data, S3)
        );
      })
    }
  );
});
var Pr = import_react12.default.memo(function() {
  const e2 = et("HeaderComponent"), n3 = It("headerHeight"), o3 = et("headerFooterTag"), r3 = Ht(
    import_react12.default.useMemo(
      () => (i3) => {
        n3(vt(i3, "height"));
      },
      [n3]
    ),
    true,
    false
  ), s3 = et("context");
  return e2 ? (0, import_jsx_runtime3.jsx)(o3, { ref: r3, children: (0, import_jsx_runtime3.jsx)(e2, { ...q(e2, s3) }) }) : null;
});
var Ar = import_react12.default.memo(function() {
  const e2 = et("FooterComponent"), n3 = It("footerHeight"), o3 = et("headerFooterTag"), r3 = Ht(
    import_react12.default.useMemo(
      () => (i3) => {
        n3(vt(i3, "height"));
      },
      [n3]
    ),
    true,
    false
  ), s3 = et("context");
  return e2 ? (0, import_jsx_runtime3.jsx)(o3, { ref: r3, children: (0, import_jsx_runtime3.jsx)(e2, { ...q(e2, s3) }) }) : null;
});
var Mr = ({ children: t3 }) => {
  const e2 = import_react12.default.useContext(Jn), n3 = It("itemDimensions"), o3 = It("viewportDimensions"), r3 = Ht(
    import_react12.default.useMemo(
      () => (s3) => {
        o3(s3.getBoundingClientRect());
      },
      [o3]
    ),
    true,
    false
  );
  return import_react12.default.useEffect(() => {
    e2 && (o3({ height: e2.viewportHeight, width: e2.viewportWidth }), n3({ height: e2.itemHeight, width: e2.itemWidth }));
  }, [e2, o3, n3]), (0, import_jsx_runtime3.jsx)("div", { ref: r3, style: Zt(false), children: t3 });
};
var Wr = ({ children: t3 }) => {
  const e2 = import_react12.default.useContext(Jn), n3 = It("windowViewportRect"), o3 = It("itemDimensions"), r3 = et("customScrollParent"), s3 = Ne(n3, r3, false);
  return import_react12.default.useEffect(() => {
    e2 && (o3({ height: e2.itemHeight, width: e2.itemWidth }), n3({ offsetTop: 0, visibleHeight: e2.viewportHeight, visibleWidth: e2.viewportWidth }));
  }, [e2, n3, o3]), (0, import_jsx_runtime3.jsx)("div", { ref: s3, style: Zt(false), children: t3 });
};
var Gr = import_react12.default.memo(function({ ...e2 }) {
  const n3 = et("useWindowScroll"), o3 = et("customScrollParent"), r3 = o3 || n3 ? Dr : Nr, s3 = o3 || n3 ? Wr : Mr, i3 = et("context");
  return (0, import_jsx_runtime3.jsx)(r3, { ...e2, ...q(r3, i3), children: (0, import_jsx_runtime3.jsxs)(s3, { children: [
    (0, import_jsx_runtime3.jsx)(Pr, {}),
    (0, import_jsx_runtime3.jsx)(Vr, {}),
    (0, import_jsx_runtime3.jsx)(Ar, {})
  ] }) });
});
var {
  Component: _r,
  useEmitter: io,
  useEmitterValue: et,
  usePublisher: It
} = Ye(
  zr,
  {
    optional: {
      context: "context",
      totalCount: "totalCount",
      overscan: "overscan",
      itemContent: "itemContent",
      components: "components",
      computeItemKey: "computeItemKey",
      data: "data",
      initialItemCount: "initialItemCount",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "headerFooterTag",
      listClassName: "listClassName",
      itemClassName: "itemClassName",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      restoreStateFrom: "restoreStateFrom",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      increaseViewportBy: "increaseViewportBy"
    },
    methods: {
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      scrollToIndex: "scrollToIndex"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      stateChanged: "stateChanged",
      readyStateChanged: "readyStateChanged"
    }
  },
  Gr
);
var Nr = Je({ useEmitter: io, useEmitterValue: et, usePublisher: It });
var Dr = Qe({ useEmitter: io, useEmitterValue: et, usePublisher: It });
function Bn(t3, e2, n3) {
  return e2 !== "normal" && !(e2 != null && e2.endsWith("px")) && n3(`${t3} was not resolved to pixel value correctly`, e2, mt2.WARN), e2 === "normal" ? 0 : parseInt(e2 != null ? e2 : "0", 10);
}
var Jr = _r;

// node_modules/react-hook-form/dist/index.esm.mjs
var import_react13 = __toESM(require_react(), 1);
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
var isObjectType = (value) => typeof value === "object";
var isObject = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject2 = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy3;
  const isArray2 = Array.isArray(data);
  const isFileListInstance = typeof FileList !== "undefined" ? data instanceof FileList : false;
  if (data instanceof Date) {
    copy3 = new Date(data);
  } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray2 || isObject(data))) {
    copy3 = isArray2 ? [] : Object.create(Object.getPrototypeOf(data));
    if (!isArray2 && !isPlainObject2(data)) {
      copy3 = data;
    } else {
      for (const key2 in data) {
        if (data.hasOwnProperty(key2)) {
          copy3[key2] = cloneObject(data[key2]);
        }
      }
    }
  } else {
    return data;
  }
  return copy3;
}
var isKey = (value) => /^\w*$/.test(value);
var isUndefined = (val) => val === void 0;
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var get = (object, path, defaultValue) => {
  if (!path || !isObject(object)) {
    return defaultValue;
  }
  const result = (isKey(path) ? [path] : stringToPath(path)).reduce((result2, key2) => isNullOrUndefined(result2) ? result2 : result2[key2], object);
  return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
};
var isBoolean2 = (value) => typeof value === "boolean";
var set = (object, path, value) => {
  let index2 = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length2 = tempPath.length;
  const lastIndex = length2 - 1;
  while (++index2 < length2) {
    const key2 = tempPath[index2];
    let newValue = value;
    if (index2 !== lastIndex) {
      const objValue = object[key2];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index2 + 1]) ? [] : {};
    }
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return;
    }
    object[key2] = newValue;
    object = object[key2];
  }
};
var EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
var VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
var INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
var HookFormContext = import_react13.default.createContext(null);
HookFormContext.displayName = "HookFormContext";
var useFormContext = () => import_react13.default.useContext(HookFormContext);
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key2 in formState) {
    Object.defineProperty(result, key2, {
      get: () => {
        const _key = key2;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? import_react13.default.useLayoutEffect : import_react13.default.useEffect;
function useFormState(props) {
  const methods = useFormContext();
  const { control = methods.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = import_react13.default.useState(control._formState);
  const _localProxyFormState = import_react13.default.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  useIsomorphicLayoutEffect2(() => control._subscribe({
    name,
    formState: _localProxyFormState.current,
    exact,
    callback: (formState2) => {
      !disabled && updateFormState({
        ...control._formState,
        ...formState2
      });
    }
  }), [name, disabled, exact]);
  import_react13.default.useEffect(() => {
    _localProxyFormState.current.isValid && control._setValid(true);
  }, [control]);
  return import_react13.default.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual(object1, object2, _internal_visited = /* @__PURE__ */ new WeakSet()) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  if (_internal_visited.has(object1) || _internal_visited.has(object2)) {
    return true;
  }
  _internal_visited.add(object1);
  _internal_visited.add(object2);
  for (const key2 of keys1) {
    const val1 = object1[key2];
    if (!keys2.includes(key2)) {
      return false;
    }
    if (key2 !== "ref") {
      const val2 = object2[key2];
      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2, _internal_visited) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
function useWatch(props) {
  const methods = useFormContext();
  const { control = methods.control, name, defaultValue, disabled, exact, compute } = props || {};
  const _defaultValue = import_react13.default.useRef(defaultValue);
  const _compute = import_react13.default.useRef(compute);
  const _computeFormValues = import_react13.default.useRef(void 0);
  _compute.current = compute;
  const defaultValueMemo = import_react13.default.useMemo(() => control._getWatch(name, _defaultValue.current), [control, name]);
  const [value, updateValue] = import_react13.default.useState(_compute.current ? _compute.current(defaultValueMemo) : defaultValueMemo);
  useIsomorphicLayoutEffect2(() => control._subscribe({
    name,
    formState: {
      values: true
    },
    exact,
    callback: (formState) => {
      if (!disabled) {
        const formValues = generateWatchOutput(name, control._names, formState.values || control._formValues, false, _defaultValue.current);
        if (_compute.current) {
          const computedFormValues = _compute.current(formValues);
          if (!deepEqual(computedFormValues, _computeFormValues.current)) {
            updateValue(computedFormValues);
            _computeFormValues.current = computedFormValues;
          }
        } else {
          updateValue(formValues);
        }
      }
    }
  }), [control, disabled, name, exact]);
  import_react13.default.useEffect(() => control._removeUnmounted());
  return value;
}
function useController(props) {
  const methods = useFormContext();
  const { name, disabled, control = methods.control, shouldUnregister, defaultValue } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const defaultValueMemo = import_react13.default.useMemo(() => get(control._formValues, name, get(control._defaultValues, name, defaultValue)), [control, name, defaultValue]);
  const value = useWatch({
    control,
    name,
    defaultValue: defaultValueMemo,
    exact: true
  });
  const formState = useFormState({
    control,
    name,
    exact: true
  });
  const _props = import_react13.default.useRef(props);
  const _registerProps = import_react13.default.useRef(control.register(name, {
    ...props.rules,
    value,
    ...isBoolean2(props.disabled) ? { disabled: props.disabled } : {}
  }));
  _props.current = props;
  const fieldState = import_react13.default.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: true,
      get: () => !!get(formState.errors, name)
    },
    isDirty: {
      enumerable: true,
      get: () => !!get(formState.dirtyFields, name)
    },
    isTouched: {
      enumerable: true,
      get: () => !!get(formState.touchedFields, name)
    },
    isValidating: {
      enumerable: true,
      get: () => !!get(formState.validatingFields, name)
    },
    error: {
      enumerable: true,
      get: () => get(formState.errors, name)
    }
  }), [formState, name]);
  const onChange2 = import_react13.default.useCallback((event) => _registerProps.current.onChange({
    target: {
      value: getEventValue(event),
      name
    },
    type: EVENTS.CHANGE
  }), [name]);
  const onBlur = import_react13.default.useCallback(() => _registerProps.current.onBlur({
    target: {
      value: get(control._formValues, name),
      name
    },
    type: EVENTS.BLUR
  }), [name, control._formValues]);
  const ref = import_react13.default.useCallback((elm) => {
    const field2 = get(control._fields, name);
    if (field2 && elm) {
      field2._f.ref = {
        focus: () => elm.focus && elm.focus(),
        select: () => elm.select && elm.select(),
        setCustomValidity: (message2) => elm.setCustomValidity(message2),
        reportValidity: () => elm.reportValidity()
      };
    }
  }, [control._fields, name]);
  const field = import_react13.default.useMemo(() => ({
    name,
    value,
    ...isBoolean2(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
    onChange: onChange2,
    onBlur,
    ref
  }), [name, disabled, formState.disabled, onChange2, onBlur, ref, value]);
  import_react13.default.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    control.register(name, {
      ..._props.current.rules,
      ...isBoolean2(_props.current.disabled) ? { disabled: _props.current.disabled } : {}
    });
    const updateMounted = (name2, value2) => {
      const field2 = get(control._fields, name2);
      if (field2 && field2._f) {
        field2._f.mount = value2;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value2 = cloneObject(get(control._options.defaultValues, name));
      set(control._defaultValues, name, value2);
      if (isUndefined(get(control._formValues, name))) {
        set(control._formValues, name, value2);
      }
    }
    !isArrayField && control.register(name);
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  import_react13.default.useEffect(() => {
    control._setDisabledField({
      disabled,
      name
    });
  }, [disabled, name, control]);
  return import_react13.default.useMemo(() => ({
    field,
    formState,
    fieldState
  }), [field, formState, fieldState]);
}
var Controller = (props) => props.render(useController(props));
var appendErrors = (name, validateAllFieldCriteria, errors, type, message2) => validateAllFieldCriteria ? {
  ...errors[name],
  types: {
    ...errors[name] && errors[name].types ? errors[name].types : {},
    [type]: message2 || true
  }
} : {};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
var createSubject = () => {
  let _observers = [];
  const next2 = (value) => {
    for (const observer of _observers) {
      observer.next && observer.next(value);
    }
  };
  const subscribe2 = (observer) => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o3) => o3 !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next: next2,
    subscribe: subscribe2,
    unsubscribe
  };
};
var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;
var isFileInput = (element) => element.type === "file";
var isFunction = (value) => typeof value === "function";
var isHTMLElement2 = (value) => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioInput = (element) => element.type === "radio";
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement2(ref) && ref.isConnected;
function baseGet(object, updatePath) {
  const length2 = updatePath.slice(0, -1).length;
  let index2 = 0;
  while (index2 < length2) {
    object = isUndefined(object) ? index2++ : object[updatePath[index2++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key2 in obj) {
    if (obj.hasOwnProperty(key2) && !isUndefined(obj[key2])) {
      return false;
    }
  }
  return true;
}
function unset(object, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object : baseGet(object, paths);
  const index2 = paths.length - 1;
  const key2 = paths[index2];
  if (childObject) {
    delete childObject[key2];
  }
  if (index2 !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object, paths.slice(0, -1));
  }
  return object;
}
var objectHasFunction = (data) => {
  for (const key2 in data) {
    if (isFunction(data[key2])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key2 in data) {
      if (Array.isArray(data[key2]) || isObject(data[key2]) && !objectHasFunction(data[key2])) {
        fields[key2] = Array.isArray(data[key2]) ? [] : {};
        markFieldsDirty(data[key2], fields[key2]);
      } else if (!isNullOrUndefined(data[key2])) {
        fields[key2] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key2 in data) {
      if (Array.isArray(data[key2]) || isObject(data[key2]) && !objectHasFunction(data[key2])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key2])) {
          dirtyFieldsFromValues[key2] = Array.isArray(data[key2]) ? markFieldsDirty(data[key2], []) : { ...markFieldsDirty(data[key2]) };
        } else {
          getDirtyFieldsFromDefaultValues(data[key2], isNullOrUndefined(formValues) ? {} : formValues[key2], dirtyFieldsFromValues[key2]);
        }
      } else {
        dirtyFieldsFromValues[key2] = !deepEqual(data[key2], formValues[key2]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var defaultResult = {
  value: false,
  isValid: false
};
var validResult = { value: true, isValid: true };
var getCheckboxValue = (options2) => {
  if (Array.isArray(options2)) {
    if (options2.length > 1) {
      const values = options2.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values, isValid: !!values.length };
    }
    return options2[0].checked && !options2[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      options2[0].attributes && !isUndefined(options2[0].attributes.value) ? isUndefined(options2[0].value) || options2[0].value === "" ? validResult : { value: options2[0].value, isValid: true } : validResult
    ) : defaultResult;
  }
  return defaultResult;
};
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
var defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options2) => Array.isArray(options2) ? options2.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getFieldValue(_f) {
  const ref = _f.ref;
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get(_fields, name);
    field && set(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var isRegex = (value) => value instanceof RegExp;
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = (fieldReference) => !!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = (options2) => options2.mount && (options2.required || options2.min || options2.max || options2.maxLength || options2.minLength || options2.pattern || options2.validate);
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
var iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
  for (const key2 of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key2);
    if (field) {
      const { _f, ...currentField } = field;
      if (_f) {
        if (_f.refs && _f.refs[0] && action(_f.refs[0], key2) && !abortEarly) {
          return true;
        } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject(currentField)) {
        if (iterateFieldsByAction(currentField, action)) {
          break;
        }
      }
    }
  }
  return;
};
function schemaErrorLookup(errors, _fields, name) {
  const error = get(errors, name);
  if (error || isKey(name)) {
    return {
      error,
      name
    };
  }
  const names = name.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    if (foundError && foundError.root && foundError.root.type) {
      return {
        name: `${fieldName}.root`,
        error: foundError.root
      };
    }
    names.pop();
  }
  return {
    name
  };
}
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const { name, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key2) => _proxyFormState[key2] === (!isRoot || VALIDATION_MODE.all));
};
var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);
var updateFieldArrayRootError = (errors, error, name) => {
  const fieldArrayErrors = convertToArrayPayload(get(errors, name));
  set(fieldArrayErrors, "root", error[name]);
  set(errors, name, fieldArrayErrors);
  return errors;
};
var isMessage = (value) => isString(value);
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean2(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount } = field._f;
  const inputValue = get(formValues, name);
  if (!mount || disabledFieldNames.has(name)) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message2) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean2(message2) ? "" : message2 || "");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement2(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message2 = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = {
      type: exceedMax ? maxType : minType,
      message: message2,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message2)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean2(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value, message: message2 } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (value) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.required,
        message: message2,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message2)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message2);
        return error;
      }
    }
  }
  if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max);
    const minOutput = getValueAndMessage(min);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
      const isTime = ref.type == "time";
      const isWeek = ref.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty && isString(inputValue)) {
    const { value: patternValue, message: message2 } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message: message2,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message2)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message2);
        return error;
      }
    }
  }
  if (validate) {
    if (isFunction(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject(validate)) {
      let validationResult = {};
      for (const key2 in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key2](inputValue, formValues), inputRef, key2);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key2, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
var defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}) {
  let _options = {
    ...defaultOptions,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isReady: false,
    isLoading: isFunction(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  let _fields = {};
  let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    disabled: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  let _proxySubscribeFormState = {
    ..._proxyFormState
  };
  const _subjects = {
    array: createSubject(),
    state: createSubject()
  };
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce = (callback) => (wait) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _setValid = async (shouldUpdateValid) => {
    if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {
      const isValid3 = _options.resolver ? isEmptyObject((await _runSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid3 !== _formState.isValid) {
        _subjects.state.next({
          isValid: isValid3
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {
      (names || Array.from(_names.mount)).forEach((name) => {
        if (name) {
          isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method && !_options.disabled) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
        const fieldValues = method(get(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {
        const errors = method(get(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {
        const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name, values);
    }
  };
  const updateErrors = (name, error) => {
    set(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = (errors) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get(_fields, name);
    if (field) {
      const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
      _state.mount && _setValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name
    };
    if (!_options.disabled) {
      if (!isBlurEvent || shouldDirty) {
        if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {
          isPreviousDirty = _formState.isDirty;
          _formState.isDirty = output.isDirty = _getDirty();
          shouldUpdateField = isPreviousDirty !== output.isDirty;
        }
        const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);
        isPreviousDirty = !!get(_formState.dirtyFields, name);
        isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
        output.dirtyFields = _formState.dirtyFields;
        shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;
      }
      if (isBlurEvent) {
        const isPreviousFieldTouched = get(_formState.touchedFields, name);
        if (!isPreviousFieldTouched) {
          set(_formState.touchedFields, name, isBlurEvent);
          output.touchedFields = _formState.touchedFields;
          shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;
        }
      }
      shouldUpdateField && shouldRender && _subjects.state.next(output);
    }
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name, isValid3, error, fieldState) => {
    const previousFieldError = get(_formState.errors, name);
    const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean2(isValid3) && _formState.isValid !== isValid3;
    if (_options.delayError && error) {
      delayErrorCallback = debounce(() => updateErrors(name, error));
      delayErrorCallback(_options.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
    }
    if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean2(isValid3) ? { isValid: isValid3 } : {},
        errors: _formState.errors,
        name
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
  };
  const _runSchema = async (name) => {
    _updateIsValidating(name, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name);
    return result;
  };
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _runSchema(names);
    if (names) {
      for (const name of names) {
        const error = get(errors, name);
        error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const { _f, ...fieldValue } = field;
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const isPromiseFunction = field._f && hasPromiseValidation(field._f);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name], true);
          }
          const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name]);
          }
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name, data) => !_options.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? { [names]: defaultValue } : defaultValue
  }, isGlobal, defaultValue);
  const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));
  const setFieldValue = (name, value, options2 = {}) => {
    const field = get(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement2(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.forEach((checkboxRef) => {
              if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {
                if (Array.isArray(fieldValue)) {
                  checkboxRef.checked = !!fieldValue.find((data) => data === checkboxRef.value);
                } else {
                  checkboxRef.checked = fieldValue === checkboxRef.value || !!fieldValue;
                }
              }
            });
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.state.next({
              name,
              values: cloneObject(_formValues)
            });
          }
        }
      }
    }
    (options2.shouldDirty || options2.shouldTouch) && updateTouchAndDirty(name, fieldValue, options2.shouldTouch, options2.shouldDirty, true);
    options2.shouldValidate && trigger(name);
  };
  const setValues = (name, value, options2) => {
    for (const fieldKey in value) {
      if (!value.hasOwnProperty(fieldKey)) {
        return;
      }
      const fieldValue = value[fieldKey];
      const fieldName = name + "." + fieldKey;
      const field = get(_fields, fieldName);
      (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options2) : setFieldValue(fieldName, fieldValue, options2);
    }
  };
  const setValue = (name, value, options2 = {}) => {
    const field = get(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: cloneObject(_formValues)
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options2.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options2) : setFieldValue(name, cloneValue, options2);
    }
    isWatched(name, _names) && _subjects.state.next({ ..._formState, name });
    _subjects.state.next({
      name: _state.mount ? name : void 0,
      values: cloneObject(_formValues)
    });
  };
  const onChange2 = async (event) => {
    _state.mount = true;
    const target = event.target;
    let name = target.name;
    let isFieldValueUpdated = true;
    const field = get(_fields, name);
    const _updateIsFieldValueUpdated = (fieldValue) => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get(_formValues, name, fieldValue));
    };
    const validationModeBeforeSubmit = getValidationModes(_options.mode);
    const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
    if (field) {
      let error;
      let isValid3;
      const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set(_formValues, name, fieldValue);
      if (isBlurEvent) {
        if (!target || !target.readOnly) {
          field._f.onBlur && field._f.onBlur(event);
          delayErrorCallback && delayErrorCallback(0);
        }
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.state.next({
        name,
        type: event.type,
        values: cloneObject(_formValues)
      });
      if (shouldSkipValidation) {
        if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
          if (_options.mode === "onBlur") {
            if (isBlurEvent) {
              _setValid();
            }
          } else if (!isBlurEvent) {
            _setValid();
          }
        }
        return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      if (_options.resolver) {
        const { errors } = await _runSchema([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
          error = errorLookupResult.error;
          name = errorLookupResult.name;
          isValid3 = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        _updateIsValidating([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error) {
            isValid3 = false;
          } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
            isValid3 = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger(field._f.deps);
        shouldRenderByError(name, isValid3, error, fieldState);
      }
    }
  };
  const _focusInput = (ref, key2) => {
    if (get(_formState.errors, key2) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };
  const trigger = async (name, options2 = {}) => {
    let isValid3;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid3 = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get(errors, name2)) : isValid3;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _setValid();
    } else {
      validationResult = isValid3 = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid3 !== _formState.isValid ? {} : { name },
      ..._options.resolver || !name ? { isValid: isValid3 } : {},
      errors: _formState.errors
    });
    options2.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values = {
      ..._state.mount ? _formValues : _defaultValues
    };
    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name) => get(values, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get((formState || _formState).errors, name),
    isDirty: !!get((formState || _formState).dirtyFields, name),
    error: get((formState || _formState).errors, name),
    isValidating: !!get(_formState.validatingFields, name),
    isTouched: !!get((formState || _formState).touchedFields, name)
  });
  const clearErrors = (name) => {
    name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error, options2) => {
    const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
    const currentError = get(_formState.errors, name) || {};
    const { ref: currentRef, message: message2, type, ...restOfErrorTree } = currentError;
    set(_formState.errors, name, {
      ...restOfErrorTree,
      ...error,
      ref
    });
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options2 && options2.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue) => isFunction(name) ? _subjects.state.subscribe({
    next: (payload) => "values" in payload && name(_getWatch(void 0, defaultValue), payload)
  }) : _getWatch(name, defaultValue, true);
  const _subscribe = (props2) => _subjects.state.subscribe({
    next: (formState) => {
      if (shouldSubscribeByName(props2.name, formState.name, props2.exact) && shouldRenderFormState(formState, props2.formState || _proxyFormState, _setFormState, props2.reRenderRoot)) {
        props2.callback({
          values: { ..._formValues },
          ..._formState,
          ...formState,
          defaultValues: _defaultValues
        });
      }
    }
  }).unsubscribe;
  const subscribe2 = (props2) => {
    _state.mount = true;
    _proxySubscribeFormState = {
      ..._proxySubscribeFormState,
      ...props2.formState
    };
    return _subscribe({
      ...props2,
      formState: _proxySubscribeFormState
    });
  };
  const unregister = (name, options2 = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options2.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options2.keepError && unset(_formState.errors, fieldName);
      !options2.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options2.keepTouched && unset(_formState.touchedFields, fieldName);
      !options2.keepIsValidating && unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options2.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.state.next({
      values: cloneObject(_formValues)
    });
    _subjects.state.next({
      ..._formState,
      ...!options2.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options2.keepIsValid && _setValid();
  };
  const _setDisabledField = ({ disabled, name }) => {
    if (isBoolean2(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {
      disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
    }
  };
  const register = (name, options2 = {}) => {
    let field = get(_fields, name);
    const disabledIsDefined = isBoolean2(options2.disabled) || isBoolean2(_options.disabled);
    set(_fields, name, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name } },
        name,
        mount: true,
        ...options2
      }
    });
    _names.mount.add(name);
    if (field) {
      _setDisabledField({
        disabled: isBoolean2(options2.disabled) ? options2.disabled : _options.disabled,
        name
      });
    } else {
      updateValidAndValue(name, true, options2.value);
    }
    return {
      ...disabledIsDefined ? { disabled: options2.disabled || _options.disabled } : {},
      ..._options.progressive ? {
        required: !!options2.required,
        min: getRuleValue(options2.min),
        max: getRuleValue(options2.max),
        minLength: getRuleValue(options2.minLength),
        maxLength: getRuleValue(options2.maxLength),
        pattern: getRuleValue(options2.pattern)
      } : {},
      name,
      onChange: onChange2,
      onBlur: onChange2,
      ref: (ref) => {
        if (ref) {
          register(name, options2);
          field = get(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get(_defaultValues, name)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options2.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = (disabled) => {
    if (isBoolean2(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(_fields, (ref, name) => {
        const currentField = get(_fields, name);
        if (currentField) {
          ref.disabled = currentField._f.disabled || disabled;
          if (Array.isArray(currentField._f.refs)) {
            currentField._f.refs.forEach((inputRef) => {
              inputRef.disabled = currentField._f.disabled || disabled;
            });
          }
        }
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async (e2) => {
    let onValidError = void 0;
    if (e2) {
      e2.preventDefault && e2.preventDefault();
      e2.persist && e2.persist();
    }
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values } = await _runSchema();
      _formState.errors = errors;
      fieldValues = cloneObject(values);
    } else {
      await executeBuiltInValidation(_fields);
    }
    if (_names.disabled.size) {
      for (const name of _names.disabled) {
        unset(fieldValues, name);
      }
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e2);
      } catch (error) {
        onValidError = error;
      }
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e2);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = (name, options2 = {}) => {
    if (get(_fields, name)) {
      if (isUndefined(options2.defaultValue)) {
        setValue(name, cloneObject(get(_defaultValues, name)));
      } else {
        setValue(name, options2.defaultValue);
        set(_defaultValues, name, cloneObject(options2.defaultValue));
      }
      if (!options2.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options2.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options2.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();
      }
      if (!options2.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _setValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        const fieldsToCheck = /* @__PURE__ */ new Set([
          ..._names.mount,
          ...Object.keys(getDirtyFields(_defaultValues, _formValues))
        ]);
        for (const fieldName of Array.from(fieldsToCheck)) {
          get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement2(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        if (keepStateOptions.keepFieldsRef) {
          for (const fieldName of _names.mount) {
            setValue(fieldName, get(values, fieldName));
          }
        } else {
          _fields = {};
        }
      }
      _formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);
      _subjects.array.next({
        values: { ...values }
      });
      _subjects.state.next({
        values: { ...values }
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!_options.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false,
      defaultValues: _defaultValues
    });
  };
  const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name, options2 = {}) => {
    const field = get(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options2.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();
      }
    }
  };
  const _setFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then((values) => {
    reset(values, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  const methods = {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _subscribe,
      _runSchema,
      _focusError,
      _getWatch,
      _getDirty,
      _setValid,
      _setFieldArray,
      _setDisabledField,
      _setErrors,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _removeUnmounted,
      _disableForm,
      _subjects,
      _proxyFormState,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    subscribe: subscribe2,
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
  return {
    ...methods,
    formControl: methods
  };
}
function useForm(props = {}) {
  const _formControl = import_react13.default.useRef(void 0);
  const _values = import_react13.default.useRef(void 0);
  const [formState, updateFormState] = import_react13.default.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    isReady: false,
    defaultValues: isFunction(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    if (props.formControl) {
      _formControl.current = {
        ...props.formControl,
        formState
      };
      if (props.defaultValues && !isFunction(props.defaultValues)) {
        props.formControl.reset(props.defaultValues, props.resetOptions);
      }
    } else {
      const { formControl, ...rest } = createFormControl(props);
      _formControl.current = {
        ...rest,
        formState
      };
    }
  }
  const control = _formControl.current.control;
  control._options = props;
  useIsomorphicLayoutEffect2(() => {
    const sub = control._subscribe({
      formState: control._proxyFormState,
      callback: () => updateFormState({ ...control._formState }),
      reRenderRoot: true
    });
    updateFormState((data) => ({
      ...data,
      isReady: true
    }));
    control._formState.isReady = true;
    return sub;
  }, [control]);
  import_react13.default.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  import_react13.default.useEffect(() => {
    if (props.mode) {
      control._options.mode = props.mode;
    }
    if (props.reValidateMode) {
      control._options.reValidateMode = props.reValidateMode;
    }
  }, [control, props.mode, props.reValidateMode]);
  import_react13.default.useEffect(() => {
    if (props.errors) {
      control._setErrors(props.errors);
      control._focusError();
    }
  }, [control, props.errors]);
  import_react13.default.useEffect(() => {
    props.shouldUnregister && control._subjects.state.next({
      values: control._getWatch()
    });
  }, [control, props.shouldUnregister]);
  import_react13.default.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty2 = control._getDirty();
      if (isDirty2 !== formState.isDirty) {
        control._subjects.state.next({
          isDirty: isDirty2
        });
      }
    }
  }, [control, formState.isDirty]);
  import_react13.default.useEffect(() => {
    if (props.values && !deepEqual(props.values, _values.current)) {
      control._reset(props.values, {
        keepFieldsRef: true,
        ...control._options.resetOptions
      });
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [control, props.values]);
  import_react13.default.useEffect(() => {
    if (!control._state.mount) {
      control._setValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}

// node_modules/@hookform/resolvers/dist/resolvers.mjs
var s = (e2, s3, o3) => {
  if (e2 && "reportValidity" in e2) {
    const r3 = get(o3, s3);
    e2.setCustomValidity(r3 && r3.message || ""), e2.reportValidity();
  }
};
var o = (t3, e2) => {
  for (const o3 in e2.fields) {
    const r3 = e2.fields[o3];
    r3 && r3.ref && "reportValidity" in r3.ref ? s(r3.ref, o3, t3) : r3.refs && r3.refs.forEach((e3) => s(e3, o3, t3));
  }
};
var r = (s3, r3) => {
  r3.shouldUseNativeValidation && o(s3, r3);
  const f2 = {};
  for (const o3 in s3) {
    const n3 = get(r3.fields, o3), a2 = Object.assign(s3[o3] || {}, { ref: n3 && n3.ref });
    if (i(r3.names || Object.keys(s3), o3)) {
      const s4 = Object.assign({}, get(f2, o3));
      set(s4, "root", a2), set(f2, o3, s4);
    } else set(f2, o3, a2);
  }
  return f2;
};
var i = (t3, e2) => t3.some((t4) => t4.startsWith(e2 + "."));

// node_modules/@hookform/resolvers/zod/dist/zod.mjs
var n = function(r3, e2) {
  for (var n3 = {}; r3.length; ) {
    var t3 = r3[0], s3 = t3.code, i3 = t3.message, a2 = t3.path.join(".");
    if (!n3[a2]) if ("unionErrors" in t3) {
      var u2 = t3.unionErrors[0].errors[0];
      n3[a2] = { message: u2.message, type: u2.code };
    } else n3[a2] = { message: i3, type: s3 };
    if ("unionErrors" in t3 && t3.unionErrors.forEach(function(e3) {
      return e3.errors.forEach(function(e4) {
        return r3.push(e4);
      });
    }), e2) {
      var c4 = n3[a2].types, f2 = c4 && c4[t3.code];
      n3[a2] = appendErrors(a2, e2, n3, s3, f2 ? [].concat(f2, t3.message) : t3.message);
    }
    r3.shift();
  }
  return n3;
};
var t = function(o3, t3, s3) {
  return void 0 === s3 && (s3 = {}), function(i3, a2, u2) {
    try {
      return Promise.resolve((function(e2, n3) {
        try {
          var a3 = Promise.resolve(o3["sync" === s3.mode ? "parse" : "parseAsync"](i3, t3)).then(function(e3) {
            return u2.shouldUseNativeValidation && o({}, u2), { errors: {}, values: s3.raw ? i3 : e3 };
          });
        } catch (r3) {
          return n3(r3);
        }
        return a3 && a3.then ? a3.then(void 0, n3) : a3;
      })(0, function(r3) {
        if ((function(r4) {
          return Array.isArray(null == r4 ? void 0 : r4.errors);
        })(r3)) return { values: {}, errors: r(n(r3.errors, !u2.shouldUseNativeValidation && "all" === u2.criteriaMode), u2) };
        throw r3;
      }));
    } catch (r3) {
      return Promise.reject(r3);
    }
  };
};

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key2 in object) {
      if (Object.prototype.hasOwnProperty.call(object, key2)) {
        keys.push(key2);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return {
      ...first2,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t3 = typeof data;
  switch (t3) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i3 = 0;
          while (i3 < issue.path.length) {
            const el = issue.path[i3];
            const terminal = i3 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i3++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message2;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message2 = "Required";
      } else {
        message2 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message2 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message2 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message2 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message2 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message2 = `Invalid ${issue.validation}`;
      } else {
        message2 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message2 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message2 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message2 = "Number must be finite";
      break;
    default:
      message2 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message2 };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function getErrorMap() {
  return overrideErrorMap;
}

// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x3) => !!x3)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s3 of results) {
      if (s3.status === "aborted")
        return INVALID;
      if (s3.status === "dirty")
        status.dirty();
      arrayValue.push(s3.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key2 = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key: key2,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key2, value } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key2.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x3) => x3.status === "aborted";
var isDirty = (x3) => x3.status === "dirty";
var isValid = (x3) => x3.status === "valid";
var isAsync = (x3) => typeof Promise !== "undefined" && x3 instanceof Promise;

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
  errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key2) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key2;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message: message2 } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message2 ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message2 ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message2 ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message2) {
    const getIssueProperties = (val) => {
      if (typeof message2 === "string" || typeof message2 === "undefined") {
        return { message: message2 };
      } else if (typeof message2 === "function") {
        return message2(val);
      } else {
        return message2;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message2) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message2)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message2) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message2) });
  }
  url(message2) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message2) });
  }
  emoji(message2) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message2) });
  }
  uuid(message2) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message2) });
  }
  nanoid(message2) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message2) });
  }
  cuid(message2) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message2) });
  }
  cuid2(message2) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message2) });
  }
  ulid(message2) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message2) });
  }
  base64(message2) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message2) });
  }
  base64url(message2) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message2)
    });
  }
  jwt(options2) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options2) });
  }
  ip(options2) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
  }
  cidr(options2) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options2) });
  }
  datetime(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options2
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
      offset: options2?.offset ?? false,
      local: options2?.local ?? false,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  date(message2) {
    return this._addCheck({ kind: "date", message: message2 });
  }
  time(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options2
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  duration(message2) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message2) });
  }
  regex(regex, message2) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message2)
    });
  }
  includes(value, options2) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options2?.position,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  startsWith(value, message2) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  endsWith(value, message2) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  min(minLength, message2) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message2)
    });
  }
  max(maxLength, message2) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message2)
    });
  }
  length(len, message2) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message2)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message2) {
    return this.min(1, errorUtil.errToObj(message2));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message2) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message2)
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  finite(message2) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message2)
    });
  }
  safe(message2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message2) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  max(maxDate, message2) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i3) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i3) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message2) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message2) }
    });
  }
  max(maxLength, message2) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message2) }
    });
  }
  length(len, message2) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message2) }
    });
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key2 in ctx.data) {
        if (!shapeKeys.includes(key2)) {
          extraKeys.push(key2);
        }
      }
    }
    const pairs = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape[key2];
      const value = ctx.data[key2];
      pairs.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key2)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key: key2,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message2) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message2 !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message2).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new _ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    for (const key2 of util.objectKeys(mask)) {
      if (mask[key2] && this.shape[key2]) {
        shape[key2] = this.shape[key2];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key2 of util.objectKeys(this.shape)) {
      if (!mask[key2]) {
        shape[key2] = this.shape[key2];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key2 of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key2];
      if (mask && !mask[key2]) {
        newShape[key2] = fieldSchema;
      } else {
        newShape[key2] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key2 of util.objectKeys(this.shape)) {
      if (mask && !mask[key2]) {
        newShape[key2] = this.shape[key2];
      } else {
        const fieldSchema = this.shape[key2];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key2] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options2 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options2.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options2) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options2, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options2) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options2,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a2[key2], b2[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x3) => !!x3);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first2, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first2,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first2,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key2, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key2 = pair.key;
        const value = pair.value;
        if (key2.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message2) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message2) }
    });
  }
  max(maxSize, message2) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message2) }
    });
  }
  size(size2, message2) {
    return this.min(size2, message2).max(size2, message2);
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new _ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze2 = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze2(data)) : freeze2(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US/_lib/formatDistance.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = (token2, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2?.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/_lib/buildFormatLongFn.js
function buildFormatLongFn(args) {
  return (options2 = {}) => {
    const width = options2.width ? String(options2.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US/_lib/formatLong.js
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US/_lib/formatRelative.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = (token2, _date, _baseDate, _options) => formatRelativeLocale[token2];

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/_lib/buildLocalizeFn.js
function buildLocalizeFn(args) {
  return (value, options2) => {
    const context = options2?.context ? String(options2.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options2?.width ? String(options2.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options2?.width ? String(options2.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US/_lib/localize.js
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/_lib/buildMatchFn.js
function buildMatchFn(args) {
  return (string, options2 = {}) => {
    const width = options2.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key2 = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key2) : key2;
    value = options2.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options2.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key2 in object) {
    if (Object.prototype.hasOwnProperty.call(object, key2) && predicate(object[key2])) {
      return key2;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key2 = 0; key2 < array.length; key2++) {
    if (predicate(array[key2])) {
      return key2;
    }
  }
  return void 0;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/_lib/buildMatchPatternFn.js
function buildMatchPatternFn(args) {
  return (string, options2 = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options2.valueCallback ? options2.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US/_lib/match.js
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US.js
var enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match: match2,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/defaultOptions.js
var defaultOptions2 = {};
function getDefaultOptions() {
  return defaultOptions2;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/constants.js
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var millisecondsInWeek = 6048e5;
var millisecondsInDay = 864e5;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;
var constructFromSymbol = Symbol.for("constructDateFrom");

// node_modules/sanity-plugin-media/node_modules/date-fns/constructFrom.js
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}

// node_modules/sanity-plugin-media/node_modules/date-fns/toDate.js
function toDate(argument, context) {
  return constructFrom(context || argument, argument);
}

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/normalizeDates.js
function normalizeDates(context, ...dates) {
  const normalize = constructFrom.bind(
    null,
    context || dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize);
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfDay.js
function startOfDay(date, options2) {
  const _date = toDate(date, options2?.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/differenceInCalendarDays.js
function differenceInCalendarDays(laterDate, earlierDate, options2) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options2?.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfYear.js
function startOfYear(date, options2) {
  const date_ = toDate(date, options2?.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/getDayOfYear.js
function getDayOfYear(date, options2) {
  const _date = toDate(date, options2?.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfWeek.js
function startOfWeek(date, options2) {
  const defaultOptions3 = getDefaultOptions();
  const weekStartsOn = options2?.weekStartsOn ?? options2?.locale?.options?.weekStartsOn ?? defaultOptions3.weekStartsOn ?? defaultOptions3.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date, options2?.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfISOWeek.js
function startOfISOWeek(date, options2) {
  return startOfWeek(date, { ...options2, weekStartsOn: 1 });
}

// node_modules/sanity-plugin-media/node_modules/date-fns/getISOWeekYear.js
function getISOWeekYear(date, options2) {
  const _date = toDate(date, options2?.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfISOWeekYear.js
function startOfISOWeekYear(date, options2) {
  const year = getISOWeekYear(date, options2);
  const fourthOfJanuary = constructFrom(options2?.in || date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// node_modules/sanity-plugin-media/node_modules/date-fns/getISOWeek.js
function getISOWeek(date, options2) {
  const _date = toDate(date, options2?.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/getWeekYear.js
function getWeekYear(date, options2) {
  const _date = toDate(date, options2?.in);
  const year = _date.getFullYear();
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = options2?.firstWeekContainsDate ?? options2?.locale?.options?.firstWeekContainsDate ?? defaultOptions3.firstWeekContainsDate ?? defaultOptions3.locale?.options?.firstWeekContainsDate ?? 1;
  const firstWeekOfNextYear = constructFrom(options2?.in || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options2);
  const firstWeekOfThisYear = constructFrom(options2?.in || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options2);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfWeekYear.js
function startOfWeekYear(date, options2) {
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = options2?.firstWeekContainsDate ?? options2?.locale?.options?.firstWeekContainsDate ?? defaultOptions3.firstWeekContainsDate ?? defaultOptions3.locale?.options?.firstWeekContainsDate ?? 1;
  const year = getWeekYear(date, options2);
  const firstWeek = constructFrom(options2?.in || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options2);
  return _date;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/getWeek.js
function getWeek(date, options2) {
  const _date = toDate(date, options2?.in);
  const diff = +startOfWeek(_date, options2) - +startOfWeekYear(_date, options2);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/addLeadingZeros.js
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/format/lightFormatters.js
var lightFormatters = {
  // Year
  y(date, token2) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token2 === "yy" ? year % 100 : year, token2.length);
  },
  // Month
  M(date, token2) {
    const month = date.getMonth();
    return token2 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token2) {
    return addLeadingZeros(date.getDate(), token2.length);
  },
  // AM or PM
  a(date, token2) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token2) {
    return addLeadingZeros(date.getHours() % 12 || 12, token2.length);
  },
  // Hour [0-23]
  H(date, token2) {
    return addLeadingZeros(date.getHours(), token2.length);
  },
  // Minute
  m(date, token2) {
    return addLeadingZeros(date.getMinutes(), token2.length);
  },
  // Second
  s(date, token2) {
    return addLeadingZeros(date.getSeconds(), token2.length);
  },
  // Fraction of second
  S(date, token2) {
    const numberOfDigits = token2.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token2.length);
  }
};

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/format/formatters.js
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function(date, token2, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token2) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token2, localize2) {
    if (token2 === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token2);
  },
  // Local week-numbering year
  Y: function(date, token2, localize2, options2) {
    const signedWeekYear = getWeekYear(date, options2);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token2 === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token2 === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token2.length);
  },
  // ISO week-numbering year
  R: function(date, token2) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token2.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token2) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token2.length);
  },
  // Quarter
  Q: function(date, token2, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token2) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token2, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token2) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token2, localize2) {
    const month = date.getMonth();
    switch (token2) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token2);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token2, localize2) {
    const month = date.getMonth();
    switch (token2) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token2, localize2, options2) {
    const week = getWeek(date, options2);
    if (token2 === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token2.length);
  },
  // ISO week of year
  I: function(date, token2, localize2) {
    const isoWeek = getISOWeek(date);
    if (token2 === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token2.length);
  },
  // Day of the month
  d: function(date, token2, localize2) {
    if (token2 === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token2);
  },
  // Day of year
  D: function(date, token2, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token2 === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token2.length);
  },
  // Day of week
  E: function(date, token2, localize2) {
    const dayOfWeek = date.getDay();
    switch (token2) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token2, localize2, options2) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token2, localize2, options2) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token2.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token2, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token2) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token2.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token2, localize2) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token2, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token2) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token2, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token2) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token2, localize2) {
    if (token2 === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token2);
  },
  // Hour [0-23]
  H: function(date, token2, localize2) {
    if (token2 === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token2);
  },
  // Hour [0-11]
  K: function(date, token2, localize2) {
    const hours = date.getHours() % 12;
    if (token2 === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token2.length);
  },
  // Hour [1-24]
  k: function(date, token2, localize2) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;
    if (token2 === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token2.length);
  },
  // Minute
  m: function(date, token2, localize2) {
    if (token2 === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token2);
  },
  // Second
  s: function(date, token2, localize2) {
    if (token2 === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token2);
  },
  // Fraction of second
  S: function(date, token2) {
    return lightFormatters.S(date, token2);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token2) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token2) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token2) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token2) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token2, _localize) {
    const timestamp = Math.trunc(+date / 1e3);
    return addLeadingZeros(timestamp, token2.length);
  },
  // Milliseconds timestamp
  T: function(date, token2, _localize) {
    return addLeadingZeros(+date, token2.length);
  }
};
function formatTimezoneShort(offset2, delimiter2 = "") {
  const sign = offset2 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset2);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter2 + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset2, delimiter2) {
  if (offset2 % 60 === 0) {
    const sign = offset2 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset2) / 60, 2);
  }
  return formatTimezone(offset2, delimiter2);
}
function formatTimezone(offset2, delimiter2 = "") {
  const sign = offset2 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset2);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter2 + minutes;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/format/longFormatters.js
var dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
var timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
var dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/protectedTokens.js
var dayOfYearTokenRE = /^D+$/;
var weekYearTokenRE = /^Y+$/;
var throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token2) {
  return dayOfYearTokenRE.test(token2);
}
function isProtectedWeekYearToken(token2) {
  return weekYearTokenRE.test(token2);
}
function warnOrThrowProtectedError(token2, format2, input) {
  const _message = message(token2, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token2)) throw new RangeError(_message);
}
function message(token2, format2, input) {
  const subject = token2[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token2.toLowerCase()}\` instead of \`${token2}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/isDate.js
function isDate2(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/sanity-plugin-media/node_modules/date-fns/isValid.js
function isValid2(date) {
  return !(!isDate2(date) && typeof date !== "number" || isNaN(+toDate(date)));
}

// node_modules/sanity-plugin-media/node_modules/date-fns/format.js
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date, formatStr, options2) {
  const defaultOptions3 = getDefaultOptions();
  const locale = options2?.locale ?? defaultOptions3.locale ?? enUS;
  const firstWeekContainsDate = options2?.firstWeekContainsDate ?? options2?.locale?.options?.firstWeekContainsDate ?? defaultOptions3.firstWeekContainsDate ?? defaultOptions3.locale?.options?.firstWeekContainsDate ?? 1;
  const weekStartsOn = options2?.weekStartsOn ?? options2?.locale?.options?.weekStartsOn ?? defaultOptions3.weekStartsOn ?? defaultOptions3.locale?.options?.weekStartsOn ?? 0;
  const originalDate = toDate(date, options2?.in);
  if (!isValid2(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token2 = part.value;
    if (!options2?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token2) || !options2?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token2)) {
      warnOrThrowProtectedError(token2, formatStr, String(date));
    }
    const formatter = formatters[token2[0]];
    return formatter(originalDate, token2, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
var format_default = format;

// node_modules/filesize/lib/filesize.esm.js
var ARRAY = "array";
var BIT = "bit";
var BITS = "bits";
var BYTE = "byte";
var BYTES = "bytes";
var EMPTY2 = "";
var EXPONENT = "exponent";
var FUNCTION = "function";
var IEC = "iec";
var INVALID_NUMBER = "Invalid number";
var INVALID_ROUND = "Invalid rounding method";
var JEDEC = "jedec";
var OBJECT = "object";
var PERIOD = ".";
var ROUND = "round";
var S = "s";
var SI_KBIT = "kbit";
var SI_KBYTE = "kB";
var SPACE = " ";
var STRING = "string";
var ZERO = "0";
var strings = {
  symbol: {
    iec: {
      bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
      bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
    },
    jedec: {
      bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
      bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
    }
  },
  fullform: {
    iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
    jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
  }
};
function filesize(arg, {
  bits = false,
  pad = false,
  base = -1,
  round: round2 = 2,
  locale = EMPTY2,
  localeOptions = {},
  separator = EMPTY2,
  spacer = SPACE,
  symbols = {},
  standard = EMPTY2,
  output = STRING,
  fullform = false,
  fullforms = [],
  exponent = -1,
  roundingMethod = ROUND,
  precision = 0
} = {}) {
  let e2 = exponent, num = Number(arg), result = [], val = 0, u2 = EMPTY2;
  if (base === -1 && standard.length === 0) {
    base = 10;
    standard = JEDEC;
  } else if (base === -1 && standard.length > 0) {
    standard = standard === IEC ? IEC : JEDEC;
    base = standard === IEC ? 2 : 10;
  } else {
    base = base === 2 ? 2 : 10;
    standard = base === 10 ? JEDEC : standard === JEDEC ? JEDEC : IEC;
  }
  const ceil = base === 10 ? 1e3 : 1024, full = fullform === true, neg = num < 0, roundingFunc = Math[roundingMethod];
  if (isNaN(arg)) {
    throw new TypeError(INVALID_NUMBER);
  }
  if (typeof roundingFunc !== FUNCTION) {
    throw new TypeError(INVALID_ROUND);
  }
  if (neg) {
    num = -num;
  }
  if (e2 === -1 || isNaN(e2)) {
    e2 = Math.floor(Math.log(num) / Math.log(ceil));
    if (e2 < 0) {
      e2 = 0;
    }
  }
  if (e2 > 8) {
    if (precision > 0) {
      precision += 8 - e2;
    }
    e2 = 8;
  }
  if (output === EXPONENT) {
    return e2;
  }
  if (num === 0) {
    result[0] = 0;
    u2 = result[1] = strings.symbol[standard][bits ? BITS : BYTES][e2];
  } else {
    val = num / (base === 2 ? Math.pow(2, e2 * 10) : Math.pow(1e3, e2));
    if (bits) {
      val = val * 8;
      if (val >= ceil && e2 < 8) {
        val = val / ceil;
        e2++;
      }
    }
    const p2 = Math.pow(10, e2 > 0 ? round2 : 0);
    result[0] = roundingFunc(val * p2) / p2;
    if (result[0] === ceil && e2 < 8 && exponent === -1) {
      result[0] = 1;
      e2++;
    }
    u2 = result[1] = base === 10 && e2 === 1 ? bits ? SI_KBIT : SI_KBYTE : strings.symbol[standard][bits ? BITS : BYTES][e2];
  }
  if (neg) {
    result[0] = -result[0];
  }
  if (precision > 0) {
    result[0] = result[0].toPrecision(precision);
  }
  result[1] = symbols[result[1]] || result[1];
  if (locale === true) {
    result[0] = result[0].toLocaleString();
  } else if (locale.length > 0) {
    result[0] = result[0].toLocaleString(locale, localeOptions);
  } else if (separator.length > 0) {
    result[0] = result[0].toString().replace(PERIOD, separator);
  }
  if (pad && Number.isInteger(result[0]) === false && round2 > 0) {
    const x3 = separator || PERIOD, tmp = result[0].toString().split(x3), s3 = tmp[1] || EMPTY2, l2 = s3.length, n3 = round2 - l2;
    result[0] = `${tmp[0]}${x3}${s3.padEnd(l2 + n3, ZERO)}`;
  }
  if (full) {
    result[1] = fullforms[e2] ? fullforms[e2] : strings.fullform[standard][e2] + (bits ? BIT : BYTE) + (result[0] === 1 ? EMPTY2 : S);
  }
  return output === ARRAY ? result : output === OBJECT ? {
    value: result[0],
    symbol: result[1],
    exponent: e2,
    unit: u2
  } : result.join(spacer);
}
filesize.partial = (opt) => (arg) => filesize(arg, opt);

// node_modules/sanity-plugin-media/dist/index.mjs
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard(), 1);

// node_modules/react-file-icon/dist/react-file-icon.esm.js
var import_react14 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());

// node_modules/colord/index.mjs
var r2 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
var t2 = function(r3) {
  return "string" == typeof r3 ? r3.length > 0 : "number" == typeof r3;
};
var n2 = function(r3, t3, n3) {
  return void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = Math.pow(10, t3)), Math.round(n3 * r3) / n3 + 0;
};
var e = function(r3, t3, n3) {
  return void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = 1), r3 > n3 ? n3 : r3 > t3 ? r3 : t3;
};
var u = function(r3) {
  return (r3 = isFinite(r3) ? r3 % 360 : 0) > 0 ? r3 : r3 + 360;
};
var a = function(r3) {
  return { r: e(r3.r, 0, 255), g: e(r3.g, 0, 255), b: e(r3.b, 0, 255), a: e(r3.a) };
};
var o2 = function(r3) {
  return { r: n2(r3.r), g: n2(r3.g), b: n2(r3.b), a: n2(r3.a, 3) };
};
var i2 = /^#([0-9a-f]{3,8})$/i;
var s2 = function(r3) {
  var t3 = r3.toString(16);
  return t3.length < 2 ? "0" + t3 : t3;
};
var h = function(r3) {
  var t3 = r3.r, n3 = r3.g, e2 = r3.b, u2 = r3.a, a2 = Math.max(t3, n3, e2), o3 = a2 - Math.min(t3, n3, e2), i3 = o3 ? a2 === t3 ? (n3 - e2) / o3 : a2 === n3 ? 2 + (e2 - t3) / o3 : 4 + (t3 - n3) / o3 : 0;
  return { h: 60 * (i3 < 0 ? i3 + 6 : i3), s: a2 ? o3 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
};
var b = function(r3) {
  var t3 = r3.h, n3 = r3.s, e2 = r3.v, u2 = r3.a;
  t3 = t3 / 360 * 6, n3 /= 100, e2 /= 100;
  var a2 = Math.floor(t3), o3 = e2 * (1 - n3), i3 = e2 * (1 - (t3 - a2) * n3), s3 = e2 * (1 - (1 - t3 + a2) * n3), h2 = a2 % 6;
  return { r: 255 * [e2, i3, o3, o3, s3, e2][h2], g: 255 * [s3, e2, e2, i3, o3, o3][h2], b: 255 * [o3, o3, s3, e2, e2, i3][h2], a: u2 };
};
var g = function(r3) {
  return { h: u(r3.h), s: e(r3.s, 0, 100), l: e(r3.l, 0, 100), a: e(r3.a) };
};
var d = function(r3) {
  return { h: n2(r3.h), s: n2(r3.s), l: n2(r3.l), a: n2(r3.a, 3) };
};
var f = function(r3) {
  return b((n3 = (t3 = r3).s, { h: t3.h, s: (n3 *= ((e2 = t3.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n3 / (e2 + n3) * 100 : 0, v: e2 + n3, a: t3.a }));
  var t3, n3, e2;
};
var c3 = function(r3) {
  return { h: (t3 = h(r3)).h, s: (u2 = (200 - (n3 = t3.s)) * (e2 = t3.v) / 100) > 0 && u2 < 200 ? n3 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t3.a };
  var t3, n3, e2, u2;
};
var l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var y = { string: [[function(r3) {
  var t3 = i2.exec(r3);
  return t3 ? (r3 = t3[1]).length <= 4 ? { r: parseInt(r3[0] + r3[0], 16), g: parseInt(r3[1] + r3[1], 16), b: parseInt(r3[2] + r3[2], 16), a: 4 === r3.length ? n2(parseInt(r3[3] + r3[3], 16) / 255, 2) : 1 } : 6 === r3.length || 8 === r3.length ? { r: parseInt(r3.substr(0, 2), 16), g: parseInt(r3.substr(2, 2), 16), b: parseInt(r3.substr(4, 2), 16), a: 8 === r3.length ? n2(parseInt(r3.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r3) {
  var t3 = v.exec(r3) || m.exec(r3);
  return t3 ? t3[2] !== t3[4] || t3[4] !== t3[6] ? null : a({ r: Number(t3[1]) / (t3[2] ? 100 / 255 : 1), g: Number(t3[3]) / (t3[4] ? 100 / 255 : 1), b: Number(t3[5]) / (t3[6] ? 100 / 255 : 1), a: void 0 === t3[7] ? 1 : Number(t3[7]) / (t3[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t3) {
  var n3 = l.exec(t3) || p.exec(t3);
  if (!n3) return null;
  var e2, u2, a2 = g({ h: (e2 = n3[1], u2 = n3[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r2[u2] || 1)), s: Number(n3[3]), l: Number(n3[4]), a: void 0 === n3[5] ? 1 : Number(n3[5]) / (n3[6] ? 100 : 1) });
  return f(a2);
}, "hsl"]], object: [[function(r3) {
  var n3 = r3.r, e2 = r3.g, u2 = r3.b, o3 = r3.a, i3 = void 0 === o3 ? 1 : o3;
  return t2(n3) && t2(e2) && t2(u2) ? a({ r: Number(n3), g: Number(e2), b: Number(u2), a: Number(i3) }) : null;
}, "rgb"], [function(r3) {
  var n3 = r3.h, e2 = r3.s, u2 = r3.l, a2 = r3.a, o3 = void 0 === a2 ? 1 : a2;
  if (!t2(n3) || !t2(e2) || !t2(u2)) return null;
  var i3 = g({ h: Number(n3), s: Number(e2), l: Number(u2), a: Number(o3) });
  return f(i3);
}, "hsl"], [function(r3) {
  var n3 = r3.h, a2 = r3.s, o3 = r3.v, i3 = r3.a, s3 = void 0 === i3 ? 1 : i3;
  if (!t2(n3) || !t2(a2) || !t2(o3)) return null;
  var h2 = (function(r4) {
    return { h: u(r4.h), s: e(r4.s, 0, 100), v: e(r4.v, 0, 100), a: e(r4.a) };
  })({ h: Number(n3), s: Number(a2), v: Number(o3), a: Number(s3) });
  return b(h2);
}, "hsv"]] };
var N2 = function(r3, t3) {
  for (var n3 = 0; n3 < t3.length; n3++) {
    var e2 = t3[n3][0](r3);
    if (e2) return [e2, t3[n3][1]];
  }
  return [null, void 0];
};
var x2 = function(r3) {
  return "string" == typeof r3 ? N2(r3.trim(), y.string) : "object" == typeof r3 && null !== r3 ? N2(r3, y.object) : [null, void 0];
};
var M2 = function(r3, t3) {
  var n3 = c3(r3);
  return { h: n3.h, s: e(n3.s + 100 * t3, 0, 100), l: n3.l, a: n3.a };
};
var H2 = function(r3) {
  return (299 * r3.r + 587 * r3.g + 114 * r3.b) / 1e3 / 255;
};
var $2 = function(r3, t3) {
  var n3 = c3(r3);
  return { h: n3.h, s: n3.s, l: e(n3.l + 100 * t3, 0, 100), a: n3.a };
};
var j2 = (function() {
  function r3(r4) {
    this.parsed = x2(r4)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r3.prototype.isValid = function() {
    return null !== this.parsed;
  }, r3.prototype.brightness = function() {
    return n2(H2(this.rgba), 2);
  }, r3.prototype.isDark = function() {
    return H2(this.rgba) < 0.5;
  }, r3.prototype.isLight = function() {
    return H2(this.rgba) >= 0.5;
  }, r3.prototype.toHex = function() {
    return r4 = o2(this.rgba), t3 = r4.r, e2 = r4.g, u2 = r4.b, i3 = (a2 = r4.a) < 1 ? s2(n2(255 * a2)) : "", "#" + s2(t3) + s2(e2) + s2(u2) + i3;
    var r4, t3, e2, u2, a2, i3;
  }, r3.prototype.toRgb = function() {
    return o2(this.rgba);
  }, r3.prototype.toRgbString = function() {
    return r4 = o2(this.rgba), t3 = r4.r, n3 = r4.g, e2 = r4.b, (u2 = r4.a) < 1 ? "rgba(" + t3 + ", " + n3 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t3 + ", " + n3 + ", " + e2 + ")";
    var r4, t3, n3, e2, u2;
  }, r3.prototype.toHsl = function() {
    return d(c3(this.rgba));
  }, r3.prototype.toHslString = function() {
    return r4 = d(c3(this.rgba)), t3 = r4.h, n3 = r4.s, e2 = r4.l, (u2 = r4.a) < 1 ? "hsla(" + t3 + ", " + n3 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t3 + ", " + n3 + "%, " + e2 + "%)";
    var r4, t3, n3, e2, u2;
  }, r3.prototype.toHsv = function() {
    return r4 = h(this.rgba), { h: n2(r4.h), s: n2(r4.s), v: n2(r4.v), a: n2(r4.a, 3) };
    var r4;
  }, r3.prototype.invert = function() {
    return w2({ r: 255 - (r4 = this.rgba).r, g: 255 - r4.g, b: 255 - r4.b, a: r4.a });
    var r4;
  }, r3.prototype.saturate = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w2(M2(this.rgba, r4));
  }, r3.prototype.desaturate = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w2(M2(this.rgba, -r4));
  }, r3.prototype.grayscale = function() {
    return w2(M2(this.rgba, -1));
  }, r3.prototype.lighten = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w2($2(this.rgba, r4));
  }, r3.prototype.darken = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w2($2(this.rgba, -r4));
  }, r3.prototype.rotate = function(r4) {
    return void 0 === r4 && (r4 = 15), this.hue(this.hue() + r4);
  }, r3.prototype.alpha = function(r4) {
    return "number" == typeof r4 ? w2({ r: (t3 = this.rgba).r, g: t3.g, b: t3.b, a: r4 }) : n2(this.rgba.a, 3);
    var t3;
  }, r3.prototype.hue = function(r4) {
    var t3 = c3(this.rgba);
    return "number" == typeof r4 ? w2({ h: r4, s: t3.s, l: t3.l, a: t3.a }) : n2(t3.h);
  }, r3.prototype.isEqual = function(r4) {
    return this.toHex() === w2(r4).toHex();
  }, r3;
})();
var w2 = function(r3) {
  return r3 instanceof j2 ? r3 : new j2(r3);
};
var S2 = [];
var k = function(r3) {
  r3.forEach(function(r4) {
    S2.indexOf(r4) < 0 && (r4(j2, y), S2.push(r4));
  });
};

// node_modules/colord/plugins/names.mjs
function names_default(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r3 = {};
  for (var d2 in a2) r3[a2[d2]] = d2;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var d3, i3, n3 = r3[this.toHex()];
    if (n3) return n3;
    if (null == f3 ? void 0 : f3.closest) {
      var o3 = this.toRgb(), t3 = 1 / 0, b2 = "black";
      if (!l2.length) for (var c4 in a2) l2[c4] = new e2(a2[c4]).toRgb();
      for (var g2 in a2) {
        var u2 = (d3 = o3, i3 = l2[g2], Math.pow(d3.r - i3.r, 2) + Math.pow(d3.g - i3.g, 2) + Math.pow(d3.b - i3.b, 2));
        u2 < t3 && (t3 = u2, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r4 = f3.toLowerCase(), d3 = "transparent" === r4 ? "#0000" : a2[r4];
    return d3 ? new e2(d3).toRgb() : null;
  }, "name"]);
}

// node_modules/react-file-icon/dist/react-file-icon.esm.js
var glyphs = {
  "3d": import_react14.default.createElement("path", {
    d: "M18 14.625V3.375L9 0 0 3.375v11.25L9 18l9-3.375zM9 2.136l5.918 2.22-5.98 2.242-5.919-2.22L9 2.137zM2 13.239V5.065l6.438 2.414v8.174L2 13.24zM9.438 15.7L16 13.239V5.018l-6.563 2.46V15.7z",
    transform: "translate(15 10)",
    fillRule: "evenodd"
  }),
  acrobat: import_react14.default.createElement("path", {
    d: "M10.15 1.095C9.938.33 9.42-.051 8.984.005c-.528.068-1.09.382-1.314.876-.63 1.416.685 5.582.887 6.279-1.28 3.863-5.66 11.5-7.806 12.017-.045-.505.225-1.965 3.055-3.785.146-.157.315-.348.393-.472-2.392 1.168-5.492 3.044-3.628 4.448.102.079.259.146.439.213 1.426.528 3.425-1.201 5.435-5.121 2.213-.73 3.999-1.28 6.526-1.662 2.762 1.875 4.616 2.257 5.874 1.774.348-.135.898-.573 1.055-1.145-1.022 1.258-3.414.382-5.323-.82 1.763-.191 3.582-.303 4.369-.056 1 .314.965.808.954.876.079-.27.191-.708-.022-1.056-.842-1.37-4.706-.573-6.11-.427-2.212-1.336-3.74-3.717-4.358-5.436.573-2.212 1.19-3.818.742-5.413zm-.954 4.638C8.826 4.42 8.309 1.5 9.14.556c1.628.932.618 3.144.056 5.177zm3.044 6.514c-2.134.393-3.583.944-5.66 1.764.617-1.202 1.785-4.268 2.346-6.29.787 1.573 1.741 3.111 3.314 4.526z",
    transform: "translate(14 9)",
    fillRule: "evenodd"
  }),
  android: import_react14.default.createElement("path", {
    d: "M17.6,9.48l1.84-3.18c0.16-0.31,0.04-0.69-0.26-0.85c-0.29-0.15-0.65-0.06-0.83,0.22l-1.88,3.24 c-2.86-1.21-6.08-1.21-8.94,0L5.65,5.67c-0.19-0.29-0.58-0.38-0.87-0.2C4.5,5.65,4.41,6.01,4.56,6.3L6.4,9.48 C3.3,11.25,1.28,14.44,1,18h22C22.72,14.44,20.7,11.25,17.6,9.48z M7,15.25c-0.69,0-1.25-0.56-1.25-1.25 c0-0.69,0.56-1.25,1.25-1.25S8.25,13.31,8.25,14C8.25,14.69,7.69,15.25,7,15.25z M17,15.25c-0.69,0-1.25-0.56-1.25-1.25 c0-0.69,0.56-1.25,1.25-1.25s1.25,0.56,1.25,1.25C18.25,14.69,17.69,15.25,17,15.25z",
    transform: "translate(12 8)"
  }),
  audio: import_react14.default.createElement("path", {
    d: "M.25 4.75v4.5h3L7 13V1L3.25 4.75h-3zM10.375 7A3.375 3.375 0 0 0 8.5 3.977v6.037A3.355 3.355 0 0 0 10.375 7zM8.5.421v1.545A5.254 5.254 0 0 1 12.25 7a5.254 5.254 0 0 1-3.75 5.032v1.545A6.747 6.747 0 0 0 13.75 7 6.747 6.747 0 0 0 8.5.421z",
    transform: "translate(17 12)",
    fillRule: "evenodd"
  }),
  binary: import_react14.default.createElement("path", {
    d: "M2.338 6.112c1.192 0 1.928-1.072 1.928-2.68 0-1.56-.576-2.504-1.8-2.504C1.274.928.538 2 .538 3.608c0 1.56.576 2.504 1.8 2.504zM1.61 3.408c0-1.008.24-1.568.776-1.568.376 0 .616.336.728.888l-1.504.776v-.096zM2.418 5.2c-.368 0-.608-.32-.72-.856l1.496-.768v.056c0 1.008-.24 1.568-.776 1.568zm7.03.8l.088-.944H8.36V.896L7.272.984v.592l-1.184.112.024.824h1.16v2.544h-1.32V6zm5.199 0l.088-.944h-1.176V.896L12.47.984v.592l-1.184.112.024.824h1.16v2.544h-1.32V6zM4.25 14l.088-.944H3.162v-4.16l-1.088.088v.592L.89 9.688l.024.824h1.16v2.544H.754V14zm5.198 0l.088-.944H8.36v-4.16l-1.088.088v.592l-1.184.112.024.824h1.16v2.544h-1.32V14zm3.287.112c1.192 0 1.928-1.072 1.928-2.68 0-1.56-.576-2.504-1.8-2.504-1.192 0-1.928 1.072-1.928 2.68 0 1.56.576 2.504 1.8 2.504zm-.728-2.704c0-1.008.24-1.568.776-1.568.376 0 .616.336.728.888l-1.504.776v-.096zm.808 1.792c-.368 0-.608-.32-.72-.856l1.496-.768v.056c0 1.008-.24 1.568-.776 1.568z",
    transform: "translate(16 11)",
    fillRule: "evenodd"
  }),
  code: import_react14.default.createElement("path", {
    d: "M4.078 13.67c-1.875-.527-2.812-1.738-2.812-3.634V9.49C1.266 8.437.844 7.911 0 7.911V6.138c.844 0 1.266-.529 1.266-1.586v-.64c.015-.938.257-1.696.726-2.274C2.466 1.06 3.162.64 4.078.38l.492 1.375c-.656.25-.997.95-1.023 2.102v.695c0 1.167-.482 1.99-1.445 2.469.963.479 1.445 1.304 1.445 2.476v.688c.026 1.15.367 1.851 1.023 2.101l-.492 1.383zm7.844 0c1.875-.527 2.812-1.738 2.812-3.634V9.49c0-1.052.422-1.578 1.266-1.578V6.138c-.844 0-1.266-.529-1.266-1.586v-.64c-.015-.938-.257-1.696-.726-2.274-.474-.578-1.17-.998-2.086-1.258l-.492 1.375c.656.25.997.95 1.023 2.102v.695c0 1.167.482 1.99 1.445 2.469-.963.479-1.445 1.304-1.445 2.476v.688c-.026 1.15-.367 1.851-1.023 2.101l.492 1.383z",
    transform: "translate(16 13)",
    fillRule: "evenodd"
  }),
  code2: import_react14.default.createElement("path", {
    d: "M7.4 10.6L2.8 6l4.6-4.6L6 0 0 6l6 6 1.4-1.4zm5.2 0L17.2 6l-4.6-4.6L14 0l6 6-6 6-1.4-1.4z",
    transform: "translate(14 14)",
    fillRule: "evenodd"
  }),
  compressed: import_react14.default.createElement("path", {
    d: "M.25 0A.25.25 0 0 0 0 .25v1.5c0 .138.112.25.25.25h1.5A.25.25 0 0 0 2 1.75V.25A.25.25 0 0 0 1.75 0H.25zM1 17a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1H1zm0 4v3h2v-3H1zM2 2.25A.25.25 0 0 1 2.25 2h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5A.25.25 0 0 1 2 3.75v-1.5zM.25 4a.25.25 0 0 0-.25.25v1.5c0 .138.112.25.25.25h1.5A.25.25 0 0 0 2 5.75v-1.5A.25.25 0 0 0 1.75 4H.25zM2 6.25A.25.25 0 0 1 2.25 6h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5A.25.25 0 0 1 2 7.75v-1.5zM.25 8a.25.25 0 0 0-.25.25v1.5c0 .138.112.25.25.25h1.5A.25.25 0 0 0 2 9.75v-1.5A.25.25 0 0 0 1.75 8H.25zM2 10.25a.25.25 0 0 1 .25-.25h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5a.25.25 0 0 1-.25-.25v-1.5zM.25 12a.25.25 0 0 0-.25.25v1.5c0 .138.112.25.25.25h1.5a.25.25 0 0 0 .25-.25v-1.5a.25.25 0 0 0-.25-.25H.25zM2 14.25a.25.25 0 0 1 .25-.25h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5a.25.25 0 0 1-.25-.25v-1.5z",
    transform: "translate(15 1)",
    fillRule: "evenodd"
  }),
  document: import_react14.default.createElement("path", {
    d: "M12 4H0v2h12V4zM0 10h18V8H0v2zM0 0v2h18V0H0z",
    transform: "translate(15 15)",
    fillRule: "evenodd"
  }),
  drive: import_react14.default.createElement("path", {
    d: "M2.199.289A.5.5 0 0 1 2.652 0h8.696a.5.5 0 0 1 .453.289l1.867 4a.5.5 0 0 1-.453.711H.785a.5.5 0 0 1-.453-.711l1.867-4zM13 6H1a.752.752 0 0 0-.75.75v4.5c0 .412.338.75.75.75h12c.412 0 .75-.338.75-.75v-4.5A.752.752 0 0 0 13 6zm-9.75 4.5c-.825 0-1.5-.675-1.5-1.5s.675-1.5 1.5-1.5 1.5.675 1.5 1.5-.675 1.5-1.5 1.5z",
    transform: "translate(17 13)",
    fillRule: "evenodd"
  }),
  font: import_react14.default.createElement("path", {
    d: "M3.722 8.702l-.686 1.89c-.053.14-.094.28-.123.421-.03.135-.044.252-.044.352 0 .304.097.527.29.668.2.14.501.21.905.21h.414V13H.083v-.756h.343c.176 0 .325-.018.448-.053a.81.81 0 0 0 .334-.22c.1-.105.193-.249.281-.43.094-.182.197-.416.308-.704L5.787.15h1.406l4.07 11.136c.07.187.14.343.21.466.077.123.165.222.264.298.1.07.214.12.343.15.129.03.281.044.457.044h.237V13H7.826v-.756h.413c.72 0 1.081-.287 1.081-.862 0-.1-.014-.202-.044-.307a3.274 3.274 0 0 0-.105-.36l-.72-2.013H3.72zM7.009 4.65c-.188-.533-.36-1.031-.519-1.494a15.92 15.92 0 0 1-.378-1.354 7.12 7.12 0 0 1-.15.633 16.95 16.95 0 0 1-.395 1.283c-.082.229-.175.484-.28.765L4.063 7.796h4.061L7.009 4.65zm8.411 5.74c0 .562.117.984.351 1.265.24.275.61.413 1.108.413.363 0 .691-.059.984-.176.3-.117.551-.284.756-.5.211-.218.372-.481.483-.792.112-.31.168-.656.168-1.037V8.104l-1.152.053c-.51.023-.937.088-1.283.193-.34.1-.615.243-.826.43a1.546 1.546 0 0 0-.457.678c-.088.27-.132.58-.132.931zm2.18-6.32c-.346 0-.627.05-.844.15a1.182 1.182 0 0 0-.501.404 1.594 1.594 0 0 0-.237.624c-.041.24-.062.5-.062.782-.498 0-.879-.085-1.143-.255-.257-.17-.386-.463-.386-.879 0-.31.085-.574.255-.79.17-.218.401-.393.694-.528.299-.14.644-.243 1.037-.308a7.76 7.76 0 0 1 1.257-.097c.55 0 1.031.056 1.441.167.41.106.753.282 1.029.528.275.246.48.568.615.967.14.392.21.876.21 1.45v4.667c0 .252.021.46.062.624a.928.928 0 0 0 .194.395c.088.1.202.17.343.211.146.041.319.062.518.062h.053V13H19.7l-.281-1.547h-.15c-.187.252-.369.483-.544.694-.176.211-.37.393-.58.545-.211.152-.452.27-.721.352a3.053 3.053 0 0 1-.958.131c-.399 0-.77-.058-1.116-.175a2.369 2.369 0 0 1-.888-.519 2.516 2.516 0 0 1-.58-.896c-.14-.364-.211-.791-.211-1.284 0-.955.34-1.664 1.02-2.127.68-.462 1.707-.714 3.084-.755l1.495-.053V6.285a6.93 6.93 0 0 0-.053-.888 1.778 1.778 0 0 0-.229-.703 1.14 1.14 0 0 0-.51-.457c-.216-.111-.51-.167-.878-.167z",
    transform: "translate(13 12)",
    fillRule: "evenodd"
  }),
  image: import_react14.default.createElement("path", {
    d: "M13 0L9.25 5l2.85 3.8-1.6 1.2C8.81 7.75 6 4 6 4l-6 8h22L13 0z",
    transform: "translate(13 14)",
    fillRule: "evenodd"
  }),
  presentation: import_react14.default.createElement("path", {
    d: "M2 4H0v10c0 1.1.9 2 2 2h14v-2H2V4zm16-4H6C4.9 0 4 .9 4 2v8c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V2c0-1.1-.9-2-2-2zm0 10H6V2h12v8z",
    transform: "matrix(-1 0 0 1 34 12)",
    fillRule: "evenodd"
  }),
  settings: import_react14.default.createElement("path", {
    d: "M13.572 8.735c.03-.24.053-.48.053-.735s-.023-.495-.053-.735l1.583-1.237a.378.378 0 0 0 .09-.48l-1.5-2.595a.377.377 0 0 0-.457-.165l-1.868.75a5.48 5.48 0 0 0-1.268-.735L9.868.815A.366.366 0 0 0 9.5.5h-3a.366.366 0 0 0-.367.315l-.285 1.988a5.762 5.762 0 0 0-1.268.735l-1.868-.75a.366.366 0 0 0-.457.165l-1.5 2.595a.37.37 0 0 0 .09.48l1.583 1.237c-.03.24-.053.488-.053.735 0 .248.022.495.053.735L.845 9.973a.378.378 0 0 0-.09.48l1.5 2.595c.09.165.292.225.458.165l1.867-.75c.39.3.81.547 1.268.735l.285 1.987c.022.18.18.315.367.315h3a.366.366 0 0 0 .367-.315l.285-1.988a5.762 5.762 0 0 0 1.268-.734l1.867.75c.173.067.368 0 .458-.165l1.5-2.595a.378.378 0 0 0-.09-.48l-1.582-1.238zM8 10.625A2.628 2.628 0 0 1 5.375 8 2.628 2.628 0 0 1 8 5.375 2.628 2.628 0 0 1 10.625 8 2.628 2.628 0 0 1 8 10.625z",
    transform: "translate(16 11)",
    fillRule: "evenodd"
  }),
  spreadsheet: import_react14.default.createElement("path", {
    d: "M0 8h6V5H0v3zm0 5h6v-3H0v3zM0 3h6V0H0v3zm8 5h12V5H8v3zm0 5h12v-3H8v3zM8 0v3h12V0H8z",
    transform: "translate(14 14)",
    fillRule: "evenodd"
  }),
  vector: import_react14.default.createElement("path", {
    d: "M14.5 2V1a1 1 0 0 0-1-1h-3a1 1 0 0 0-1 1v1H3.937a2 2 0 1 0 0 1h3.936A9 9 0 0 0 3 11v1h2v-1a7.003 7.003 0 0 1 4.594-6.576A1 1 0 0 0 10.5 5h3a1 1 0 0 0 .906-.576A7.003 7.003 0 0 1 19 11v1h2v-1a9 9 0 0 0-4.873-8h3.936a2 2 0 1 0 0-1H14.5zm-1-1h-3v3h3V1zM2 1.5a1 1 0 1 0 0 2 1 1 0 0 0 0-2zm19 1a1 1 0 1 0 2 0 1 1 0 0 0-2 0z",
    transform: "translate(12 14)",
    fillRule: "evenodd"
  }),
  video: import_react14.default.createElement("path", {
    d: "M10.75 3.875V1.25A.752.752 0 0 0 10 .5H1a.752.752 0 0 0-.75.75v7.5c0 .412.338.75.75.75h9c.412 0 .75-.338.75-.75V6.125l3 3V.875l-3 3z",
    transform: "translate(17 14)"
  })
};
k([names_default]);
var propTypes = {
  /** Color of icon background */
  color: import_prop_types.default.string,
  /** Text to display in label */
  extension: import_prop_types.default.string,
  /** Displays the corner fold */
  fold: import_prop_types.default.bool,
  /** Color of the corner fold */
  foldColor: import_prop_types.default.string,
  /** Color of file type icon */
  glyphColor: import_prop_types.default.string,
  /** Color of page gradient */
  gradientColor: import_prop_types.default.string,
  /** Opacity of page gradient */
  gradientOpacity: import_prop_types.default.number,
  /** Color of label */
  labelColor: import_prop_types.default.string,
  /** Color of label text */
  labelTextColor: import_prop_types.default.string,
  /** Displays the label in all caps */
  labelUppercase: import_prop_types.default.bool,
  /** Corner radius of the file icon */
  radius: import_prop_types.default.number,
  /** Type of glyph icon to display */
  type: import_prop_types.default.oneOf(["3d", "acrobat", "android", "audio", "binary", "code", "code2", "compressed", "document", "drive", "font", "image", "presentation", "settings", "spreadsheet", "vector", "video"])
};
var VIEWBOX = {
  WIDTH: 40,
  HEIGHT: 48
};
var ICON = {
  WIDTH: VIEWBOX.WIDTH,
  HEIGHT: VIEWBOX.HEIGHT,
  X_OFFSET: 0
};
var FOLD = {
  HEIGHT: 12
};
var LABEL_HEIGHT = 14;
var useId3 = import_react14.default.useId || /* @__PURE__ */ (function() {
  var i3 = 0;
  return function() {
    return i3++;
  };
})();
var FileIcon = function FileIcon2(_ref3) {
  var _ref$color = _ref3.color, color2 = _ref$color === void 0 ? "whitesmoke" : _ref$color, extension = _ref3.extension, _ref$fold = _ref3.fold, fold = _ref$fold === void 0 ? true : _ref$fold, foldColor = _ref3.foldColor, glyphColor = _ref3.glyphColor, _ref$gradientColor = _ref3.gradientColor, gradientColor = _ref$gradientColor === void 0 ? "white" : _ref$gradientColor, _ref$gradientOpacity = _ref3.gradientOpacity, gradientOpacity = _ref$gradientOpacity === void 0 ? 0.25 : _ref$gradientOpacity, labelColor = _ref3.labelColor, _ref$labelTextColor = _ref3.labelTextColor, labelTextColor = _ref$labelTextColor === void 0 ? "white" : _ref$labelTextColor, _ref$labelUppercase = _ref3.labelUppercase, labelUppercase = _ref$labelUppercase === void 0 ? false : _ref$labelUppercase, _ref$radius = _ref3.radius, radius = _ref$radius === void 0 ? 4 : _ref$radius, type = _ref3.type;
  var id = useId3();
  var UNIQUE_ID = typeof jest === "undefined" ? id : "";
  return import_react14.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 " + VIEWBOX.WIDTH + " " + VIEWBOX.HEIGHT,
    width: "100%",
    style: {
      maxWidth: "100%"
    }
  }, import_react14.default.createElement("defs", null, import_react14.default.createElement("clipPath", {
    id: "pageRadius" + UNIQUE_ID
  }, import_react14.default.createElement("rect", {
    x: ICON.X_OFFSET,
    y: "0",
    rx: radius,
    ry: radius,
    width: ICON.WIDTH,
    height: ICON.HEIGHT
  })), import_react14.default.createElement("clipPath", {
    id: "foldCrop" + UNIQUE_ID
  }, import_react14.default.createElement("rect", {
    width: ICON.WIDTH,
    height: FOLD.HEIGHT,
    transform: "rotate(-45 0 " + FOLD.HEIGHT + ")"
  })), import_react14.default.createElement("linearGradient", {
    x1: "100%",
    y1: "0%",
    y2: "100%",
    id: "pageGradient" + UNIQUE_ID
  }, import_react14.default.createElement("stop", {
    stopColor: gradientColor,
    stopOpacity: gradientOpacity,
    offset: "0%"
  }), import_react14.default.createElement("stop", {
    stopColor: gradientColor,
    stopOpacity: "0",
    offset: "66.67%"
  }))), import_react14.default.createElement("g", {
    id: "file",
    clipPath: "url(#pageRadius" + UNIQUE_ID + ")"
  }, fold ? import_react14.default.createElement(import_react14.default.Fragment, null, import_react14.default.createElement("path", {
    d: "M" + ICON.X_OFFSET + " 0 h " + (ICON.WIDTH - FOLD.HEIGHT) + " L " + (ICON.WIDTH + ICON.X_OFFSET) + " " + FOLD.HEIGHT + " v " + (ICON.HEIGHT - FOLD.HEIGHT) + " H " + ICON.X_OFFSET + " Z",
    fill: color2
  }), import_react14.default.createElement("path", {
    d: "M" + ICON.X_OFFSET + " 0 h " + (ICON.WIDTH - FOLD.HEIGHT) + " L " + (ICON.WIDTH + ICON.X_OFFSET) + " " + FOLD.HEIGHT + " v " + (ICON.HEIGHT - FOLD.HEIGHT) + " H " + ICON.X_OFFSET + " Z",
    fill: "url(#pageGradient" + UNIQUE_ID + ")"
  })) : import_react14.default.createElement(import_react14.default.Fragment, null, import_react14.default.createElement("rect", {
    x: ICON.X_OFFSET,
    y: "0",
    width: ICON.WIDTH,
    height: ICON.HEIGHT,
    fill: color2
  }), import_react14.default.createElement("rect", {
    x: ICON.X_OFFSET,
    y: "0",
    width: ICON.WIDTH,
    height: ICON.HEIGHT,
    fill: "url(#pageGradient" + UNIQUE_ID + ")"
  }))), fold && import_react14.default.createElement("g", {
    transform: "translate(28 " + FOLD.HEIGHT + ") rotate(-90)"
  }, import_react14.default.createElement("rect", {
    width: ICON.WIDTH,
    height: ICON.HEIGHT,
    fill: foldColor || w2(color2).darken(0.1).toHex(),
    rx: radius,
    ry: radius,
    clipPath: "url(#foldCrop" + UNIQUE_ID + ")"
  })), extension && import_react14.default.createElement(import_react14.default.Fragment, null, import_react14.default.createElement("g", {
    id: "label" + UNIQUE_ID
  }, import_react14.default.createElement("rect", {
    fill: labelColor || w2(color2).darken(0.3).toHex(),
    x: ICON.X_OFFSET,
    y: ICON.HEIGHT - LABEL_HEIGHT,
    width: ICON.WIDTH,
    height: LABEL_HEIGHT,
    clipPath: "url(#pageRadius" + UNIQUE_ID + ")"
  })), import_react14.default.createElement("g", {
    id: "labelText" + UNIQUE_ID,
    transform: "translate(" + ICON.X_OFFSET + " 34)"
  }, import_react14.default.createElement("text", {
    x: ICON.WIDTH / 2,
    y: "10",
    fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif",
    fontSize: "9",
    fill: labelTextColor,
    textAnchor: "middle",
    style: {
      fontWeight: "bold",
      textAlign: "center",
      pointerEvents: "none",
      textTransform: labelUppercase ? "uppercase" : "none",
      userSelect: "none"
    }
  }, extension))), type && import_react14.default.createElement("g", {
    transform: "translate(-4 " + (!extension ? 6 : 0) + ")",
    fill: glyphColor || w2(color2).darken(0.15).toHex()
  }, glyphs[type]));
};
FileIcon.propTypes = propTypes;
var defaultStyles2 = {
  "3dm": {
    labelColor: "#8D1A11",
    type: "3d"
  },
  "3ds": {
    labelColor: "#5FB9AD",
    type: "3d"
  },
  "3g2": {
    type: "video"
  },
  "3gp": {
    type: "video"
  },
  "7zip": {
    type: "compressed"
  },
  aab: {
    type: "android",
    labelColor: "#3DDC84"
  },
  aac: {
    type: "audio"
  },
  aep: {
    type: "video"
  },
  ai: {
    color: "#423325",
    gradientOpacity: 0,
    labelColor: "#423325",
    labelTextColor: "#FF7F18",
    labelUppercase: true,
    foldColor: "#FF7F18",
    radius: 2
  },
  aif: {
    type: "audio"
  },
  aiff: {
    type: "audio"
  },
  apk: {
    type: "android",
    labelColor: "#3DDC84"
  },
  apkm: {
    type: "android",
    labelColor: "#3DDC84"
  },
  apks: {
    type: "android",
    labelColor: "#3DDC84"
  },
  asf: {
    type: "video"
  },
  asp: {
    type: "code"
  },
  aspx: {
    type: "code"
  },
  avi: {
    type: "video"
  },
  bin: {
    type: "binary"
  },
  bmp: {
    type: "image"
  },
  c: {
    type: "code"
  },
  cpp: {
    type: "code"
  },
  cs: {
    type: "code"
  },
  css: {
    type: "code"
  },
  csv: {
    type: "spreadsheet"
  },
  cue: {
    type: "document"
  },
  dll: {
    type: "settings"
  },
  dmg: {
    type: "drive"
  },
  doc: {
    color: "#2C5898",
    foldColor: "#254A80",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#2C5898",
    labelUppercase: true,
    type: "document"
  },
  docx: {
    color: "#2C5898",
    foldColor: "#254A80",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#2C5898",
    labelUppercase: true,
    type: "document"
  },
  dwg: {
    type: "vector"
  },
  dxf: {
    type: "vector"
  },
  eot: {
    type: "font"
  },
  eps: {
    type: "vector"
  },
  exe: {
    type: "settings"
  },
  flac: {
    type: "audio"
  },
  flv: {
    type: "video"
  },
  fnt: {
    type: "font"
  },
  fodp: {
    type: "presentation"
  },
  fods: {
    type: "spreadsheet"
  },
  fodt: {
    type: "document"
  },
  fon: {
    type: "font"
  },
  gif: {
    type: "image"
  },
  gz: {
    type: "compressed"
  },
  heic: {
    type: "image"
  },
  htm: {
    type: "code"
  },
  html: {
    type: "code"
  },
  indd: {
    color: "#4B2B36",
    gradientOpacity: 0,
    labelColor: "#4B2B36",
    labelTextColor: "#FF408C",
    labelUppercase: true,
    foldColor: "#FF408C",
    radius: 2
  },
  ini: {
    type: "settings"
  },
  java: {
    type: "code"
  },
  jpeg: {
    type: "image"
  },
  jpg: {
    type: "image"
  },
  js: {
    labelColor: "#F7DF1E",
    type: "code"
  },
  json: {
    type: "code"
  },
  jsx: {
    labelColor: "#00D8FF",
    type: "code"
  },
  m4a: {
    type: "audio"
  },
  m4v: {
    type: "video"
  },
  max: {
    labelColor: "#5FB9AD",
    type: "3d"
  },
  md: {
    type: "document"
  },
  mid: {
    type: "audio"
  },
  mkv: {
    type: "video"
  },
  mov: {
    type: "video"
  },
  mp3: {
    type: "audio"
  },
  mp4: {
    type: "video"
  },
  mpeg: {
    type: "video"
  },
  mpg: {
    type: "video"
  },
  obj: {
    type: "3d"
  },
  odp: {
    type: "presentation"
  },
  ods: {
    type: "spreadsheet"
  },
  odt: {
    type: "document"
  },
  ogg: {
    type: "audio"
  },
  ogv: {
    type: "video"
  },
  otf: {
    type: "font"
  },
  pdf: {
    labelColor: "#D93831",
    type: "acrobat"
  },
  php: {
    labelColor: "#8892BE",
    type: "code"
  },
  pkg: {
    type: "3d"
  },
  plist: {
    type: "settings"
  },
  png: {
    type: "image"
  },
  ppt: {
    color: "#D14423",
    foldColor: "#AB381D",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#D14423",
    labelUppercase: true,
    type: "presentation"
  },
  pptx: {
    color: "#D14423",
    foldColor: "#AB381D",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#D14423",
    labelUppercase: true,
    type: "presentation"
  },
  pr: {
    type: "video"
  },
  ps: {
    type: "vector"
  },
  psd: {
    color: "#34364E",
    gradientOpacity: 0,
    labelColor: "#34364E",
    labelTextColor: "#31C5F0",
    labelUppercase: true,
    foldColor: "#31C5F0",
    radius: 2
  },
  py: {
    labelColor: "#FFDE57",
    type: "code"
  },
  rar: {
    type: "compressed"
  },
  rb: {
    labelColor: "#BB271A",
    type: "code"
  },
  rm: {
    type: "video"
  },
  rtf: {
    type: "document"
  },
  scss: {
    labelColor: "#C16A98",
    type: "code"
  },
  sitx: {
    type: "compressed"
  },
  skp: {
    type: "3d"
  },
  svg: {
    type: "vector"
  },
  swf: {
    type: "video"
  },
  sys: {
    type: "settings"
  },
  tar: {
    type: "compressed"
  },
  tex: {
    type: "document"
  },
  tif: {
    type: "image"
  },
  tiff: {
    type: "image"
  },
  ts: {
    labelColor: "#3478C7",
    type: "code"
  },
  ttf: {
    type: "font"
  },
  txt: {
    type: "document"
  },
  wav: {
    type: "audio"
  },
  webm: {
    type: "video"
  },
  wmv: {
    type: "video"
  },
  woff: {
    type: "font"
  },
  wpd: {
    type: "document"
  },
  wps: {
    type: "document"
  },
  xapk: {
    type: "android",
    labelColor: "#3DDC84"
  },
  xlr: {
    type: "spreadsheet"
  },
  xls: {
    color: "#1A754C",
    foldColor: "#16613F",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#1A754C",
    labelUppercase: true,
    type: "spreadsheet"
  },
  xlsx: {
    color: "#1A754C",
    foldColor: "#16613F",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#1A754C",
    labelUppercase: true,
    type: "spreadsheet"
  },
  yml: {
    type: "code"
  },
  zip: {
    type: "compressed"
  },
  zipx: {
    type: "compressed"
  }
};

// node_modules/react-select/creatable/dist/react-select-creatable.esm.js
var React10 = __toESM(require_react());
var import_react16 = __toESM(require_react());

// node_modules/react-select/dist/useCreatable-09aaeb9a.esm.js
var import_react15 = __toESM(require_react());
var _excluded5 = ["allowCreateWhileLoading", "createOptionPosition", "formatCreateLabel", "isValidNewOption", "getNewOptionData", "onCreateOption", "options", "onChange"];
var compareOption = function compareOption2() {
  var inputValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var option = arguments.length > 1 ? arguments[1] : void 0;
  var accessors = arguments.length > 2 ? arguments[2] : void 0;
  var candidate = String(inputValue).toLowerCase();
  var optionValue = String(accessors.getOptionValue(option)).toLowerCase();
  var optionLabel = String(accessors.getOptionLabel(option)).toLowerCase();
  return optionValue === candidate || optionLabel === candidate;
};
var builtins = {
  formatCreateLabel: function formatCreateLabel(inputValue) {
    return 'Create "'.concat(inputValue, '"');
  },
  isValidNewOption: function isValidNewOption(inputValue, selectValue, selectOptions, accessors) {
    return !(!inputValue || selectValue.some(function(option) {
      return compareOption(inputValue, option, accessors);
    }) || selectOptions.some(function(option) {
      return compareOption(inputValue, option, accessors);
    }));
  },
  getNewOptionData: function getNewOptionData(inputValue, optionLabel) {
    return {
      label: optionLabel,
      value: inputValue,
      __isNew__: true
    };
  }
};
function useCreatable(_ref3) {
  var _ref$allowCreateWhile = _ref3.allowCreateWhileLoading, allowCreateWhileLoading = _ref$allowCreateWhile === void 0 ? false : _ref$allowCreateWhile, _ref$createOptionPosi = _ref3.createOptionPosition, createOptionPosition = _ref$createOptionPosi === void 0 ? "last" : _ref$createOptionPosi, _ref$formatCreateLabe = _ref3.formatCreateLabel, formatCreateLabel2 = _ref$formatCreateLabe === void 0 ? builtins.formatCreateLabel : _ref$formatCreateLabe, _ref$isValidNewOption = _ref3.isValidNewOption, isValidNewOption2 = _ref$isValidNewOption === void 0 ? builtins.isValidNewOption : _ref$isValidNewOption, _ref$getNewOptionData = _ref3.getNewOptionData, getNewOptionData2 = _ref$getNewOptionData === void 0 ? builtins.getNewOptionData : _ref$getNewOptionData, onCreateOption = _ref3.onCreateOption, _ref$options = _ref3.options, propsOptions = _ref$options === void 0 ? [] : _ref$options, propsOnChange = _ref3.onChange, restSelectProps = _objectWithoutProperties(_ref3, _excluded5);
  var _restSelectProps$getO = restSelectProps.getOptionValue, getOptionValue$12 = _restSelectProps$getO === void 0 ? getOptionValue$1 : _restSelectProps$getO, _restSelectProps$getO2 = restSelectProps.getOptionLabel, getOptionLabel$12 = _restSelectProps$getO2 === void 0 ? getOptionLabel$1 : _restSelectProps$getO2, inputValue = restSelectProps.inputValue, isLoading = restSelectProps.isLoading, isMulti = restSelectProps.isMulti, value = restSelectProps.value, name = restSelectProps.name;
  var newOption = (0, import_react15.useMemo)(function() {
    return isValidNewOption2(inputValue, cleanValue(value), propsOptions, {
      getOptionValue: getOptionValue$12,
      getOptionLabel: getOptionLabel$12
    }) ? getNewOptionData2(inputValue, formatCreateLabel2(inputValue)) : void 0;
  }, [formatCreateLabel2, getNewOptionData2, getOptionLabel$12, getOptionValue$12, inputValue, isValidNewOption2, propsOptions, value]);
  var options2 = (0, import_react15.useMemo)(function() {
    return (allowCreateWhileLoading || !isLoading) && newOption ? createOptionPosition === "first" ? [newOption].concat(_toConsumableArray(propsOptions)) : [].concat(_toConsumableArray(propsOptions), [newOption]) : propsOptions;
  }, [allowCreateWhileLoading, createOptionPosition, isLoading, newOption, propsOptions]);
  var onChange2 = (0, import_react15.useCallback)(function(newValue, actionMeta) {
    if (actionMeta.action !== "select-option") {
      return propsOnChange(newValue, actionMeta);
    }
    var valueArray = Array.isArray(newValue) ? newValue : [newValue];
    if (valueArray[valueArray.length - 1] === newOption) {
      if (onCreateOption) onCreateOption(inputValue);
      else {
        var newOptionData = getNewOptionData2(inputValue, inputValue);
        var newActionMeta = {
          action: "create-option",
          name,
          option: newOptionData
        };
        propsOnChange(valueTernary(isMulti, [].concat(_toConsumableArray(cleanValue(value)), [newOptionData]), newOptionData), newActionMeta);
      }
      return;
    }
    propsOnChange(newValue, actionMeta);
  }, [getNewOptionData2, inputValue, isMulti, name, newOption, onCreateOption, propsOnChange, value]);
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    options: options2,
    onChange: onChange2
  });
}

// node_modules/react-select/creatable/dist/react-select-creatable.esm.js
var import_react_dom6 = __toESM(require_react_dom());
var CreatableSelect = (0, import_react16.forwardRef)(function(props, ref) {
  var creatableProps = useStateManager(props);
  var selectProps = useCreatable(creatableProps);
  return React10.createElement(Select2, _extends({
    ref
  }, selectProps));
});
var CreatableSelect$1 = CreatableSelect;

// node_modules/sanity-plugin-media/node_modules/date-fns/formatRelative.js
function formatRelative2(date, baseDate, options2) {
  const [date_, baseDate_] = normalizeDates(options2?.in, date, baseDate);
  const defaultOptions3 = getDefaultOptions();
  const locale = options2?.locale ?? defaultOptions3.locale ?? enUS;
  const weekStartsOn = options2?.weekStartsOn ?? options2?.locale?.options?.weekStartsOn ?? defaultOptions3.weekStartsOn ?? defaultOptions3.locale?.options?.weekStartsOn ?? 0;
  const diff = differenceInCalendarDays(date_, baseDate_);
  if (isNaN(diff)) {
    throw new RangeError("Invalid time value");
  }
  let token2;
  if (diff < -6) {
    token2 = "other";
  } else if (diff < -1) {
    token2 = "lastWeek";
  } else if (diff < 0) {
    token2 = "yesterday";
  } else if (diff < 1) {
    token2 = "today";
  } else if (diff < 2) {
    token2 = "tomorrow";
  } else if (diff < 7) {
    token2 = "nextWeek";
  } else {
    token2 = "other";
  }
  const formatStr = locale.formatRelative(token2, date_, baseDate_, {
    locale,
    weekStartsOn
  });
  return format(date_, formatStr, { locale, weekStartsOn });
}
var formatRelative_default = formatRelative2;

// node_modules/react-dropzone/dist/es/index.js
var import_react18 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/file-selector/dist/es5/file.js
var COMMON_MIME_TYPES = /* @__PURE__ */ new Map([
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  // Others
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function toFileWithPath(file, path) {
  var f2 = withMimeType(file);
  if (typeof f2.path !== "string") {
    var webkitRelativePath = file.webkitRelativePath;
    Object.defineProperty(f2, "path", {
      value: typeof path === "string" ? path : typeof webkitRelativePath === "string" && webkitRelativePath.length > 0 ? webkitRelativePath : file.name,
      writable: false,
      configurable: false,
      enumerable: true
    });
  }
  return f2;
}
function withMimeType(file) {
  var name = file.name;
  var hasExtension = name && name.lastIndexOf(".") !== -1;
  if (hasExtension && !file.type) {
    var ext = name.split(".").pop().toLowerCase();
    var type = COMMON_MIME_TYPES.get(ext);
    if (type) {
      Object.defineProperty(file, "type", {
        value: type,
        writable: false,
        configurable: false,
        enumerable: true
      });
    }
  }
  return file;
}

// node_modules/file-selector/dist/es5/file-selector.js
var FILES_TO_IGNORE = [
  // Thumbnail cache files for macOS and Windows
  ".DS_Store",
  "Thumbs.db"
  // Windows
];
function fromEvent(evt) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      if (isObject2(evt) && isDataTransfer(evt)) {
        return [2, getDataTransferFiles(evt.dataTransfer, evt.type)];
      } else if (isChangeEvt(evt)) {
        return [2, getInputFiles(evt)];
      } else if (Array.isArray(evt) && evt.every(function(item) {
        return "getFile" in item && typeof item.getFile === "function";
      })) {
        return [2, getFsHandleFiles(evt)];
      }
      return [2, []];
    });
  });
}
function isDataTransfer(value) {
  return isObject2(value.dataTransfer);
}
function isChangeEvt(value) {
  return isObject2(value) && isObject2(value.target);
}
function isObject2(v2) {
  return typeof v2 === "object" && v2 !== null;
}
function getInputFiles(evt) {
  return fromList(evt.target.files).map(function(file) {
    return toFileWithPath(file);
  });
}
function getFsHandleFiles(handles) {
  return __awaiter(this, void 0, void 0, function() {
    var files;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          return [4, Promise.all(handles.map(function(h2) {
            return h2.getFile();
          }))];
        case 1:
          files = _a.sent();
          return [2, files.map(function(file) {
            return toFileWithPath(file);
          })];
      }
    });
  });
}
function getDataTransferFiles(dt2, type) {
  return __awaiter(this, void 0, void 0, function() {
    var items, files;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          if (dt2 === null) {
            return [2, []];
          }
          if (!dt2.items) return [3, 2];
          items = fromList(dt2.items).filter(function(item) {
            return item.kind === "file";
          });
          if (type !== "drop") {
            return [2, items];
          }
          return [4, Promise.all(items.map(toFilePromises))];
        case 1:
          files = _a.sent();
          return [2, noIgnoredFiles(flatten(files))];
        case 2:
          return [2, noIgnoredFiles(fromList(dt2.files).map(function(file) {
            return toFileWithPath(file);
          }))];
      }
    });
  });
}
function noIgnoredFiles(files) {
  return files.filter(function(file) {
    return FILES_TO_IGNORE.indexOf(file.name) === -1;
  });
}
function fromList(items) {
  if (items === null) {
    return [];
  }
  var files = [];
  for (var i3 = 0; i3 < items.length; i3++) {
    var file = items[i3];
    files.push(file);
  }
  return files;
}
function toFilePromises(item) {
  if (typeof item.webkitGetAsEntry !== "function") {
    return fromDataTransferItem(item);
  }
  var entry = item.webkitGetAsEntry();
  if (entry && entry.isDirectory) {
    return fromDirEntry(entry);
  }
  return fromDataTransferItem(item);
}
function flatten(items) {
  return items.reduce(function(acc, files) {
    return __spread(acc, Array.isArray(files) ? flatten(files) : [files]);
  }, []);
}
function fromDataTransferItem(item) {
  var file = item.getAsFile();
  if (!file) {
    return Promise.reject(item + " is not a File");
  }
  var fwp = toFileWithPath(file);
  return Promise.resolve(fwp);
}
function fromEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, entry.isDirectory ? fromDirEntry(entry) : fromFileEntry(entry)];
    });
  });
}
function fromDirEntry(entry) {
  var reader = entry.createReader();
  return new Promise(function(resolve, reject) {
    var entries = [];
    function readEntries() {
      var _this = this;
      reader.readEntries(function(batch) {
        return __awaiter(_this, void 0, void 0, function() {
          var files, err_1, items;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!!batch.length) return [3, 5];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, Promise.all(entries)];
              case 2:
                files = _a.sent();
                resolve(files);
                return [3, 4];
              case 3:
                err_1 = _a.sent();
                reject(err_1);
                return [3, 4];
              case 4:
                return [3, 6];
              case 5:
                items = Promise.all(batch.map(fromEntry));
                entries.push(items);
                readEntries();
                _a.label = 6;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, function(err) {
        reject(err);
      });
    }
    readEntries();
  });
}
function fromFileEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, new Promise(function(resolve, reject) {
        entry.file(function(file) {
          var fwp = toFileWithPath(file, entry.fullPath);
          resolve(fwp);
        }, function(err) {
          reject(err);
        });
      })];
    });
  });
}

// node_modules/react-dropzone/dist/es/utils/index.js
var import_attr_accept = __toESM(require_es());
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys2(Object(source), true).forEach(function(key2) {
      _defineProperty2(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function _defineProperty2(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _slicedToArray2(arr, i3) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i3) || _unsupportedIterableToArray2(arr, i3) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray2(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor) n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set") return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return _arrayLikeToArray2(o3, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
    arr2[i3] = arr[i3];
  }
  return arr2;
}
function _iterableToArrayLimit2(arr, i3) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i = _i.call(arr); !(_n2 = (_s = _i.next()).done); _n2 = true) {
      _arr.push(_s.value);
      if (i3 && _arr.length === i3) break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr)) return arr;
}
var FILE_INVALID_TYPE = "file-invalid-type";
var FILE_TOO_LARGE = "file-too-large";
var FILE_TOO_SMALL = "file-too-small";
var TOO_MANY_FILES = "too-many-files";
var getInvalidTypeRejectionErr = function getInvalidTypeRejectionErr2(accept) {
  accept = Array.isArray(accept) && accept.length === 1 ? accept[0] : accept;
  var messageSuffix = Array.isArray(accept) ? "one of ".concat(accept.join(", ")) : accept;
  return {
    code: FILE_INVALID_TYPE,
    message: "File type must be ".concat(messageSuffix)
  };
};
var getTooLargeRejectionErr = function getTooLargeRejectionErr2(maxSize) {
  return {
    code: FILE_TOO_LARGE,
    message: "File is larger than ".concat(maxSize, " ").concat(maxSize === 1 ? "byte" : "bytes")
  };
};
var getTooSmallRejectionErr = function getTooSmallRejectionErr2(minSize) {
  return {
    code: FILE_TOO_SMALL,
    message: "File is smaller than ".concat(minSize, " ").concat(minSize === 1 ? "byte" : "bytes")
  };
};
var TOO_MANY_FILES_REJECTION = {
  code: TOO_MANY_FILES,
  message: "Too many files"
};
function fileAccepted(file, accept) {
  var isAcceptable = file.type === "application/x-moz-file" || (0, import_attr_accept.default)(file, accept);
  return [isAcceptable, isAcceptable ? null : getInvalidTypeRejectionErr(accept)];
}
function fileMatchSize(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize) return [false, getTooLargeRejectionErr(maxSize)];
      if (file.size < minSize) return [false, getTooSmallRejectionErr(minSize)];
    } else if (isDefined(minSize) && file.size < minSize) return [false, getTooSmallRejectionErr(minSize)];
    else if (isDefined(maxSize) && file.size > maxSize) return [false, getTooLargeRejectionErr(maxSize)];
  }
  return [true, null];
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function allFilesAccepted(_ref3) {
  var files = _ref3.files, accept = _ref3.accept, minSize = _ref3.minSize, maxSize = _ref3.maxSize, multiple = _ref3.multiple, maxFiles = _ref3.maxFiles;
  if (!multiple && files.length > 1 || multiple && maxFiles >= 1 && files.length > maxFiles) {
    return false;
  }
  return files.every(function(file) {
    var _fileAccepted = fileAccepted(file, accept), _fileAccepted2 = _slicedToArray2(_fileAccepted, 1), accepted = _fileAccepted2[0];
    var _fileMatchSize = fileMatchSize(file, minSize, maxSize), _fileMatchSize2 = _slicedToArray2(_fileMatchSize, 1), sizeMatch = _fileMatchSize2[0];
    return accepted && sizeMatch;
  });
}
function isPropagationStopped(event) {
  if (typeof event.isPropagationStopped === "function") {
    return event.isPropagationStopped();
  } else if (typeof event.cancelBubble !== "undefined") {
    return event.cancelBubble;
  }
  return false;
}
function isEvtWithFiles(event) {
  if (!event.dataTransfer) {
    return !!event.target && !!event.target.files;
  }
  return Array.prototype.some.call(event.dataTransfer.types, function(type) {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function onDocumentDragOver(event) {
  event.preventDefault();
}
function isIe(userAgent) {
  return userAgent.indexOf("MSIE") !== -1 || userAgent.indexOf("Trident/") !== -1;
}
function isEdge(userAgent) {
  return userAgent.indexOf("Edge/") !== -1;
}
function isIeOrEdge() {
  var userAgent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return isIe(userAgent) || isEdge(userAgent);
}
function composeEventHandlers() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function(event) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return fns.some(function(fn2) {
      if (!isPropagationStopped(event) && fn2) {
        fn2.apply(void 0, [event].concat(args));
      }
      return isPropagationStopped(event);
    });
  };
}
function canUseFileSystemAccessAPI() {
  return "showOpenFilePicker" in window;
}
function filePickerOptionsTypes(accept) {
  accept = typeof accept === "string" ? accept.split(",") : accept;
  return [{
    description: "everything",
    // TODO: Need to handle filtering more elegantly than this!
    accept: Array.isArray(accept) ? accept.filter(function(item) {
      return item === "audio/*" || item === "video/*" || item === "image/*" || item === "text/*" || /\w+\/[-+.\w]+/g.test(item);
    }).reduce(function(a2, b2) {
      return _objectSpread(_objectSpread({}, a2), {}, _defineProperty2({}, b2, []));
    }, {}) : {}
  }];
}

// node_modules/react-dropzone/dist/es/index.js
var _excluded6 = ["children"];
var _excluded22 = ["open"];
var _excluded32 = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"];
var _excluded42 = ["refKey", "onChange", "onClick"];
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray3(arr) || _nonIterableSpread2();
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles2(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray3(arr);
}
function _slicedToArray3(arr, i3) {
  return _arrayWithHoles3(arr) || _iterableToArrayLimit3(arr, i3) || _unsupportedIterableToArray3(arr, i3) || _nonIterableRest3();
}
function _nonIterableRest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray3(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray3(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor) n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set") return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return _arrayLikeToArray3(o3, minLen);
}
function _arrayLikeToArray3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
    arr2[i3] = arr[i3];
  }
  return arr2;
}
function _iterableToArrayLimit3(arr, i3) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i = _i.call(arr); !(_n2 = (_s = _i.next()).done); _n2 = true) {
      _arr.push(_s.value);
      if (i3 && _arr.length === i3) break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles3(arr) {
  if (Array.isArray(arr)) return arr;
}
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys3(Object(source), true).forEach(function(key2) {
      _defineProperty3(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function _defineProperty3(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key2, i3;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
      key2 = sourceSymbolKeys[i3];
      if (excluded.indexOf(key2) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2)) continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key2 = sourceKeys[i3];
    if (excluded.indexOf(key2) >= 0) continue;
    target[key2] = source[key2];
  }
  return target;
}
var Dropzone = (0, import_react18.forwardRef)(function(_ref3, ref) {
  var children = _ref3.children, params = _objectWithoutProperties2(_ref3, _excluded6);
  var _useDropzone = useDropzone(params), open = _useDropzone.open, props = _objectWithoutProperties2(_useDropzone, _excluded22);
  (0, import_react18.useImperativeHandle)(ref, function() {
    return {
      open
    };
  }, [open]);
  return import_react18.default.createElement(import_react18.Fragment, null, children(_objectSpread3(_objectSpread3({}, props), {}, {
    open
  })));
});
Dropzone.displayName = "Dropzone";
var defaultProps2 = {
  disabled: false,
  getFilesFromEvent: fromEvent,
  maxSize: Infinity,
  minSize: 0,
  multiple: true,
  maxFiles: 0,
  preventDropOnDocument: true,
  noClick: false,
  noKeyboard: false,
  noDrag: false,
  noDragEventsBubbling: false,
  validator: null,
  useFsAccessApi: false
};
Dropzone.defaultProps = defaultProps2;
Dropzone.propTypes = {
  /**
   * Render function that exposes the dropzone state and prop getter fns
   *
   * @param {object} params
   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render
   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render
   * @param {Function} params.open Open the native file selection dialog
   * @param {boolean} params.isFocused Dropzone area is in focus
   * @param {boolean} params.isFileDialogActive File dialog is opened
   * @param {boolean} params.isDragActive Active drag is in progress
   * @param {boolean} params.isDragAccept Dragged files are accepted
   * @param {boolean} params.isDragReject Some dragged files are rejected
   * @param {File[]} params.draggedFiles Files in active drag
   * @param {File[]} params.acceptedFiles Accepted files
   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected
   */
  children: import_prop_types2.default.func,
  /**
   * Set accepted file types.
   * See https://github.com/okonet/attr-accept for more information.
   * Keep in mind that mime type determination is not reliable across platforms. CSV files,
   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
   * Windows. In some cases there might not be a mime type set at all.
   * See: https://github.com/react-dropzone/react-dropzone/issues/276
   */
  accept: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.arrayOf(import_prop_types2.default.string)]),
  /**
   * Allow drag 'n' drop (or selection from the file dialog) of multiple files
   */
  multiple: import_prop_types2.default.bool,
  /**
   * If false, allow dropped items to take over the current browser window
   */
  preventDropOnDocument: import_prop_types2.default.bool,
  /**
   * If true, disables click to open the native file selection dialog
   */
  noClick: import_prop_types2.default.bool,
  /**
   * If true, disables SPACE/ENTER to open the native file selection dialog.
   * Note that it also stops tracking the focus state.
   */
  noKeyboard: import_prop_types2.default.bool,
  /**
   * If true, disables drag 'n' drop
   */
  noDrag: import_prop_types2.default.bool,
  /**
   * If true, stops drag event propagation to parents
   */
  noDragEventsBubbling: import_prop_types2.default.bool,
  /**
   * Minimum file size (in bytes)
   */
  minSize: import_prop_types2.default.number,
  /**
   * Maximum file size (in bytes)
   */
  maxSize: import_prop_types2.default.number,
  /**
   * Maximum accepted number of files
   * The default value is 0 which means there is no limitation to how many files are accepted.
   */
  maxFiles: import_prop_types2.default.number,
  /**
   * Enable/disable the dropzone
   */
  disabled: import_prop_types2.default.bool,
  /**
   * Use this to provide a custom file aggregator
   *
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  getFilesFromEvent: import_prop_types2.default.func,
  /**
   * Cb for when closing the file dialog with no selection
   */
  onFileDialogCancel: import_prop_types2.default.func,
  /**
   * Cb for when opening the file dialog
   */
  onFileDialogOpen: import_prop_types2.default.func,
  /**
   * Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API
   * to open the file picker instead of using an `<input type="file">` click event.
   */
  useFsAccessApi: import_prop_types2.default.bool,
  /**
   * Cb for when the `dragenter` event occurs.
   *
   * @param {DragEvent} event
   */
  onDragEnter: import_prop_types2.default.func,
  /**
   * Cb for when the `dragleave` event occurs
   *
   * @param {DragEvent} event
   */
  onDragLeave: import_prop_types2.default.func,
  /**
   * Cb for when the `dragover` event occurs
   *
   * @param {DragEvent} event
   */
  onDragOver: import_prop_types2.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
   *
   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
   * If `multiple` is set to false and additional files are dropped,
   * all files besides the first will be rejected.
   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
   *
   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
   *
   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
   *
   * ```js
   * function onDrop(acceptedFiles) {
   *   const req = request.post('/upload')
   *   acceptedFiles.forEach(file => {
   *     req.attach(file.name, file)
   *   })
   *   req.end(callback)
   * }
   * ```
   *
   * @param {File[]} acceptedFiles
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  onDrop: import_prop_types2.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are accepted, this callback is not invoked.
   *
   * @param {File[]} files
   * @param {(DragEvent|Event)} event
   */
  onDropAccepted: import_prop_types2.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are rejected, this callback is not invoked.
   *
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event
   */
  onDropRejected: import_prop_types2.default.func,
  /**
   * Custom validation function
   * @param {File} file
   * @returns {FileError|FileError[]}
   */
  validator: import_prop_types2.default.func
};
var initialState2 = {
  isFocused: false,
  isFileDialogActive: false,
  isDragActive: false,
  isDragAccept: false,
  isDragReject: false,
  draggedFiles: [],
  acceptedFiles: [],
  fileRejections: []
};
function useDropzone() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _defaultProps$options = _objectSpread3(_objectSpread3({}, defaultProps2), options2), accept = _defaultProps$options.accept, disabled = _defaultProps$options.disabled, getFilesFromEvent = _defaultProps$options.getFilesFromEvent, maxSize = _defaultProps$options.maxSize, minSize = _defaultProps$options.minSize, multiple = _defaultProps$options.multiple, maxFiles = _defaultProps$options.maxFiles, onDragEnter = _defaultProps$options.onDragEnter, onDragLeave = _defaultProps$options.onDragLeave, onDragOver = _defaultProps$options.onDragOver, onDrop = _defaultProps$options.onDrop, onDropAccepted = _defaultProps$options.onDropAccepted, onDropRejected = _defaultProps$options.onDropRejected, onFileDialogCancel = _defaultProps$options.onFileDialogCancel, onFileDialogOpen = _defaultProps$options.onFileDialogOpen, useFsAccessApi = _defaultProps$options.useFsAccessApi, preventDropOnDocument = _defaultProps$options.preventDropOnDocument, noClick = _defaultProps$options.noClick, noKeyboard = _defaultProps$options.noKeyboard, noDrag = _defaultProps$options.noDrag, noDragEventsBubbling = _defaultProps$options.noDragEventsBubbling, validator = _defaultProps$options.validator;
  var onFileDialogOpenCb = (0, import_react18.useMemo)(function() {
    return typeof onFileDialogOpen === "function" ? onFileDialogOpen : noop6;
  }, [onFileDialogOpen]);
  var onFileDialogCancelCb = (0, import_react18.useMemo)(function() {
    return typeof onFileDialogCancel === "function" ? onFileDialogCancel : noop6;
  }, [onFileDialogCancel]);
  var rootRef = (0, import_react18.useRef)(null);
  var inputRef = (0, import_react18.useRef)(null);
  var _useReducer = (0, import_react18.useReducer)(reducer, initialState2), _useReducer2 = _slicedToArray3(_useReducer, 2), state = _useReducer2[0], dispatch = _useReducer2[1];
  var isFocused = state.isFocused, isFileDialogActive = state.isFileDialogActive, draggedFiles = state.draggedFiles;
  var onWindowFocus = function onWindowFocus2() {
    if (isFileDialogActive) {
      setTimeout(function() {
        if (inputRef.current) {
          var files = inputRef.current.files;
          if (!files.length) {
            dispatch({
              type: "closeDialog"
            });
            onFileDialogCancelCb();
          }
        }
      }, 300);
    }
  };
  (0, import_react18.useEffect)(function() {
    if (useFsAccessApi && canUseFileSystemAccessAPI()) {
      return function() {
      };
    }
    window.addEventListener("focus", onWindowFocus, false);
    return function() {
      window.removeEventListener("focus", onWindowFocus, false);
    };
  }, [inputRef, isFileDialogActive, onFileDialogCancelCb, useFsAccessApi]);
  var dragTargetsRef = (0, import_react18.useRef)([]);
  var onDocumentDrop = function onDocumentDrop2(event) {
    if (rootRef.current && rootRef.current.contains(event.target)) {
      return;
    }
    event.preventDefault();
    dragTargetsRef.current = [];
  };
  (0, import_react18.useEffect)(function() {
    if (preventDropOnDocument) {
      document.addEventListener("dragover", onDocumentDragOver, false);
      document.addEventListener("drop", onDocumentDrop, false);
    }
    return function() {
      if (preventDropOnDocument) {
        document.removeEventListener("dragover", onDocumentDragOver);
        document.removeEventListener("drop", onDocumentDrop);
      }
    };
  }, [rootRef, preventDropOnDocument]);
  var onDragEnterCb = (0, import_react18.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [].concat(_toConsumableArray2(dragTargetsRef.current), [event.target]);
    if (isEvtWithFiles(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function(draggedFiles2) {
        if (isPropagationStopped(event) && !noDragEventsBubbling) {
          return;
        }
        dispatch({
          draggedFiles: draggedFiles2,
          isDragActive: true,
          type: "setDraggedFiles"
        });
        if (onDragEnter) {
          onDragEnter(event);
        }
      });
    }
  }, [getFilesFromEvent, onDragEnter, noDragEventsBubbling]);
  var onDragOverCb = (0, import_react18.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    var hasFiles = isEvtWithFiles(event);
    if (hasFiles && event.dataTransfer) {
      try {
        event.dataTransfer.dropEffect = "copy";
      } catch (_unused) {
      }
    }
    if (hasFiles && onDragOver) {
      onDragOver(event);
    }
    return false;
  }, [onDragOver, noDragEventsBubbling]);
  var onDragLeaveCb = (0, import_react18.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    var targets = dragTargetsRef.current.filter(function(target) {
      return rootRef.current && rootRef.current.contains(target);
    });
    var targetIdx = targets.indexOf(event.target);
    if (targetIdx !== -1) {
      targets.splice(targetIdx, 1);
    }
    dragTargetsRef.current = targets;
    if (targets.length > 0) {
      return;
    }
    dispatch({
      isDragActive: false,
      type: "setDraggedFiles",
      draggedFiles: []
    });
    if (isEvtWithFiles(event) && onDragLeave) {
      onDragLeave(event);
    }
  }, [rootRef, onDragLeave, noDragEventsBubbling]);
  var setFiles = (0, import_react18.useCallback)(function(files, event) {
    var acceptedFiles = [];
    var fileRejections = [];
    files.forEach(function(file) {
      var _fileAccepted = fileAccepted(file, accept), _fileAccepted2 = _slicedToArray3(_fileAccepted, 2), accepted = _fileAccepted2[0], acceptError = _fileAccepted2[1];
      var _fileMatchSize = fileMatchSize(file, minSize, maxSize), _fileMatchSize2 = _slicedToArray3(_fileMatchSize, 2), sizeMatch = _fileMatchSize2[0], sizeError = _fileMatchSize2[1];
      var customErrors = validator ? validator(file) : null;
      if (accepted && sizeMatch && !customErrors) {
        acceptedFiles.push(file);
      } else {
        var errors = [acceptError, sizeError];
        if (customErrors) {
          errors = errors.concat(customErrors);
        }
        fileRejections.push({
          file,
          errors: errors.filter(function(e2) {
            return e2;
          })
        });
      }
    });
    if (!multiple && acceptedFiles.length > 1 || multiple && maxFiles >= 1 && acceptedFiles.length > maxFiles) {
      acceptedFiles.forEach(function(file) {
        fileRejections.push({
          file,
          errors: [TOO_MANY_FILES_REJECTION]
        });
      });
      acceptedFiles.splice(0);
    }
    dispatch({
      acceptedFiles,
      fileRejections,
      type: "setFiles"
    });
    if (onDrop) {
      onDrop(acceptedFiles, fileRejections, event);
    }
    if (fileRejections.length > 0 && onDropRejected) {
      onDropRejected(fileRejections, event);
    }
    if (acceptedFiles.length > 0 && onDropAccepted) {
      onDropAccepted(acceptedFiles, event);
    }
  }, [dispatch, multiple, accept, minSize, maxSize, maxFiles, onDrop, onDropAccepted, onDropRejected, validator]);
  var onDropCb = (0, import_react18.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [];
    if (isEvtWithFiles(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function(files) {
        if (isPropagationStopped(event) && !noDragEventsBubbling) {
          return;
        }
        setFiles(files, event);
      });
    }
    dispatch({
      type: "reset"
    });
  }, [getFilesFromEvent, setFiles, noDragEventsBubbling]);
  var openFileDialog = (0, import_react18.useCallback)(function() {
    if (useFsAccessApi && canUseFileSystemAccessAPI()) {
      dispatch({
        type: "openDialog"
      });
      onFileDialogOpenCb();
      var opts = {
        multiple,
        types: filePickerOptionsTypes(accept)
      };
      window.showOpenFilePicker(opts).then(function(handles) {
        return getFilesFromEvent(handles);
      }).then(function(files) {
        return setFiles(files, null);
      }).catch(function(e2) {
        return onFileDialogCancelCb(e2);
      }).finally(function() {
        return dispatch({
          type: "closeDialog"
        });
      });
      return;
    }
    if (inputRef.current) {
      dispatch({
        type: "openDialog"
      });
      onFileDialogOpenCb();
      inputRef.current.value = null;
      inputRef.current.click();
    }
  }, [dispatch, onFileDialogOpenCb, onFileDialogCancelCb, useFsAccessApi, setFiles, accept, multiple]);
  var onKeyDownCb = (0, import_react18.useCallback)(function(event) {
    if (!rootRef.current || !rootRef.current.isEqualNode(event.target)) {
      return;
    }
    if (event.keyCode === 32 || event.keyCode === 13) {
      event.preventDefault();
      openFileDialog();
    }
  }, [rootRef, inputRef, openFileDialog]);
  var onFocusCb = (0, import_react18.useCallback)(function() {
    dispatch({
      type: "focus"
    });
  }, []);
  var onBlurCb = (0, import_react18.useCallback)(function() {
    dispatch({
      type: "blur"
    });
  }, []);
  var onClickCb = (0, import_react18.useCallback)(function() {
    if (noClick) {
      return;
    }
    if (isIeOrEdge()) {
      setTimeout(openFileDialog, 0);
    } else {
      openFileDialog();
    }
  }, [inputRef, noClick, openFileDialog]);
  var composeHandler = function composeHandler2(fn2) {
    return disabled ? null : fn2;
  };
  var composeKeyboardHandler = function composeKeyboardHandler2(fn2) {
    return noKeyboard ? null : composeHandler(fn2);
  };
  var composeDragHandler = function composeDragHandler2(fn2) {
    return noDrag ? null : composeHandler(fn2);
  };
  var stopPropagation = function stopPropagation2(event) {
    if (noDragEventsBubbling) {
      event.stopPropagation();
    }
  };
  var getRootProps = (0, import_react18.useMemo)(function() {
    return function() {
      var _ref23 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$refKey = _ref23.refKey, refKey = _ref2$refKey === void 0 ? "ref" : _ref2$refKey, role = _ref23.role, onKeyDown = _ref23.onKeyDown, onFocus2 = _ref23.onFocus, onBlur = _ref23.onBlur, onClick = _ref23.onClick, onDragEnter2 = _ref23.onDragEnter, onDragOver2 = _ref23.onDragOver, onDragLeave2 = _ref23.onDragLeave, onDrop2 = _ref23.onDrop, rest = _objectWithoutProperties2(_ref23, _excluded32);
      return _objectSpread3(_objectSpread3(_defineProperty3({
        onKeyDown: composeKeyboardHandler(composeEventHandlers(onKeyDown, onKeyDownCb)),
        onFocus: composeKeyboardHandler(composeEventHandlers(onFocus2, onFocusCb)),
        onBlur: composeKeyboardHandler(composeEventHandlers(onBlur, onBlurCb)),
        onClick: composeHandler(composeEventHandlers(onClick, onClickCb)),
        onDragEnter: composeDragHandler(composeEventHandlers(onDragEnter2, onDragEnterCb)),
        onDragOver: composeDragHandler(composeEventHandlers(onDragOver2, onDragOverCb)),
        onDragLeave: composeDragHandler(composeEventHandlers(onDragLeave2, onDragLeaveCb)),
        onDrop: composeDragHandler(composeEventHandlers(onDrop2, onDropCb)),
        role: typeof role === "string" && role !== "" ? role : "button"
      }, refKey, rootRef), !disabled && !noKeyboard ? {
        tabIndex: 0
      } : {}), rest);
    };
  }, [rootRef, onKeyDownCb, onFocusCb, onBlurCb, onClickCb, onDragEnterCb, onDragOverCb, onDragLeaveCb, onDropCb, noKeyboard, noDrag, disabled]);
  var onInputElementClick = (0, import_react18.useCallback)(function(event) {
    event.stopPropagation();
  }, []);
  var getInputProps = (0, import_react18.useMemo)(function() {
    return function() {
      var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, onChange2 = _ref3.onChange, onClick = _ref3.onClick, rest = _objectWithoutProperties2(_ref3, _excluded42);
      var inputProps = _defineProperty3({
        accept,
        multiple,
        type: "file",
        style: {
          display: "none"
        },
        onChange: composeHandler(composeEventHandlers(onChange2, onDropCb)),
        onClick: composeHandler(composeEventHandlers(onClick, onInputElementClick)),
        autoComplete: "off",
        tabIndex: -1
      }, refKey, inputRef);
      return _objectSpread3(_objectSpread3({}, inputProps), rest);
    };
  }, [inputRef, accept, multiple, onDropCb, disabled]);
  var fileCount = draggedFiles.length;
  var isDragAccept = fileCount > 0 && allFilesAccepted({
    files: draggedFiles,
    accept,
    minSize,
    maxSize,
    multiple,
    maxFiles
  });
  var isDragReject = fileCount > 0 && !isDragAccept;
  return _objectSpread3(_objectSpread3({}, state), {}, {
    isDragAccept,
    isDragReject,
    isFocused: isFocused && !disabled,
    getRootProps,
    getInputProps,
    rootRef,
    inputRef,
    open: composeHandler(openFileDialog)
  });
}
function reducer(state, action) {
  switch (action.type) {
    case "focus":
      return _objectSpread3(_objectSpread3({}, state), {}, {
        isFocused: true
      });
    case "blur":
      return _objectSpread3(_objectSpread3({}, state), {}, {
        isFocused: false
      });
    case "openDialog":
      return _objectSpread3(_objectSpread3({}, initialState2), {}, {
        isFileDialogActive: true
      });
    case "closeDialog":
      return _objectSpread3(_objectSpread3({}, state), {}, {
        isFileDialogActive: false
      });
    case "setDraggedFiles":
      var isDragActive = action.isDragActive, draggedFiles = action.draggedFiles;
      return _objectSpread3(_objectSpread3({}, state), {}, {
        draggedFiles,
        isDragActive
      });
    case "setFiles":
      return _objectSpread3(_objectSpread3({}, state), {}, {
        acceptedFiles: action.acceptedFiles,
        fileRejections: action.fileRejections
      });
    case "reset":
      return _objectSpread3({}, initialState2);
    default:
      return state;
  }
}
function noop6() {
}

// node_modules/sanity-plugin-media/dist/index.mjs
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3.default : x3;
}
var lib = {};
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1, Object.defineProperty(lib, "__esModule", {
    value: true
  });
  for (var IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  }, ALIASES = {
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  }, CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  }, f2 = 1; f2 < 20; f2++)
    CODES["f" + f2] = 111 + f2;
  function isHotkey2(hotkey, options2, event) {
    options2 && !("byKey" in options2) && (event = options2, options2 = null), Array.isArray(hotkey) || (hotkey = [hotkey]);
    var array = hotkey.map(function(string) {
      return parseHotkey(string, options2);
    }), check = function(e2) {
      return array.some(function(object) {
        return compareHotkey(object, e2);
      });
    }, ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey2(hotkey, event);
  }
  function isKeyHotkey(hotkey, event) {
    return isHotkey2(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options2) {
    var byKey = options2 && options2.byKey, ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values = hotkey.split("+"), length2 = values.length;
    for (var k2 in MODIFIERS)
      ret[MODIFIERS[k2]] = false;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value, optional = value.endsWith("?") && value.length > 1;
        optional && (value = value.slice(0, -1));
        var name = toKeyName(value), modifier = MODIFIERS[name];
        if (value.length > 1 && !modifier && !ALIASES[value] && !CODES[name])
          throw new TypeError('Unknown modifier: "' + value + '"');
        (length2 === 1 || !modifier) && (byKey ? ret.key = name : ret.which = toKeyCode(value)), modifier && (ret[modifier] = optional ? null : true);
      }
    } catch (err) {
      _didIteratorError = true, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
    return ret;
  }
  function compareHotkey(object, event) {
    for (var key2 in object) {
      var expected = object[key2], actual = void 0;
      if (expected != null && (key2 === "key" && event.key != null ? actual = event.key.toLowerCase() : key2 === "which" ? actual = expected === 91 && event.which === 93 ? 91 : event.which : actual = event[key2], !(actual == null && expected === false) && actual !== expected))
        return false;
    }
    return true;
  }
  function toKeyCode(name) {
    name = toKeyName(name);
    var code = CODES[name] || name.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name) {
    return name = name.toLowerCase(), name = ALIASES[name] || name, name;
  }
  return lib.default = isHotkey2, lib.isHotkey = isHotkey2, lib.isCodeHotkey = isCodeHotkey, lib.isKeyHotkey = isKeyHotkey, lib.parseHotkey = parseHotkey, lib.compareHotkey = compareHotkey, lib.toKeyCode = toKeyCode, lib.toKeyName = toKeyName, lib;
}
var libExports = requireLib();
var isHotkey = getDefaultExportFromCjs(libExports);
var useKeyPress = (hotkey, onPress) => {
  const keyPressed = (0, import_react19.useRef)(false), downHandler = (0, import_react19.useCallback)(
    (e2) => {
      isHotkey(hotkey, e2) && (keyPressed.current = true, onPress && onPress());
    },
    [hotkey, onPress]
  ), upHandler = (0, import_react19.useCallback)(() => {
    keyPressed.current = false;
  }, []);
  return (0, import_react19.useEffect)(() => (window.addEventListener("keydown", downHandler), window.addEventListener("keyup", upHandler), () => {
    window.removeEventListener("keydown", downHandler), window.removeEventListener("keyup", upHandler);
  }), [downHandler, upHandler]), keyPressed;
};
var divider = { type: "divider" };
var inputs = {
  altText: {
    assetTypes: ["file", "image"],
    field: "altText",
    name: "altText",
    operatorType: "empty",
    operatorTypes: ["empty", "notEmpty", null, "includes", "doesNotInclude"],
    title: "Alt text",
    type: "string",
    value: ""
  },
  creditLine: {
    assetTypes: ["file", "image"],
    field: "creditLine",
    name: "creditLine",
    operatorType: "empty",
    operatorTypes: ["empty", "notEmpty", null, "includes", "doesNotInclude"],
    title: "Credit",
    type: "string",
    value: ""
  },
  description: {
    assetTypes: ["file", "image"],
    field: "description",
    name: "description",
    operatorType: "empty",
    operatorTypes: ["empty", "notEmpty", null, "includes", "doesNotInclude"],
    title: "Description",
    type: "string",
    value: ""
  },
  fileName: {
    assetTypes: ["file", "image"],
    field: "originalFilename",
    name: "filename",
    operatorType: "includes",
    operatorTypes: ["includes", "doesNotInclude"],
    title: "File name",
    type: "string",
    value: ""
  },
  height: {
    assetTypes: ["image"],
    field: "metadata.dimensions.height",
    name: "height",
    operatorType: "greaterThan",
    operatorTypes: [
      "greaterThan",
      "greaterThanOrEqualTo",
      "lessThan",
      "lessThanOrEqualTo",
      null,
      "equalTo"
    ],
    title: "Height",
    type: "number",
    value: 400
  },
  inCurrentDocument: {
    assetTypes: ["file", "image"],
    name: "inCurrentDocument",
    operatorType: "is",
    options: [
      {
        name: "true",
        title: "True",
        value: groq`_id in $documentAssetIds`
      },
      {
        name: "false",
        title: "False",
        value: groq`!(_id in $documentAssetIds)`
      }
    ],
    selectOnly: true,
    title: "In use in current document",
    type: "select",
    value: "true"
  },
  inUse: {
    assetTypes: ["file", "image"],
    name: "inUse",
    operatorType: "is",
    options: [
      {
        name: "true",
        title: "True",
        value: groq`count(*[references(^._id)]) > 0`
      },
      {
        name: "false",
        title: "False",
        value: groq`count(*[references(^._id)]) == 0`
      }
    ],
    title: "In use",
    type: "select",
    value: "true"
  },
  isOpaque: {
    assetTypes: ["image"],
    field: "metadata.isOpaque",
    name: "isOpaque",
    operatorType: "equalTo",
    options: [
      {
        name: "true",
        title: "True",
        value: "false"
      },
      {
        name: "false",
        title: "False",
        value: "true"
      }
    ],
    title: "Has transparency",
    type: "select",
    value: "true"
  },
  orientation: {
    assetTypes: ["image"],
    name: "orientation",
    operatorType: "is",
    operatorTypes: ["is", "isNot"],
    options: [
      {
        name: "portrait",
        title: "Portrait",
        value: "metadata.dimensions.aspectRatio < 1"
      },
      {
        name: "landscape",
        title: "Landscape",
        value: "metadata.dimensions.aspectRatio > 1"
      },
      {
        name: "square",
        title: "Square",
        value: "metadata.dimensions.aspectRatio == 1"
      }
    ],
    title: "Orientation",
    type: "select",
    value: "portrait"
  },
  size: {
    assetTypes: ["file", "image"],
    field: "size",
    modifier: "kb",
    modifiers: [
      {
        name: "kb",
        title: "KB",
        fieldModifier: (fieldName) => `round(${fieldName} / 1000)`
      },
      {
        name: "mb",
        title: "MB",
        fieldModifier: (fieldName) => `round(${fieldName} / 1000000)`
      }
    ],
    name: "size",
    operatorType: "greaterThan",
    operatorTypes: [
      "greaterThan",
      "greaterThanOrEqualTo",
      "lessThan",
      "lessThanOrEqualTo",
      null,
      "equalTo"
    ],
    title: "File size",
    type: "number",
    value: 0
  },
  tag: {
    assetTypes: ["file", "image"],
    field: "opt.media.tags",
    name: "tag",
    operatorType: "references",
    operatorTypes: ["references", "doesNotReference", null, "empty", "notEmpty"],
    title: "Tags",
    type: "searchable"
  },
  title: {
    assetTypes: ["file", "image"],
    field: "title",
    name: "title",
    operatorType: "empty",
    operatorTypes: ["empty", "notEmpty", null, "includes", "doesNotInclude"],
    title: "Title",
    type: "string",
    value: ""
  },
  type: {
    assetTypes: ["file", "image"],
    name: "type",
    operatorType: "is",
    operatorTypes: ["is", "isNot"],
    options: [
      {
        name: "image",
        title: "Image",
        value: 'mimeType match "image*"'
      },
      {
        name: "video",
        title: "Video",
        value: 'mimeType match "video*"'
      },
      {
        name: "audio",
        title: "Audio",
        value: 'mimeType match "audio*"'
      },
      {
        name: "pdf",
        title: "PDF",
        value: 'mimeType == "application/pdf"'
      }
    ],
    title: "File type",
    type: "select",
    value: "image"
  },
  width: {
    assetTypes: ["image"],
    field: "metadata.dimensions.width",
    name: "width",
    operatorType: "greaterThan",
    operatorTypes: [
      "greaterThan",
      "greaterThanOrEqualTo",
      "lessThan",
      "lessThanOrEqualTo",
      null,
      "equalTo"
    ],
    title: "Width",
    type: "number",
    value: 400
  }
};
var operators = {
  doesNotInclude: {
    fn: (value, field) => value ? `!(${field} match '*${value}*')` : void 0,
    label: "does not include"
  },
  doesNotReference: {
    fn: (value, _field) => value ? `!references('${value}')` : void 0,
    label: "does not include"
  },
  empty: {
    fn: (_value, field) => `!defined(${field})`,
    hideInput: true,
    label: "is empty"
  },
  equalTo: {
    fn: (value, field) => value ? `${field} == ${value}` : void 0,
    label: "is equal to"
  },
  greaterThan: {
    fn: (value, field) => value ? `${field} > ${value}` : void 0,
    label: "is greater than"
  },
  greaterThanOrEqualTo: {
    fn: (value, field) => value ? `${field} >= ${value}` : void 0,
    label: "is greater than or equal to"
  },
  includes: {
    fn: (value, field) => value ? `${field} match '*${value}*'` : void 0,
    label: "includes"
  },
  is: {
    fn: (value, _field) => `${value}`,
    label: "is"
  },
  isNot: {
    fn: (value, _field) => `!(${value})`,
    label: "is not"
  },
  lessThan: {
    fn: (value, field) => value ? `${field} < ${value}` : void 0,
    label: "is less than"
  },
  lessThanOrEqualTo: {
    fn: (value, field) => value ? `${field} <= ${value}` : void 0,
    label: "is less than or equal to"
  },
  notEmpty: {
    fn: (_value, field) => `defined(${field})`,
    hideInput: true,
    label: "is not empty"
  },
  references: {
    fn: (value, _field) => value ? `references('${value}')` : void 0,
    label: "includes"
  }
};
var ORDER_OPTIONS = [
  {
    direction: "desc",
    field: "_createdAt"
  },
  {
    direction: "asc",
    field: "_createdAt"
  },
  // Divider
  null,
  {
    direction: "desc",
    field: "_updatedAt"
  },
  {
    direction: "asc",
    field: "_updatedAt"
  },
  // Divider
  null,
  {
    direction: "asc",
    field: "originalFilename"
  },
  {
    direction: "desc",
    field: "originalFilename"
  },
  // Divider
  null,
  {
    direction: "desc",
    field: "size"
  },
  {
    direction: "asc",
    field: "size"
  }
];
var FACETS = [
  inputs.tag,
  divider,
  inputs.inUse,
  inputs.inCurrentDocument,
  divider,
  inputs.title,
  inputs.altText,
  inputs.creditLine,
  inputs.description,
  divider,
  inputs.isOpaque,
  divider,
  inputs.fileName,
  inputs.size,
  inputs.type,
  divider,
  inputs.orientation,
  inputs.width,
  inputs.height
];
var GRID_TEMPLATE_COLUMNS = {
  SMALL: "3rem 100px auto 1.5rem",
  LARGE: "3rem 100px auto 5.5rem 5.5rem 3.5rem 8.5rem 4.75rem 2rem"
};
var PANEL_HEIGHT = 32;
var TAG_DOCUMENT_NAME = "media.tag";
var TAGS_PANEL_WIDTH = 250;
var AssetSourceDispatchContext = (0, import_react19.createContext)(void 0);
var AssetBrowserDispatchProvider = (props) => {
  const { children, onSelect } = props, contextValue = {
    onSelect
  };
  return (0, import_jsx_runtime4.jsx)(AssetSourceDispatchContext.Provider, { value: contextValue, children });
};
var useAssetSourceActions = () => {
  const context = (0, import_react19.useContext)(AssetSourceDispatchContext);
  if (context === void 0)
    throw new Error("useAssetSourceActions must be used within an AssetSourceDispatchProvider");
  return context;
};
var useVersionedClient = () => useClient({ apiVersion: "2022-10-01" });
var ORDER_DICTIONARY = {
  _createdAt: {
    asc: "Last created: Oldest first",
    desc: "Last created: Newest first"
  },
  _updatedAt: {
    asc: "Last updated: Oldest first",
    desc: "Last updated: Newest first"
  },
  mimeType: {
    asc: "MIME type: A to Z",
    desc: "MIME type: Z to A"
  },
  originalFilename: {
    asc: "File name: A to Z",
    desc: "File name: Z to A"
  },
  size: {
    asc: "File size: Smallest first",
    desc: "File size: Largest first"
  }
};
var getOrderTitle = (field, direction) => ORDER_DICTIONARY[field][direction];
var debugThrottle = (throttled) => function(source) {
  return iif(
    () => !!throttled,
    source.pipe(
      delay(3e3),
      mergeMap((v2) => Math.random() > 0.5 ? throwError({
        message: "Test error",
        statusCode: 500
      }) : of(v2))
    ),
    source
  );
};
var constructFilter = ({
  assetTypes,
  searchFacets,
  searchQuery
}) => {
  const documentAssetTypes = assetTypes.map((type) => `sanity.${type}Asset`), baseFilter = groq`
    _type in ${JSON.stringify(documentAssetTypes)} && !(_id in path("drafts.**"))
  `, searchFacetFragments = searchFacets.reduce((acc, facet) => {
    if (facet.type === "number") {
      const { field, modifier, modifiers, operatorType, value } = facet, operator = operators[operatorType], currentModifier = modifiers?.find((m2) => m2.name === modifier), facetField = currentModifier?.fieldModifier ? currentModifier.fieldModifier(field) : field, fragment = operator.fn(value, facetField);
      fragment && acc.push(fragment);
    }
    if (facet.type === "searchable") {
      const { field, operatorType, value } = facet, fragment = operators[operatorType].fn(value?.value, field);
      fragment && acc.push(fragment);
    }
    if (facet.type === "select") {
      const { field, operatorType, options: options2, value } = facet, operator = operators[operatorType], currentOptionValue = options2?.find((l2) => l2.name === value)?.value, fragment = operator.fn(currentOptionValue, field);
      fragment && acc.push(fragment);
    }
    if (facet.type === "string") {
      const { field, operatorType, value } = facet, fragment = operators[operatorType].fn(value, field);
      fragment && acc.push(fragment);
    }
    return acc;
  }, []);
  return [
    // Base filter
    baseFilter,
    // Search query (if present)
    // NOTE: Currently this only searches direct fields on sanity.fileAsset/sanity.imageAsset and NOT referenced tags
    // It's possible to add this by adding the following line to the searchQuery, but it's quite slow
    // references(*[_type == "media.tag" && name.current == "${searchQuery.trim()}"]._id)
    ...searchQuery ? [
      groq`[_id, altText, assetId, creditLine, description, originalFilename, title, url] match '*${searchQuery.trim()}*'`
    ] : [],
    // Search facets
    ...searchFacetFragments
  ].join(" && ");
};
var checkTagName = (client, name) => function(source) {
  return source.pipe(
    mergeMap(() => from(
      client.fetch(groq`count(*[_type == "${TAG_DOCUMENT_NAME}" && name.current == $name])`, {
        name
      })
    )),
    mergeMap((existingTagCount) => existingTagCount > 0 ? throwError({
      message: "Tag already exists",
      statusCode: 409
    }) : of(true))
  );
};
var getTagSelectOptions = (tags) => tags.reduce((acc, val) => {
  const tag = val?.tag;
  return tag && acc.push({
    label: tag?.name?.current,
    value: tag?._id
  }), acc;
}, []);
var ASSETS_ACTIONS = {
  tagsAddComplete: createAction(
    "actions/tagsAddComplete",
    function({ assets, tag }) {
      return { payload: { assets, tag } };
    }
  ),
  tagsAddError: createAction(
    "actions/tagsAddError",
    function({ assets, error, tag }) {
      return { payload: { assets, error, tag } };
    }
  ),
  tagsAddRequest: createAction(
    "actions/tagsAddRequest",
    function({ assets, tag }) {
      return { payload: { assets, tag } };
    }
  ),
  tagsRemoveComplete: createAction(
    "actions/tagsRemoveComplete",
    function({ assets, tag }) {
      return { payload: { assets, tag } };
    }
  ),
  tagsRemoveError: createAction(
    "actions/tagsRemoveError",
    function({ assets, error, tag }) {
      return { payload: { assets, error, tag } };
    }
  ),
  tagsRemoveRequest: createAction(
    "actions/tagsRemoveRequest",
    function({ assets, tag }) {
      return { payload: { assets, tag } };
    }
  )
};
var DIALOG_ACTIONS = {
  showTagCreate: createAction("dialog/showTagCreate"),
  showTagEdit: createAction("dialog/showTagEdit", function({ tagId }) {
    return {
      payload: { tagId }
    };
  })
};
var initialState$7 = {
  allIds: [],
  byIds: {},
  creating: false,
  creatingError: void 0,
  fetchCount: -1,
  fetching: false,
  fetchingError: void 0,
  panelVisible: true
};
var tagsSlice = createSlice({
  name: "tags",
  initialState: initialState$7,
  extraReducers: (builder) => {
    builder.addCase(DIALOG_ACTIONS.showTagCreate, (state) => {
      delete state.creatingError;
    }).addCase(DIALOG_ACTIONS.showTagEdit, (state, action) => {
      const { tagId } = action.payload;
      delete state.byIds[tagId].error;
    }).addMatcher(
      isAnyOf(
        ASSETS_ACTIONS.tagsAddComplete,
        ASSETS_ACTIONS.tagsAddError,
        ASSETS_ACTIONS.tagsRemoveComplete,
        ASSETS_ACTIONS.tagsRemoveError
      ),
      (state, action) => {
        const { tag } = action.payload;
        state.byIds[tag._id].updating = false;
      }
    ).addMatcher(
      isAnyOf(ASSETS_ACTIONS.tagsAddRequest, ASSETS_ACTIONS.tagsRemoveRequest),
      (state, action) => {
        const { tag } = action.payload;
        state.byIds[tag._id].updating = true;
      }
    );
  },
  reducers: {
    createComplete(state, action) {
      const { tag } = action.payload;
      state.creating = false, state.allIds.includes(tag._id) || state.allIds.push(tag._id), state.byIds[tag._id] = {
        _type: "tag",
        picked: false,
        tag,
        updating: false
      };
    },
    createError(state, action) {
      state.creating = false, state.creatingError = action.payload.error;
    },
    createRequest(state, _action) {
      state.creating = true, delete state.creatingError;
    },
    deleteComplete(state, action) {
      const { tagId } = action.payload, deleteIndex = state.allIds.indexOf(tagId);
      deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), delete state.byIds[tagId];
    },
    deleteError(state, action) {
      const { error, tag } = action.payload, tagId = tag?._id;
      state.byIds[tagId].error = error, state.byIds[tagId].updating = false;
    },
    deleteRequest(state, action) {
      const tagId = action.payload?.tag?._id;
      state.byIds[tagId].picked = false, state.byIds[tagId].updating = true, Object.keys(state.byIds).forEach((key2) => {
        delete state.byIds[key2].error;
      });
    },
    fetchComplete(state, action) {
      const { tags } = action.payload;
      tags?.forEach((tag) => {
        state.allIds.push(tag._id), state.byIds[tag._id] = {
          _type: "tag",
          picked: false,
          tag,
          updating: false
        };
      }), state.fetching = false, state.fetchCount = tags.length || 0, delete state.fetchingError;
    },
    fetchError(state, action) {
      const { error } = action.payload;
      state.fetching = false, state.fetchingError = error;
    },
    fetchRequest: {
      reducer: (state, _action) => {
        state.fetching = true, delete state.fetchingError;
      },
      prepare: () => ({ payload: { query: groq`
          {
            "items": *[
              _type == "${TAG_DOCUMENT_NAME}"
              && !(_id in path("drafts.**"))
            ] {
              _createdAt,
              _updatedAt,
              _id,
              _rev,
              _type,
              name
            } | order(name.current asc),
          }
        ` } })
    },
    // Queue batch tag creation
    listenerCreateQueue(_state, _action) {
    },
    // Apply created tags (via sanity real-time events)
    listenerCreateQueueComplete(state, action) {
      const { tags } = action.payload;
      tags?.forEach((tag) => {
        state.byIds[tag._id] = {
          _type: "tag",
          picked: false,
          tag,
          updating: false
        }, state.allIds.includes(tag._id) || state.allIds.push(tag._id);
      });
    },
    // Queue batch tag deletion
    listenerDeleteQueue(_state, _action) {
    },
    // Apply deleted tags (via sanity real-time events)
    listenerDeleteQueueComplete(state, action) {
      const { tagIds } = action.payload;
      tagIds?.forEach((tagId) => {
        const deleteIndex = state.allIds.indexOf(tagId);
        deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), delete state.byIds[tagId];
      });
    },
    // Queue batch tag updates
    listenerUpdateQueue(_state, _action) {
    },
    // Apply updated tags (via sanity real-time events)
    listenerUpdateQueueComplete(state, action) {
      const { tags } = action.payload;
      tags?.forEach((tag) => {
        state.byIds[tag._id] && (state.byIds[tag._id].tag = tag);
      });
    },
    // Set tag panel visibility
    panelVisibleSet(state, action) {
      const { panelVisible } = action.payload;
      state.panelVisible = panelVisible;
    },
    // Sort all tags by name
    sort(state) {
      state.allIds.sort((a2, b2) => {
        const tagA = state.byIds[a2].tag.name.current, tagB = state.byIds[b2].tag.name.current;
        return tagA < tagB ? -1 : tagA > tagB ? 1 : 0;
      });
    },
    updateComplete(state, action) {
      const { tag } = action.payload;
      state.byIds[tag._id].tag = tag, state.byIds[tag._id].updating = false;
    },
    updateError(state, action) {
      const { error, tag } = action.payload, tagId = tag?._id;
      state.byIds[tagId].error = error, state.byIds[tagId].updating = false;
    },
    updateRequest(state, action) {
      const { tag } = action.payload;
      state.byIds[tag?._id].updating = true;
    }
  }
});
var tagsCreateEpic = (action$, state$, { client }) => action$.pipe(
  filter(tagsSlice.actions.createRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { assetId, name } = action.payload;
    return of(action).pipe(
      debugThrottle(state.debug.badConnection),
      checkTagName(client, name),
      mergeMap(
        () => client.observable.create({
          _type: TAG_DOCUMENT_NAME,
          name: {
            _type: "slug",
            current: name
          }
        })
      ),
      mergeMap((result) => of(tagsSlice.actions.createComplete({ assetId, tag: result }))),
      catchError(
        (error) => of(
          tagsSlice.actions.createError({
            error: {
              message: error?.message || "Internal error",
              statusCode: error?.statusCode || 500
            },
            name
          })
        )
      )
    );
  })
);
var tagsDeleteEpic = (action$, state$, { client }) => action$.pipe(
  filter(tagsSlice.actions.deleteRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { tag } = action.payload;
    return of(action).pipe(
      // Optionally throttle
      debugThrottle(state.debug.badConnection),
      // Fetch assets which reference this tag
      mergeMap(
        () => client.observable.fetch(
          groq`*[
              _type in ["sanity.fileAsset", "sanity.imageAsset"]
              && references(*[_type == "media.tag" && name.current == $tagName]._id)
            ] {
              _id,
              _rev,
              opt
            }`,
          { tagName: tag.name.current }
        )
      ),
      // Create transaction which remove tag references from all matched assets and delete tag
      mergeMap((assets) => {
        const transaction = assets.map((asset) => ({
          id: asset._id,
          patch: {
            // this will cause the transaction to fail if the document has been modified since it was fetched.
            ifRevisionID: asset._rev,
            unset: [`opt.media.tags[_ref == "${tag._id}"]`]
          }
        })).reduce(
          (tx, patch) => tx.patch(patch.id, patch.patch),
          client.transaction()
        );
        return transaction.delete(tag._id), from(transaction.commit());
      }),
      // Dispatch complete action
      mergeMap(() => of(tagsSlice.actions.deleteComplete({ tagId: tag._id }))),
      catchError(
        (error) => of(
          tagsSlice.actions.deleteError({
            error: {
              message: error?.message || "Internal error",
              statusCode: error?.statusCode || 500
            },
            tag
          })
        )
      )
    );
  })
);
var tagsFetchEpic = (action$, state$, { client }) => action$.pipe(
  filter(tagsSlice.actions.fetchRequest.match),
  withLatestFrom(state$),
  switchMap(([action, state]) => {
    const { query } = action.payload;
    return of(action).pipe(
      // Optionally throttle
      debugThrottle(state.debug.badConnection),
      // Fetch tags
      mergeMap(
        () => client.observable.fetch(query)
      ),
      // Dispatch complete action
      mergeMap((result) => {
        const { items } = result;
        return of(tagsSlice.actions.fetchComplete({ tags: items }));
      }),
      catchError(
        (error) => of(
          tagsSlice.actions.fetchError({
            error: {
              message: error?.message || "Internal error",
              statusCode: error?.statusCode || 500
            }
          })
        )
      )
    );
  })
);
var tagsListenerCreateQueueEpic = (action$) => action$.pipe(
  filter(tagsSlice.actions.listenerCreateQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const tags = actions?.map((action) => action.payload.tag);
    return of(tagsSlice.actions.listenerCreateQueueComplete({ tags }));
  })
);
var tagsListenerDeleteQueueEpic = (action$) => action$.pipe(
  filter(tagsSlice.actions.listenerDeleteQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const tagIds = actions?.map((action) => action.payload.tagId);
    return of(tagsSlice.actions.listenerDeleteQueueComplete({ tagIds }));
  })
);
var tagsListenerUpdateQueueEpic = (action$) => action$.pipe(
  filter(tagsSlice.actions.listenerUpdateQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const tags = actions?.map((action) => action.payload.tag);
    return of(tagsSlice.actions.listenerUpdateQueueComplete({ tags }));
  })
);
var tagsSortEpic = (action$) => action$.pipe(
  ofType(
    tagsSlice.actions.listenerCreateQueueComplete.type,
    tagsSlice.actions.listenerUpdateQueueComplete.type
  ),
  bufferTime(1e3),
  filter((actions) => actions.length > 0),
  mergeMap(() => of(tagsSlice.actions.sort()))
);
var tagsUpdateEpic = (action$, state$, { client }) => action$.pipe(
  filter(tagsSlice.actions.updateRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { closeDialogId, formData, tag } = action.payload;
    return of(action).pipe(
      // Optionally throttle
      debugThrottle(state.debug.badConnection),
      // Check if tag name is available, throw early if not
      checkTagName(client, formData?.name?.current),
      // Patch document (Update tag)
      mergeMap(
        () => from(
          client.patch(tag._id).set({ name: { _type: "slug", current: formData?.name.current } }).commit()
        )
      ),
      // Dispatch complete action
      mergeMap((updatedTag) => of(
        tagsSlice.actions.updateComplete({
          closeDialogId,
          tag: updatedTag
        })
      )),
      catchError(
        (error) => of(
          tagsSlice.actions.updateError({
            error: {
              message: error?.message || "Internal error",
              statusCode: error?.statusCode || 500
            },
            tag
          })
        )
      )
    );
  })
);
var selectTagsByIds = (state) => state.tags.byIds;
var selectTagsAllIds = (state) => state.tags.allIds;
var selectTags = createSelector(
  [selectTagsByIds, selectTagsAllIds],
  (byIds, allIds) => allIds.map((id) => byIds[id])
);
var selectTagById = createSelector(
  [selectTagsByIds, (_state, tagId) => tagId],
  (byIds, tagId) => byIds[tagId]
);
var selectTagSelectOptions = (asset) => (state) => {
  const tags = asset?.opt?.media?.tags?.reduce((acc, v2) => {
    const tagItem = state.tags.byIds[v2._ref];
    return tagItem?.tag && acc.push(tagItem), acc;
  }, []);
  return tags && tags?.length > 0 ? getTagSelectOptions(tags) : null;
};
var tagsActions = { ...tagsSlice.actions };
var tagsReducer = tagsSlice.reducer;
var initialState$6 = {
  facets: [],
  query: ""
};
var searchSlice = createSlice({
  name: "search",
  initialState: initialState$6,
  reducers: {
    // Add search facet
    facetsAdd(state, action) {
      state.facets.push({ ...action.payload.facet, id: v4_default() });
    },
    // Clear all search facets
    facetsClear(state) {
      state.facets = [];
    },
    // Remove search facet by name
    facetsRemoveByName(state, action) {
      state.facets = state.facets.filter((facet) => facet.name !== action.payload.facetName);
    },
    // Remove search facet by name
    facetsRemoveByTag(state, action) {
      state.facets = state.facets.filter(
        (facet) => !(facet.name === "tag" && facet.type === "searchable" && (facet.operatorType === "references" || facet.operatorType === "doesNotReference") && facet.value?.value === action.payload.tagId)
      );
    },
    // Remove search facet by name
    facetsRemoveById(state, action) {
      state.facets = state.facets.filter((facet) => facet.id !== action.payload.facetId);
    },
    // Update an existing search facet
    facetsUpdate(state, action) {
      const { modifier, name, operatorType, value } = action.payload, facet = state.facets.find((f2) => f2.name === name);
      facet && (facet.type === "number" && modifier && (facet.modifier = modifier), operatorType && (facet.operatorType = operatorType), typeof value < "u" && (facet.value = value), state.facets = state.facets.filter((f2) => f2.name !== facet.name || f2.id === facet.id));
    },
    // Update an existing search facet
    facetsUpdateById(state, action) {
      const { modifier, id, operatorType, value } = action.payload;
      state.facets.forEach((facet, index2) => {
        facet.id === id && (facet.type === "number" && modifier && (facet.modifier = modifier), operatorType && (facet.operatorType = operatorType), typeof value < "u" && (state.facets[index2].value = value));
      });
    },
    // Update existing search query
    querySet(state, action) {
      state.query = action.payload?.searchQuery;
    }
  }
});
var searchFacetTagUpdateEpic = (action$, state$) => action$.pipe(
  filter(tagsActions.updateComplete.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { tag } = action.payload, currentSearchFacetTag = state.search.facets?.find((facet) => facet.name === "tag"), tagItem = state.tags.byIds[tag._id];
    return currentSearchFacetTag?.type === "searchable" && currentSearchFacetTag.value?.value === tag._id ? of(
      searchSlice.actions.facetsUpdate({
        name: "tag",
        value: {
          label: tagItem?.tag?.name?.current,
          value: tagItem?.tag?._id
        }
      })
    ) : EMPTY;
  })
);
var selectIsSearchFacetTag = createSelector(
  [
    (state) => state.search.facets,
    (_state, tagId) => tagId
  ],
  (searchFacets, tagId) => searchFacets.some(
    (facet) => facet.name === "tag" && facet.type === "searchable" && (facet.operatorType === "references" || facet.operatorType === "doesNotReference") && facet.value?.value === tagId
  )
);
var searchActions = { ...searchSlice.actions };
var searchReducer = searchSlice.reducer;
var UPLOADS_ACTIONS = {
  uploadComplete: createAction(
    "uploads/uploadComplete",
    function({ asset }) {
      return {
        payload: { asset }
      };
    }
  )
};
var defaultOrder = ORDER_OPTIONS[0];
var initialState$5 = {
  allIds: [],
  assetTypes: [],
  byIds: {},
  fetchCount: -1,
  fetching: false,
  fetchingError: void 0,
  lastPicked: void 0,
  order: {
    direction: defaultOrder.direction,
    field: defaultOrder.field,
    title: getOrderTitle(defaultOrder.field, defaultOrder.direction)
  },
  pageIndex: 0,
  pageSize: 100,
  // totalCount: -1,
  view: "grid"
};
var assetsSlice = createSlice({
  name: "assets",
  initialState: initialState$5,
  extraReducers: (builder) => {
    builder.addCase(UPLOADS_ACTIONS.uploadComplete, (state, action) => {
      const { asset } = action.payload;
      state.byIds[asset._id] = {
        _type: "asset",
        asset,
        picked: false,
        updating: false
      };
    }).addCase(ASSETS_ACTIONS.tagsAddComplete, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = false;
      });
    }).addCase(ASSETS_ACTIONS.tagsAddError, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = false;
      });
    }).addCase(ASSETS_ACTIONS.tagsAddRequest, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = true;
      });
    }).addCase(ASSETS_ACTIONS.tagsRemoveComplete, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = false;
      });
    }).addCase(ASSETS_ACTIONS.tagsRemoveError, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = false;
      });
    }).addCase(ASSETS_ACTIONS.tagsRemoveRequest, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = true;
      });
    });
  },
  reducers: {
    // Clear asset order
    clear(state) {
      state.allIds = [];
    },
    // Remove assets and update page index
    deleteComplete(state, action) {
      const { assetIds } = action.payload;
      assetIds?.forEach((id) => {
        const deleteIndex = state.allIds.indexOf(id);
        deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), delete state.byIds[id];
      }), state.pageIndex = Math.floor(state.allIds.length / state.pageSize) - 1;
    },
    deleteError(state, action) {
      const { assetIds, error } = action.payload, itemErrors = error?.response?.body?.error?.items?.map(
        (item) => item.error
      );
      assetIds?.forEach((id) => {
        state.byIds[id].updating = false;
      }), itemErrors?.forEach((item) => {
        state.byIds[item.id].error = item.description;
      });
    },
    deleteRequest(state, action) {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset?._id].updating = true;
      }), Object.keys(state.byIds).forEach((key2) => {
        delete state.byIds[key2].error;
      });
    },
    fetchComplete(state, action) {
      const assets = action.payload?.assets || [];
      assets && assets.forEach((asset) => {
        state.allIds.includes(asset._id) || state.allIds.push(asset._id), state.byIds[asset._id] = {
          _type: "asset",
          asset,
          picked: false,
          updating: false
        };
      }), state.fetching = false, state.fetchCount = assets.length || 0, delete state.fetchingError;
    },
    fetchError(state, action) {
      const error = action.payload;
      state.fetching = false, state.fetchingError = error;
    },
    fetchRequest: {
      reducer: (state, _action) => {
        state.fetching = true, delete state.fetchingError;
      },
      prepare: ({
        params = {},
        queryFilter,
        selector = "",
        sort = groq`order(_updatedAt desc)`
      }) => {
        const query = groq`
          {
            "items": *[${queryFilter}] {
              _id,
              _type,
              _createdAt,
              _updatedAt,
              altText,
              creditLine,
              description,
              extension,
              metadata {
                dimensions,
                exif,
                isOpaque,
              },
              mimeType,
              opt {
                media
              },
              originalFilename,
              size,
              source {
                name
              },
              title,
              url
            } ${sort || selector ? "|" : ""} ${sort} ${selector},
          }
        `;
        return { payload: { params, query } };
      }
    },
    insertUploads(state, action) {
      const { results } = action.payload;
      Object.entries(results).forEach(([hash2, assetId]) => {
        assetId && !state.allIds.includes(hash2) && state.allIds.push(assetId);
      });
    },
    listenerCreateQueue(_state, _action) {
    },
    listenerCreateQueueComplete(state, action) {
      const { assets } = action.payload;
      assets?.forEach((asset) => {
        state.byIds[asset?._id]?.asset && (state.byIds[asset._id].asset = asset);
      });
    },
    listenerDeleteQueue(_state, _action) {
    },
    listenerDeleteQueueComplete(state, action) {
      const { assetIds } = action.payload;
      assetIds?.forEach((assetId) => {
        const deleteIndex = state.allIds.indexOf(assetId);
        deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), delete state.byIds[assetId];
      });
    },
    listenerUpdateQueue(_state, _action) {
    },
    listenerUpdateQueueComplete(state, action) {
      const { assets } = action.payload;
      assets?.forEach((asset) => {
        state.byIds[asset?._id]?.asset && (state.byIds[asset._id].asset = asset);
      });
    },
    loadNextPage() {
    },
    loadPageIndex(state, action) {
      state.pageIndex = action.payload.pageIndex;
    },
    orderSet(state, action) {
      state.order = action.payload?.order, state.pageIndex = 0;
    },
    pick(state, action) {
      const { assetId, picked } = action.payload;
      state.byIds[assetId].picked = picked, state.lastPicked = picked ? assetId : void 0;
    },
    pickAll(state) {
      state.allIds.forEach((id) => {
        state.byIds[id].picked = true;
      });
    },
    pickClear(state) {
      state.lastPicked = void 0, Object.values(state.byIds).forEach((asset) => {
        state.byIds[asset.asset._id].picked = false;
      });
    },
    pickRange(state, action) {
      const startIndex = state.allIds.findIndex((id) => id === action.payload.startId), endIndex = state.allIds.findIndex((id) => id === action.payload.endId), indices = [startIndex, endIndex].sort((a2, b2) => a2 - b2);
      state.allIds.slice(indices[0], indices[1] + 1).forEach((key2) => {
        state.byIds[key2].picked = true;
      }), state.lastPicked = state.allIds[endIndex];
    },
    sort(state) {
      state.allIds.sort((a2, b2) => {
        const tagA = state.byIds[a2].asset[state.order.field], tagB = state.byIds[b2].asset[state.order.field];
        return tagA < tagB ? state.order.direction === "asc" ? -1 : 1 : tagA > tagB ? state.order.direction === "asc" ? 1 : -1 : 0;
      });
    },
    updateComplete(state, action) {
      const { asset } = action.payload;
      state.byIds[asset._id].updating = false, state.byIds[asset._id].asset = asset;
    },
    updateError(state, action) {
      const { asset, error } = action.payload, assetId = asset?._id;
      state.byIds[assetId].error = error.message, state.byIds[assetId].updating = false;
    },
    updateRequest(state, action) {
      const assetId = action.payload?.asset?._id;
      state.byIds[assetId].updating = true;
    },
    viewSet(state, action) {
      state.view = action.payload?.view;
    }
  }
});
var assetsDeleteEpic = (action$, _state$, { client }) => action$.pipe(
  filter(assetsActions.deleteRequest.match),
  mergeMap((action) => {
    const { assets } = action.payload, assetIds = assets.map((asset) => asset._id);
    return of(assets).pipe(
      mergeMap(
        () => client.observable.delete({
          query: groq`*[_id in ${JSON.stringify(assetIds)}]`
        })
      ),
      mergeMap(() => of(assetsActions.deleteComplete({ assetIds }))),
      catchError((error) => of(assetsActions.deleteError({ assetIds, error })))
    );
  })
);
var assetsFetchEpic = (action$, state$, { client }) => action$.pipe(
  filter(assetsActions.fetchRequest.match),
  withLatestFrom(state$),
  switchMap(([action, state]) => {
    const params = action.payload?.params, query = action.payload?.query;
    return of(action).pipe(
      debugThrottle(state.debug.badConnection),
      mergeMap(
        () => client.observable.fetch(query, params)
      ),
      mergeMap((result) => {
        const {
          items
          // totalCount
        } = result;
        return of(assetsActions.fetchComplete({ assets: items }));
      }),
      catchError(
        (error) => of(
          assetsActions.fetchError({
            message: error?.message || "Internal error",
            statusCode: error?.statusCode || 500
          })
        )
      )
    );
  })
);
var assetsFetchPageIndexEpic = (action$, state$) => action$.pipe(
  filter(assetsActions.loadPageIndex.match),
  withLatestFrom(state$),
  switchMap(([action, state]) => {
    const pageSize = state.assets.pageSize, start = action.payload.pageIndex * pageSize, end = start + pageSize, documentId = state?.selected.document?._id, documentAssetIds = state?.selected?.documentAssetIds, constructedFilter = constructFilter({
      assetTypes: state.assets.assetTypes,
      searchFacets: state.search.facets,
      searchQuery: state.search.query
    }), params = {
      ...documentId ? { documentId } : {},
      documentAssetIds
    };
    return of(
      assetsActions.fetchRequest({
        params,
        queryFilter: constructedFilter,
        selector: groq`[${start}...${end}]`,
        sort: groq`order(${state.assets?.order?.field} ${state.assets?.order?.direction})`
      })
    );
  })
);
var assetsFetchNextPageEpic = (action$, state$) => action$.pipe(
  filter(assetsActions.loadNextPage.match),
  withLatestFrom(state$),
  switchMap(
    ([_action, state]) => of(assetsActions.loadPageIndex({ pageIndex: state.assets.pageIndex + 1 }))
  )
);
var assetsFetchAfterDeleteAllEpic = (action$, state$) => action$.pipe(
  filter(assetsActions.deleteComplete.match),
  withLatestFrom(state$),
  switchMap(([_action, state]) => {
    if (state.assets.allIds.length === 0) {
      const nextPageIndex = Math.floor(state.assets.allIds.length / state.assets.pageSize);
      return of(assetsActions.loadPageIndex({ pageIndex: nextPageIndex }));
    }
    return EMPTY;
  })
);
var filterAssetWithoutTag = (tag) => (asset) => (asset?.asset?.opt?.media?.tags?.findIndex((t3) => t3._ref === tag?._id) ?? -1) < 0;
var patchOperationTagAppend = ({ tag }) => (patch) => patch.setIfMissing({ opt: {} }).setIfMissing({ "opt.media": {} }).setIfMissing({ "opt.media.tags": [] }).append("opt.media.tags", [{ _key: nanoid(), _ref: tag?._id, _type: "reference", _weak: true }]);
var patchOperationTagUnset = ({ asset, tag }) => (patch) => patch.ifRevisionId(asset?.asset?._rev).unset([`opt.media.tags[_ref == "${tag._id}"]`]);
var assetsOrderSetEpic = (action$) => action$.pipe(
  filter(assetsActions.orderSet.match),
  mergeMap(() => of(
    assetsActions.clear(),
    //
    assetsActions.loadPageIndex({ pageIndex: 0 })
  ))
);
var assetsSearchEpic = (action$) => action$.pipe(
  ofType(
    searchActions.facetsAdd.type,
    searchActions.facetsClear.type,
    searchActions.facetsRemoveById.type,
    searchActions.facetsRemoveByName.type,
    searchActions.facetsRemoveByTag.type,
    searchActions.facetsUpdate.type,
    searchActions.facetsUpdateById.type,
    searchActions.querySet.type
  ),
  debounceTime(400),
  mergeMap(() => of(
    assetsActions.clear(),
    //
    assetsActions.loadPageIndex({ pageIndex: 0 })
  ))
);
var assetsListenerCreateQueueEpic = (action$) => action$.pipe(
  filter(assetsActions.listenerCreateQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const assets = actions?.map((action) => action.payload.asset);
    return of(assetsActions.listenerCreateQueueComplete({ assets }));
  })
);
var assetsListenerDeleteQueueEpic = (action$) => action$.pipe(
  filter(assetsActions.listenerDeleteQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const assetIds = actions?.map((action) => action.payload.assetId);
    return of(assetsActions.listenerDeleteQueueComplete({ assetIds }));
  })
);
var assetsListenerUpdateQueueEpic = (action$) => action$.pipe(
  filter(assetsActions.listenerUpdateQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const assets = actions?.map((action) => action.payload.asset);
    return of(assetsActions.listenerUpdateQueueComplete({ assets }));
  })
);
var assetsSortEpic = (action$) => action$.pipe(
  ofType(
    assetsActions.insertUploads.type,
    assetsActions.listenerUpdateQueueComplete.type,
    assetsActions.updateComplete.type
  ),
  mergeMap(() => of(assetsActions.sort()))
);
var assetsTagsAddEpic = (action$, state$, { client }) => action$.pipe(
  filter(ASSETS_ACTIONS.tagsAddRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { assets, tag } = action.payload;
    return of(action).pipe(
      // Optionally throttle
      debugThrottle(state.debug.badConnection),
      // Add tag references to all picked assets
      mergeMap(() => {
        const transaction = (selectAssetsPicked(state)?.filter(filterAssetWithoutTag(tag))).reduce(
          (tx, pickedAsset) => tx.patch(pickedAsset?.asset?._id, patchOperationTagAppend({ tag })),
          client.transaction()
        );
        return from(transaction.commit());
      }),
      // Dispatch complete action
      mergeMap(() => of(ASSETS_ACTIONS.tagsAddComplete({ assets, tag }))),
      catchError(
        (error) => of(
          ASSETS_ACTIONS.tagsAddError({
            assets,
            error: {
              message: error?.message || "Internal error",
              statusCode: error?.statusCode || 500
            },
            tag
          })
        )
      )
    );
  })
);
var assetsTagsRemoveEpic = (action$, state$, { client }) => action$.pipe(
  filter(ASSETS_ACTIONS.tagsRemoveRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { assets, tag } = action.payload;
    return of(action).pipe(
      // Optionally throttle
      debugThrottle(state.debug.badConnection),
      // Remove tag references from all picked assets
      mergeMap(() => {
        const transaction = selectAssetsPicked(state).reduce(
          (tx, pickedAsset) => tx.patch(pickedAsset?.asset?._id, patchOperationTagUnset({ asset: pickedAsset, tag })),
          client.transaction()
        );
        return from(transaction.commit());
      }),
      // Dispatch complete action
      mergeMap(() => of(ASSETS_ACTIONS.tagsRemoveComplete({ assets, tag }))),
      catchError(
        (error) => of(
          ASSETS_ACTIONS.tagsRemoveError({
            assets,
            error: {
              message: error?.message || "Internal error",
              statusCode: error?.statusCode || 500
            },
            tag
          })
        )
      )
    );
  })
);
var assetsUnpickEpic = (action$) => action$.pipe(
  ofType(
    assetsActions.orderSet.type,
    assetsActions.viewSet.type,
    searchActions.facetsAdd.type,
    searchActions.facetsClear.type,
    searchActions.facetsRemoveById.type,
    searchActions.facetsRemoveByName.type,
    searchActions.facetsRemoveByTag.type,
    searchActions.facetsUpdate.type,
    searchActions.facetsUpdateById.type,
    searchActions.querySet.type
  ),
  mergeMap(() => of(assetsActions.pickClear()))
);
var assetsUpdateEpic = (action$, state$, { client }) => action$.pipe(
  filter(assetsActions.updateRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { asset, closeDialogId, formData } = action.payload;
    return of(action).pipe(
      debugThrottle(state.debug.badConnection),
      mergeMap(
        () => from(
          client.patch(asset._id).setIfMissing({ opt: {} }).setIfMissing({ "opt.media": {} }).set(formData).commit()
        )
      ),
      mergeMap(
        (updatedAsset) => of(
          assetsActions.updateComplete({
            asset: updatedAsset,
            closeDialogId
          })
        )
      ),
      catchError(
        (error) => of(
          assetsActions.updateError({
            asset,
            error: {
              message: error?.message || "Internal error",
              statusCode: error?.statusCode || 500
            }
          })
        )
      )
    );
  })
);
var selectAssetsByIds = (state) => state.assets.byIds;
var selectAssetsAllIds = (state) => state.assets.allIds;
var selectAssetById = createSelector(
  [
    (state) => state.assets.byIds,
    (_state, assetId) => assetId
  ],
  (byIds, assetId) => byIds[assetId] || void 0
);
var selectAssets = createSelector(
  [selectAssetsByIds, selectAssetsAllIds],
  (byIds, allIds) => allIds.map((id) => byIds[id])
);
var selectAssetsLength = createSelector([selectAssets], (assets) => assets.length);
var selectAssetsPicked = createSelector(
  [selectAssets],
  (assets) => assets.filter((item) => item?.picked)
);
var selectAssetsPickedLength = createSelector(
  [selectAssetsPicked],
  (assetsPicked) => assetsPicked.length
);
var assetsActions = { ...assetsSlice.actions };
var assetsReducer = assetsSlice.reducer;
var customScrollbar = lt`
  ::-webkit-scrollbar {
    width: 14px;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 10px;
    border: 4px solid rgba(0, 0, 0, 0);
    background: var(--card-border-color);
    background-clip: padding-box;

    &:hover {
      background: var(--card-muted-fg-color);
      background-clip: padding-box;
    }
  }
`;
var GlobalStyle = ft`
  .media__custom-scrollbar {
    ${customScrollbar}
  }

  // @sanity/ui overrides

  // Custom scrollbar on Box (used in Dialogs)
  div[data-ui="Box"] {
    ${customScrollbar}
  }

  // Dialog background color
  div[data-ui="Dialog"] {
    background-color: rgba(15, 17, 18, 0.9);
  }

`;
var useTypedSelector = useSelector;
var initialState$4 = {
  items: []
};
var dialogSlice = createSlice({
  name: "dialog",
  initialState: initialState$4,
  extraReducers: (builder) => {
    builder.addCase(DIALOG_ACTIONS.showTagCreate, (state) => {
      state.items.push({
        id: "tagCreate",
        type: "tagCreate"
      });
    }), builder.addCase(DIALOG_ACTIONS.showTagEdit, (state, action) => {
      const { tagId } = action.payload;
      state.items.push({
        id: tagId,
        tagId,
        type: "tagEdit"
      });
    });
  },
  reducers: {
    // Clear all dialogs
    clear(state) {
      state.items = [];
    },
    // Add newly created inline tag to assetEdit dialog
    inlineTagCreate(state, action) {
      const { assetId, tag } = action.payload;
      state.items.forEach((item) => {
        item.type === "assetEdit" && item.assetId === assetId && (item.lastCreatedTag = {
          label: tag.name.current,
          value: tag._id
        });
      });
    },
    // Remove inline tags from assetEdit dialog
    inlineTagRemove(state, action) {
      const { tagIds } = action.payload;
      state.items.forEach((item) => {
        item.type === "assetEdit" && (item.lastRemovedTagIds = tagIds);
      });
    },
    // Remove dialog by id
    remove(state, action) {
      const id = action.payload?.id;
      state.items = state.items.filter((item) => item.id !== id);
    },
    showConfirmAssetsTagAdd(state, action) {
      const { assetsPicked, closeDialogId, tag } = action.payload, suffix = `${assetsPicked.length} ${(0, import_pluralize.default)("asset", assetsPicked.length)}`;
      state.items.push({
        closeDialogId,
        confirmCallbackAction: ASSETS_ACTIONS.tagsAddRequest({
          assets: assetsPicked,
          tag
        }),
        confirmText: `Yes, add tag to ${suffix}`,
        title: `Add tag ${tag.name.current} to ${suffix}?`,
        id: "confirm",
        headerTitle: "Confirm tag addition",
        tone: "primary",
        type: "confirm"
      });
    },
    showConfirmAssetsTagRemove(state, action) {
      const { assetsPicked, closeDialogId, tag } = action.payload, suffix = `${assetsPicked.length} ${(0, import_pluralize.default)("asset", assetsPicked.length)}`;
      state.items.push({
        closeDialogId,
        confirmCallbackAction: ASSETS_ACTIONS.tagsRemoveRequest({ assets: assetsPicked, tag }),
        confirmText: `Yes, remove tag from ${suffix}`,
        headerTitle: "Confirm tag removal",
        id: "confirm",
        title: `Remove tag ${tag.name.current} from ${suffix}?`,
        tone: "critical",
        type: "confirm"
      });
    },
    showConfirmDeleteAssets(state, action) {
      const { assets, closeDialogId } = action.payload, suffix = `${assets.length} ${(0, import_pluralize.default)("asset", assets.length)}`;
      state.items.push({
        closeDialogId,
        confirmCallbackAction: assetsActions.deleteRequest({
          assets: assets.map((assetItem) => assetItem.asset)
        }),
        confirmText: `Yes, delete ${suffix}`,
        description: "This operation cannot be reversed. Are you sure you want to continue?",
        title: `Permanently delete ${suffix}?`,
        id: "confirm",
        headerTitle: "Confirm deletion",
        tone: "critical",
        type: "confirm"
      });
    },
    showConfirmDeleteTag(state, action) {
      const { closeDialogId, tag } = action.payload, suffix = "tag";
      state.items.push({
        closeDialogId,
        confirmCallbackAction: tagsActions.deleteRequest({ tag }),
        confirmText: `Yes, delete ${suffix}`,
        description: "This operation cannot be reversed. Are you sure you want to continue?",
        title: `Permanently delete ${suffix}?`,
        id: "confirm",
        headerTitle: "Confirm deletion",
        tone: "critical",
        type: "confirm"
      });
    },
    showAssetEdit(state, action) {
      const { assetId } = action.payload;
      state.items.push({
        assetId,
        id: assetId,
        type: "assetEdit"
      });
    },
    showSearchFacets(state) {
      state.items.push({
        id: "searchFacets",
        type: "searchFacets"
      });
    },
    showTags(state) {
      state.items.push({
        id: "tags",
        type: "tags"
      });
    }
  }
});
var dialogClearOnAssetUpdateEpic = (action$) => action$.pipe(
  ofType(
    assetsActions.deleteComplete.type,
    assetsActions.updateComplete.type,
    tagsActions.deleteComplete.type,
    tagsActions.updateComplete.type
  ),
  filter(
    (action) => !!action?.payload?.closeDialogId
  ),
  mergeMap((action) => {
    const dialogId = action?.payload?.closeDialogId;
    return dialogId ? of(dialogSlice.actions.remove({ id: dialogId })) : EMPTY;
  })
);
var dialogTagCreateEpic = (action$) => action$.pipe(
  filter(tagsActions.createComplete.match),
  mergeMap((action) => {
    const { assetId, tag } = action?.payload;
    return assetId ? of(dialogSlice.actions.inlineTagCreate({ tag, assetId })) : tag._id ? of(dialogSlice.actions.remove({ id: "tagCreate" })) : EMPTY;
  })
);
var dialogTagDeleteEpic = (action$) => action$.pipe(
  filter(tagsActions.listenerDeleteQueueComplete.match),
  mergeMap((action) => {
    const { tagIds } = action?.payload;
    return of(dialogSlice.actions.inlineTagRemove({ tagIds }));
  })
);
var dialogActions = { ...dialogSlice.actions };
var dialogReducer = dialogSlice.reducer;
var ButtonViewGroup = () => {
  const dispatch = useDispatch(), view = useTypedSelector((state) => state.assets.view);
  return (0, import_jsx_runtime4.jsxs)(Inline, { space: 0, style: { whiteSpace: "nowrap" }, children: [
    (0, import_jsx_runtime4.jsx)(
      Button,
      {
        fontSize: 1,
        icon: ThLargeIcon,
        mode: view === "grid" ? "default" : "ghost",
        onClick: () => dispatch(assetsActions.viewSet({ view: "grid" })),
        style: {
          borderBottomRightRadius: 0,
          borderTopRightRadius: 0
        }
      }
    ),
    (0, import_jsx_runtime4.jsx)(
      Button,
      {
        fontSize: 1,
        icon: ThListIcon,
        mode: view === "table" ? "default" : "ghost",
        onClick: () => dispatch(assetsActions.viewSet({ view: "table" })),
        style: {
          borderBottomLeftRadius: 0,
          borderTopLeftRadius: 0
        }
      }
    )
  ] });
};
function usePortalPopoverProps() {
  const portal = usePortal();
  return {
    animate: true,
    constrainSize: true,
    floatingBoundary: portal.element,
    portal: true,
    referenceBoundary: portal.element
  };
}
var OrderSelect = () => {
  const dispatch = useDispatch(), order = useTypedSelector((state) => state.assets.order), popoverProps = usePortalPopoverProps();
  return (0, import_jsx_runtime4.jsx)(
    MenuButton,
    {
      button: (0, import_jsx_runtime4.jsx)(
        Button,
        {
          fontSize: 1,
          icon: SortIcon,
          mode: "bleed",
          padding: 3,
          text: getOrderTitle(order.field, order.direction)
        }
      ),
      id: "order",
      menu: (0, import_jsx_runtime4.jsx)(Menu, { children: ORDER_OPTIONS?.map((item, index2) => {
        if (item) {
          const selected = order.field === item.field && order.direction === item.direction;
          return (0, import_jsx_runtime4.jsx)(
            MenuItem,
            {
              disabled: selected,
              fontSize: 1,
              iconRight: selected,
              onClick: () => dispatch(
                assetsActions.orderSet({
                  order: { direction: item.direction, field: item.field }
                })
              ),
              padding: 2,
              selected,
              space: 4,
              style: { minWidth: "200px" },
              text: getOrderTitle(item.field, item.direction)
            },
            index2
          );
        }
        return (0, import_jsx_runtime4.jsx)(MenuDivider, {}, index2);
      }) }),
      popover: popoverProps
    }
  );
};
var Progress = (props) => {
  const { loading } = props, { animationDuration, isFinished, progress } = useNProgress({
    animationDuration: 300,
    isAnimating: loading
  });
  return (0, import_jsx_runtime4.jsx)(
    Box,
    {
      style: {
        opacity: isFinished ? 0 : 1,
        transition: `opacity ${animationDuration}ms linear`
      },
      children: (0, import_jsx_runtime4.jsx)(
        Box,
        {
          style: {
            height: "1px",
            background: "rgba(255, 255, 255, 0.5)",
            position: "absolute",
            left: 0,
            top: 0,
            transition: `width ${animationDuration}ms linear`,
            width: `${progress * 100}%`
          }
        }
      )
    }
  );
};
var SCHEME_COLORS = {
  bg: {
    dark: hues.gray[950].hex,
    light: hues.gray[50].hex
  },
  bg2: {
    dark: hues.gray[900].hex,
    light: hues.gray[100].hex
  },
  inputEnabledBorder: {
    dark: studioTheme.color.dark.default.input.default.enabled.border,
    light: studioTheme.color.light.default.input.default.enabled.border
  },
  inputHoveredBorder: {
    dark: studioTheme.color.dark.default.input.default.hovered.border,
    light: studioTheme.color.light.default.input.default.hovered.border
  },
  mutedHoveredBg: {
    dark: studioTheme.color.dark.primary.muted.primary.hovered.bg,
    light: studioTheme.color.light.primary.muted.primary.hovered.bg
  },
  mutedHoveredFg: {
    dark: studioTheme.color.dark.primary.muted.primary.hovered.fg,
    light: studioTheme.color.light.primary.muted.primary.hovered.fg
  },
  mutedSelectedBg: {
    dark: studioTheme.color.dark.primary.muted.primary.selected.bg,
    light: studioTheme.color.light.primary.muted.primary.selected.bg
  },
  spotBlue: {
    dark: studioTheme.color.dark.primary.spot.blue,
    light: studioTheme.color.light.primary.spot.blue
  }
};
function getSchemeColor(scheme, colorKey) {
  return SCHEME_COLORS[colorKey]?.[scheme];
}
var Container$1 = dt(Box)(({ $scheme, theme }) => lt`
    background: ${getSchemeColor($scheme, "bg")};
    border-radius: ${rem(theme.sanity.radius[2])};
  `);
var SearchFacet = (props) => {
  const { children, facet } = props, scheme = useColorSchemeValue(), dispatch = useDispatch(), handleClose = () => {
    dispatch(searchActions.facetsRemoveById({ facetId: facet.id }));
  };
  return (0, import_jsx_runtime4.jsx)(Container$1, { padding: [2, 2, 1], $scheme: scheme, children: (0, import_jsx_runtime4.jsxs)(Flex, { align: ["flex-start", "flex-start", "center"], direction: ["column", "column", "row"], children: [
    (0, import_jsx_runtime4.jsx)(Box, { paddingBottom: [3, 3, 0], paddingLeft: 1, paddingRight: 2, paddingTop: [1, 1, 0], children: (0, import_jsx_runtime4.jsx)(
      Label,
      {
        size: 0,
        style: {
          whiteSpace: "nowrap"
        },
        children: facet.title
      }
    ) }),
    (0, import_jsx_runtime4.jsxs)(Flex, { align: "center", children: [
      children,
      (0, import_jsx_runtime4.jsx)(Box, { marginLeft: 1, paddingX: 2, children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 0, children: (0, import_jsx_runtime4.jsx)(CloseIcon, { onClick: handleClose }) }) })
    ] })
  ] }) });
};
var TextInputNumber = (props) => {
  const { onValueChange, value, ...remainingProps } = props;
  return (0, import_jsx_runtime4.jsx)(
    TextInput,
    {
      ...remainingProps,
      onChange: (e2) => {
        const val = e2.target.value;
        (val === "" || /^[0-9\b]+$/.test(val)) && onValueChange(parseInt(val, 10) || "");
      },
      value: value ?? ""
    }
  );
};
var SearchFacetNumber = ({ facet }) => {
  const dispatch = useDispatch(), popoverProps = usePortalPopoverProps(), modifiers = facet?.modifiers, selectedModifier = facet?.modifier ? modifiers?.find((modifier) => modifier.name === facet?.modifier) : modifiers?.[0], handleOperatorItemClick = (operatorType) => {
    dispatch(searchActions.facetsUpdateById({ id: facet.id, operatorType }));
  }, handleModifierClick = (modifier) => {
    dispatch(searchActions.facetsUpdateById({ id: facet.id, modifier: modifier.name }));
  }, handleValueChange = (value) => {
    dispatch(searchActions.facetsUpdateById({ id: facet.id, value }));
  }, selectedOperatorType = facet.operatorType ?? "greaterThan";
  return (0, import_jsx_runtime4.jsxs)(SearchFacet, { facet, children: [
    facet?.operatorTypes && (0, import_jsx_runtime4.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime4.jsx)(
          Button,
          {
            fontSize: 1,
            iconRight: SelectIcon,
            padding: 2,
            text: operators[selectedOperatorType].label
          }
        ),
        id: "operators",
        menu: (0, import_jsx_runtime4.jsx)(Menu, { children: facet.operatorTypes.map((operatorType, index2) => operatorType ? (0, import_jsx_runtime4.jsx)(
          MenuItem,
          {
            disabled: operatorType === selectedOperatorType,
            fontSize: 1,
            onClick: () => handleOperatorItemClick(operatorType),
            padding: 2,
            text: operators[operatorType].label
          },
          operatorType
        ) : (0, import_jsx_runtime4.jsx)(MenuDivider, {}, index2)) }),
        popover: popoverProps
      }
    ),
    (0, import_jsx_runtime4.jsx)(Box, { marginX: 1, style: { maxWidth: "50px" }, children: (0, import_jsx_runtime4.jsx)(
      TextInputNumber,
      {
        fontSize: 1,
        onValueChange: handleValueChange,
        padding: 2,
        radius: 2,
        width: 2,
        value: facet?.value
      }
    ) }),
    modifiers && (0, import_jsx_runtime4.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime4.jsx)(
          Button,
          {
            fontSize: 1,
            iconRight: SelectIcon,
            padding: 2,
            text: selectedModifier?.title
          }
        ),
        id: "modifier",
        menu: (0, import_jsx_runtime4.jsx)(Menu, { children: modifiers.map((modifier) => {
          const selected = modifier.name === facet.modifier;
          return (0, import_jsx_runtime4.jsx)(
            MenuItem,
            {
              disabled: selected,
              fontSize: 1,
              onClick: () => handleModifierClick(modifier),
              padding: 2,
              text: modifier.title
            },
            modifier.name
          );
        }) }),
        popover: popoverProps
      }
    )
  ] });
};
var SearchFacetSelect = ({ facet }) => {
  const dispatch = useDispatch(), popoverProps = usePortalPopoverProps(), options2 = facet?.options, selectedItem = options2?.find((v2) => v2.name === facet?.value), handleListItemClick = (option) => {
    dispatch(searchActions.facetsUpdate({ name: facet.name, value: option.name }));
  }, handleOperatorItemClick = (operatorType) => {
    dispatch(searchActions.facetsUpdate({ name: facet.name, operatorType }));
  }, selectedOperatorType = facet?.operatorType ?? "is";
  return (0, import_jsx_runtime4.jsxs)(SearchFacet, { facet, children: [
    facet?.operatorTypes && (0, import_jsx_runtime4.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime4.jsx)(Box, { marginRight: 1, children: (0, import_jsx_runtime4.jsx)(
          Button,
          {
            fontSize: 1,
            iconRight: SelectIcon,
            padding: 2,
            text: operators[selectedOperatorType].label
          }
        ) }),
        id: "operators",
        menu: (0, import_jsx_runtime4.jsx)(Menu, { children: facet.operatorTypes.map((operatorType, index2) => operatorType ? (0, import_jsx_runtime4.jsx)(
          MenuItem,
          {
            disabled: operatorType === selectedOperatorType,
            fontSize: 1,
            onClick: () => handleOperatorItemClick(operatorType),
            padding: 2,
            text: operators[operatorType].label
          },
          operatorType
        ) : (0, import_jsx_runtime4.jsx)(MenuDivider, {}, index2)) }),
        popover: popoverProps
      }
    ),
    (0, import_jsx_runtime4.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime4.jsx)(Button, { fontSize: 1, iconRight: SelectIcon, padding: 2, text: selectedItem?.title }),
        id: "list",
        menu: (0, import_jsx_runtime4.jsx)(Menu, { children: options2?.map((item, index2) => {
          const selected = item.name === selectedItem?.name;
          return (0, import_jsx_runtime4.jsx)(
            MenuItem,
            {
              disabled: selected,
              fontSize: 1,
              onClick: () => handleListItemClick(options2[index2]),
              padding: 2,
              text: item.title
            },
            item.name
          );
        }) }),
        popover: popoverProps
      }
    )
  ] });
};
var SearchFacetString = ({ facet }) => {
  const dispatch = useDispatch(), popoverProps = usePortalPopoverProps(), handleOperatorItemClick = (operatorType) => {
    dispatch(searchActions.facetsUpdateById({ id: facet.id, operatorType }));
  }, handleChange = (e2) => {
    dispatch(searchActions.facetsUpdateById({ id: facet.id, value: e2.target.value }));
  }, selectedOperatorType = facet.operatorType;
  return (0, import_jsx_runtime4.jsxs)(SearchFacet, { facet, children: [
    facet?.operatorTypes && (0, import_jsx_runtime4.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime4.jsx)(
          Button,
          {
            fontSize: 1,
            iconRight: SelectIcon,
            padding: 2,
            text: operators[selectedOperatorType].label
          }
        ),
        id: "operators",
        menu: (0, import_jsx_runtime4.jsx)(Menu, { children: facet.operatorTypes.map((operatorType, index2) => operatorType ? (0, import_jsx_runtime4.jsx)(
          MenuItem,
          {
            disabled: operatorType === selectedOperatorType,
            fontSize: 1,
            onClick: () => handleOperatorItemClick(operatorType),
            padding: 2,
            text: operators[operatorType].label
          },
          operatorType
        ) : (0, import_jsx_runtime4.jsx)(MenuDivider, {}, index2)) }),
        popover: popoverProps
      }
    ),
    !operators[selectedOperatorType].hideInput && (0, import_jsx_runtime4.jsx)(Box, { marginLeft: 1, style: { maxWidth: "125px" }, children: (0, import_jsx_runtime4.jsx)(
      TextInput,
      {
        fontSize: 1,
        onChange: handleChange,
        padding: 2,
        radius: 2,
        width: 2,
        value: facet?.value
      }
    ) })
  ] });
};
var {
  fonts: {
    text: { sizes: themeTextSizes }
  },
  radius: themeRadius$1,
  space: themeSpace$1
} = studioTheme;
var reactSelectStyles$1 = (scheme) => ({
  control: (styles, { isDisabled, isFocused }) => {
    let boxShadow = "inset 0 0 0 1px var(--card-border-color)";
    return isFocused && (boxShadow = `inset 0 0 0 1px ${getSchemeColor(scheme, "inputEnabledBorder")},
        0 0 0 1px ${getSchemeColor(scheme, "bg2")},
        0 0 0 3px var(--card-focus-ring-color) !important`), {
      ...styles,
      backgroundColor: "var(--card-bg-color)",
      color: "inherit",
      border: "none",
      borderRadius: themeRadius$1[2],
      boxShadow,
      fontSize: themeTextSizes[1].fontSize,
      minHeight: "25px",
      opacity: isDisabled ? 0.5 : "inherit",
      outline: "none",
      transition: "none",
      "&:hover": {
        boxShadow: `inset 0 0 0 1px ${getSchemeColor(scheme, "inputHoveredBorder")}`
      }
    };
  },
  input: (styles) => ({
    ...styles,
    color: "var(--card-fg-color)",
    fontFamily: studioTheme.fonts.text.family,
    fontSize: themeTextSizes[1].fontSize,
    marginLeft: rem(themeSpace$1[2])
  }),
  menuList: (styles) => ({
    ...styles,
    padding: 0
  }),
  noOptionsMessage: (styles) => ({
    ...styles,
    fontFamily: studioTheme.fonts.text.family,
    fontSize: themeTextSizes[1].fontSize,
    lineHeight: "1em"
  }),
  option: (styles, { isFocused }) => ({
    ...styles,
    backgroundColor: isFocused ? getSchemeColor(scheme, "spotBlue") : "transparent",
    borderRadius: themeRadius$1[2],
    color: isFocused ? getSchemeColor(scheme, "bg") : "inherit",
    fontSize: themeTextSizes[1].fontSize,
    lineHeight: "1em",
    margin: 0,
    padding: rem(themeSpace$1[1]),
    "&:hover": {
      backgroundColor: getSchemeColor(scheme, "spotBlue"),
      color: getSchemeColor(scheme, "bg")
    }
  }),
  placeholder: (styles) => ({
    ...styles,
    fontSize: themeTextSizes[1].fontSize,
    marginLeft: rem(themeSpace$1[2]),
    paddingLeft: 0
  }),
  singleValue: (styles) => ({
    ...styles,
    alignItems: "center",
    display: "inline-flex",
    height: "100%",
    marginLeft: rem(themeSpace$1[2])
  }),
  valueContainer: (styles) => ({
    ...styles,
    margin: 0,
    padding: 0
  })
});
var ClearIndicator3 = (props) => (0, import_jsx_runtime4.jsx)(components.ClearIndicator, { ...props, children: (0, import_jsx_runtime4.jsx)(
  Box,
  {
    paddingRight: 1,
    style: {
      transform: "scale(0.85)"
    },
    children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 0, children: (0, import_jsx_runtime4.jsx)(CloseIcon, {}) })
  }
) });
var Menu$12 = (props) => (0, import_jsx_runtime4.jsx)(components.Menu, { ...props, children: (0, import_jsx_runtime4.jsx)(Card, { radius: 1, shadow: 2, children: props.children }) });
var MenuList$1 = (props) => {
  const { children } = props, MAX_ROWS = 5, OPTION_HEIGHT = 33;
  if (Array.isArray(children)) {
    const height = children.length > MAX_ROWS ? OPTION_HEIGHT * MAX_ROWS : children.length * OPTION_HEIGHT;
    return (0, import_jsx_runtime4.jsx)(
      qr,
      {
        className: "media__custom-scrollbar",
        itemContent: (index2) => {
          const item = children[index2];
          return (0, import_jsx_runtime4.jsx)(Option$12, { ...item.props });
        },
        style: { height },
        totalCount: children.length
      }
    );
  }
  return (0, import_jsx_runtime4.jsx)(components.MenuList, { ...props, children });
};
var NoOptionsMessage3 = (props) => (0, import_jsx_runtime4.jsx)(components.NoOptionsMessage, { ...props, children: props.children });
var Option$12 = (props) => (0, import_jsx_runtime4.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime4.jsx)(components.Option, { ...props, children: (0, import_jsx_runtime4.jsx)(Box, { paddingY: 1, children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, style: { color: "inherit" }, textOverflow: "ellipsis", children: props.children }) }) }) });
var SingleValue3 = (props) => (0, import_jsx_runtime4.jsx)(components.SingleValue, { ...props, children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, textOverflow: "ellipsis", children: props.children }) });
var reactSelectComponents$1 = {
  ClearIndicator: ClearIndicator3,
  DropdownIndicator: null,
  IndicatorSeparator: null,
  Menu: Menu$12,
  MenuList: MenuList$1,
  NoOptionsMessage: NoOptionsMessage3,
  Option: Option$12,
  SingleValue: SingleValue3
};
var SearchFacetTags = ({ facet }) => {
  const scheme = useColorSchemeValue(), dispatch = useDispatch(), tags = useTypedSelector((state) => selectTags(state)), tagsFetching = useTypedSelector((state) => state.tags.fetching), allTagOptions = getTagSelectOptions(tags), popoverProps = usePortalPopoverProps(), handleChange = (option) => {
    dispatch(
      searchActions.facetsUpdateById({
        id: facet.id,
        value: option
      })
    );
  }, handleOperatorItemClick = (operatorType) => {
    dispatch(
      searchActions.facetsUpdateById({
        id: facet.id,
        operatorType
      })
    );
  }, selectedOperatorType = facet.operatorType;
  return (0, import_jsx_runtime4.jsxs)(SearchFacet, { facet, children: [
    facet?.operatorTypes && (0, import_jsx_runtime4.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime4.jsx)(
          Button,
          {
            fontSize: 1,
            iconRight: SelectIcon,
            padding: 2,
            text: operators[selectedOperatorType].label
          }
        ),
        id: "operators",
        menu: (0, import_jsx_runtime4.jsx)(Menu, { children: facet.operatorTypes.map((operatorType, index2) => operatorType ? (0, import_jsx_runtime4.jsx)(
          MenuItem,
          {
            disabled: operatorType === selectedOperatorType,
            fontSize: 1,
            onClick: () => handleOperatorItemClick(operatorType),
            padding: 2,
            space: 4,
            style: { minWidth: "150px" },
            text: operators[operatorType].label
          },
          operatorType
        ) : (0, import_jsx_runtime4.jsx)(MenuDivider, {}, index2)) }),
        popover: popoverProps
      }
    ),
    !operators[selectedOperatorType].hideInput && (0, import_jsx_runtime4.jsx)(Box, { marginX: 1, style: { width: "160px" }, children: (0, import_jsx_runtime4.jsx)(
      StateManagedSelect$1,
      {
        components: reactSelectComponents$1,
        instanceId: "facet-searchable",
        isClearable: true,
        isDisabled: tagsFetching,
        isSearchable: true,
        name: "tags",
        noOptionsMessage: () => "No tags",
        onChange: (value) => handleChange(value),
        options: allTagOptions,
        placeholder: tagsFetching ? "Loading..." : "Select...",
        styles: reactSelectStyles$1(scheme),
        value: facet?.value
      }
    ) })
  ] });
};
var StackContainer = dt(Flex)(({ theme }) => lt`
    > * {
      margin-bottom: ${rem(theme.sanity.space[2])};
    }
  `);
var SearchFacets = (props) => {
  const { layout = "inline" } = props, searchFacets = useTypedSelector((state) => state.search.facets), Items2 = searchFacets.map((facet) => {
    const key2 = facet.id;
    return facet.type === "number" ? (0, import_jsx_runtime4.jsx)(SearchFacetNumber, { facet }, key2) : facet.type === "searchable" ? (0, import_jsx_runtime4.jsx)(SearchFacetTags, { facet }, key2) : facet.type === "select" ? (0, import_jsx_runtime4.jsx)(SearchFacetSelect, { facet }, key2) : facet.type === "string" ? (0, import_jsx_runtime4.jsx)(SearchFacetString, { facet }, key2) : null;
  });
  if (layout === "inline")
    return searchFacets.length === 0 ? null : (0, import_jsx_runtime4.jsx)(Box, { marginBottom: 2, children: (0, import_jsx_runtime4.jsx)(Inline, { space: 2, children: Items2 }) });
  if (layout === "stack")
    return (0, import_jsx_runtime4.jsx)(StackContainer, { align: "flex-start", direction: "column", children: Items2 });
  throw Error("Invalid layout");
};
var ToolOptionsContext = (0, import_react19.createContext)(null);
var ToolOptionsProvider = ({ options: options2, children }) => {
  const value = (0, import_react19.useMemo)(() => {
    let creditLineExcludeSources;
    return options2?.creditLine?.excludeSources && (creditLineExcludeSources = Array.isArray(options2?.creditLine?.excludeSources) ? options2.creditLine.excludeSources : [options2?.creditLine?.excludeSources]), {
      dropzone: { maxSize: options2?.maximumUploadSize },
      creditLine: {
        enabled: options2?.creditLine?.enabled || false,
        excludeSources: creditLineExcludeSources
      }
    };
  }, [
    options2?.creditLine?.enabled,
    options2?.creditLine?.excludeSources,
    options2?.maximumUploadSize
  ]);
  return (0, import_jsx_runtime4.jsx)(ToolOptionsContext.Provider, { value, children });
};
var useToolOptions = () => {
  const context = (0, import_react19.useContext)(ToolOptionsContext);
  if (!context)
    throw new Error("useToolOptions must be used within an ToolOptionsProvider");
  return context;
};
var SearchFacetsControl = () => {
  const dispatch = useDispatch(), assetTypes = useTypedSelector((state) => state.assets.assetTypes), searchFacets = useTypedSelector((state) => state.search.facets), selectedDocument = useTypedSelector((state) => state.selected.document), popoverProps = usePortalPopoverProps(), { creditLine } = useToolOptions(), isTool = !selectedDocument, filteredFacets = FACETS.filter((facet) => !creditLine?.enabled && facet?.type === "string" && facet?.name === "creditLine" ? false : facet.type === "group" || facet.type === "divider" ? true : isTool ? !facet?.selectOnly : facet.assetTypes.filter(
    (assetType) => assetTypes.includes(assetType)
  ).length > 0).filter((facet, index2, facets) => {
    const previousFacet = facets[index2 - 1];
    return !(facet.type === "divider" && (index2 === 0 || index2 === facets.length - 1) || facet.type === "divider" && previousFacet?.type === "divider");
  }), hasSearchFacets = filteredFacets.length > 0, renderMenuFacets = (facets, level = 0) => (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: facets?.map((facet, index2) => {
    if (facet.type === "divider")
      return (0, import_jsx_runtime4.jsx)(MenuDivider, {}, index2);
    if (facet.type === "group")
      return (0, import_jsx_runtime4.jsx)(MenuGroup, { text: facet.title, title: facet.title, children: renderMenuFacets(facet.facets, level + 1) }, `group-${level}-${index2}`);
    if (facet) {
      const disabled = !facet.operatorTypes && !!searchFacets.find((v2) => v2.name === facet.name);
      return (0, import_jsx_runtime4.jsx)(
        MenuItem,
        {
          disabled,
          fontSize: 1,
          onClick: () => dispatch(searchActions.facetsAdd({ facet })),
          padding: 2,
          text: facet.title
        },
        facet.name
      );
    }
    return null;
  }) });
  return (0, import_jsx_runtime4.jsxs)(Flex, { children: [
    (0, import_jsx_runtime4.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime4.jsx)(
          Button,
          {
            disabled: !hasSearchFacets,
            fontSize: 1,
            icon: AddIcon,
            mode: "bleed",
            space: 2,
            text: "Add filter",
            tone: "primary"
          }
        ),
        id: "facets",
        menu: (0, import_jsx_runtime4.jsx)(Menu, { children: renderMenuFacets(filteredFacets) }),
        popover: {
          ...popoverProps,
          placement: "right-start"
        }
      }
    ),
    searchFacets.length > 0 && (0, import_jsx_runtime4.jsx)(
      Button,
      {
        fontSize: 1,
        mode: "bleed",
        onClick: () => dispatch(searchActions.facetsClear()),
        text: "Clear"
      }
    )
  ] });
};
var TagIcon = () => (0, import_jsx_runtime4.jsxs)(
  "svg",
  {
    "data-sanity-icon": "media__tag",
    fill: "currentColor",
    height: "1em",
    stroke: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 512 512",
    width: "1em",
    children: [
      (0, import_jsx_runtime4.jsx)(
        "path",
        {
          d: "M435.25 48h-122.9a14.46 14.46 0 00-10.2 4.2L56.45 297.9a28.85 28.85 0 000 40.7l117 117a28.85 28.85 0 0040.7 0L459.75 210a14.46 14.46 0 004.2-10.2v-123a28.66 28.66 0 00-28.7-28.8z",
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "32"
        }
      ),
      (0, import_jsx_runtime4.jsx)("path", { d: "M384 160a32 32 0 1132-32 32 32 0 01-32 32z" })
    ]
  }
);
var TextInputSearch = () => {
  const searchQuery = useTypedSelector((state) => state.search.query), dispatch = useDispatch(), handleChange = (e2) => {
    dispatch(searchActions.querySet({ searchQuery: e2.currentTarget.value }));
  }, handleClear = () => {
    dispatch(searchActions.querySet({ searchQuery: "" }));
  };
  return (0, import_jsx_runtime4.jsxs)(Box, { style: { position: "relative" }, children: [
    (0, import_jsx_runtime4.jsx)(
      TextInput,
      {
        fontSize: 1,
        icon: SearchIcon,
        onChange: handleChange,
        placeholder: "Search",
        radius: 2,
        value: searchQuery
      }
    ),
    searchQuery.length > 0 && (0, import_jsx_runtime4.jsx)(
      Flex,
      {
        align: "center",
        justify: "center",
        onClick: handleClear,
        style: {
          cursor: "pointer",
          height: "100%",
          opacity: 0.75,
          position: "absolute",
          right: 0,
          top: 0,
          width: "2em",
          zIndex: 1
          // force stacking context
        },
        children: (0, import_jsx_runtime4.jsx)(CloseIcon, {})
      }
    )
  ] });
};
var Controls = () => {
  const dispatch = useDispatch(), fetching = useTypedSelector((state) => state.assets.fetching), pageIndex = useTypedSelector((state) => state.assets.pageIndex), searchFacets = useTypedSelector((state) => state.search.facets), tagsPanelVisible = useTypedSelector((state) => state.tags.panelVisible), mediaIndex = useMediaIndex(), handleShowSearchFacetDialog = () => {
    dispatch(dialogActions.showSearchFacets());
  }, handleShowTagsDialog = () => {
    dispatch(dialogActions.showTags());
  }, toggleTagsPanelToggle = () => {
    dispatch(tagsActions.panelVisibleSet({ panelVisible: !tagsPanelVisible }));
  };
  return (0, import_jsx_runtime4.jsxs)(
    Box,
    {
      paddingY: 2,
      style: {
        borderBottom: "1px solid var(--card-border-color)",
        zIndex: 2
      },
      children: [
        (0, import_jsx_runtime4.jsx)(Box, { marginBottom: 2, children: (0, import_jsx_runtime4.jsx)(
          Flex,
          {
            align: "flex-start",
            direction: ["column", "column", "column", "column", "row"],
            justify: "space-between",
            children: (0, import_jsx_runtime4.jsxs)(
              Flex,
              {
                flex: 1,
                style: {
                  alignItems: "flex-start",
                  flex: 1,
                  height: "100%",
                  justifyContent: mediaIndex < 2 ? "space-between" : "flex-start",
                  position: "relative",
                  width: "100%"
                },
                children: [
                  (0, import_jsx_runtime4.jsx)(Box, { marginX: 2, style: { minWidth: "200px" }, children: (0, import_jsx_runtime4.jsx)(TextInputSearch, {}) }),
                  (0, import_jsx_runtime4.jsxs)(Box, { display: ["none", "none", "block"], children: [
                    (0, import_jsx_runtime4.jsx)(SearchFacets, {}),
                    (0, import_jsx_runtime4.jsx)(SearchFacetsControl, {})
                  ] }),
                  (0, import_jsx_runtime4.jsx)(Box, { display: ["block", "block", "none"], marginX: 2, children: (0, import_jsx_runtime4.jsxs)(Inline, { space: 2, style: { whiteSpace: "nowrap" }, children: [
                    (0, import_jsx_runtime4.jsx)(
                      Button,
                      {
                        fontSize: 1,
                        mode: "ghost",
                        onClick: handleShowSearchFacetDialog,
                        text: `Filters${searchFacets.length > 0 ? ` (${searchFacets.length})` : ""}`,
                        tone: "primary"
                      }
                    ),
                    (0, import_jsx_runtime4.jsx)(
                      Button,
                      {
                        fontSize: 1,
                        mode: "ghost",
                        onClick: handleShowTagsDialog,
                        text: "Tags",
                        tone: "primary"
                      }
                    )
                  ] }) })
                ]
              }
            )
          }
        ) }),
        (0, import_jsx_runtime4.jsx)(Box, { children: (0, import_jsx_runtime4.jsxs)(Flex, { align: "center", justify: ["space-between"], children: [
          (0, import_jsx_runtime4.jsx)(Box, { marginX: 2, children: (0, import_jsx_runtime4.jsx)(ButtonViewGroup, {}) }),
          (0, import_jsx_runtime4.jsxs)(Flex, { marginX: 2, children: [
            (0, import_jsx_runtime4.jsx)(OrderSelect, {}),
            (0, import_jsx_runtime4.jsx)(Box, { display: ["none", "none", "block"], marginLeft: 2, children: (0, import_jsx_runtime4.jsx)(
              Button,
              {
                fontSize: 1,
                icon: (0, import_jsx_runtime4.jsx)(Box, { style: { transform: "scale(0.75)" }, children: (0, import_jsx_runtime4.jsx)(TagIcon, {}) }),
                onClick: toggleTagsPanelToggle,
                mode: tagsPanelVisible ? "default" : "ghost",
                text: tagsPanelVisible ? "Tags" : ""
              }
            ) })
          ] })
        ] }) }),
        (0, import_jsx_runtime4.jsx)(Progress, { loading: fetching }, pageIndex)
      ]
    }
  );
};
var initialState$3 = {
  badConnection: false,
  enabled: false
};
var debugSlice = createSlice({
  name: "debug",
  initialState: initialState$3,
  reducers: {
    setBadConnection(state, action) {
      state.badConnection = action.payload;
    },
    toggleEnabled(state) {
      state.enabled = !state.enabled;
    }
  }
});
var debugActions = { ...debugSlice.actions };
var debugReducer = debugSlice.reducer;
var DebugControls = () => {
  const dispatch = useDispatch(), badConnection = useTypedSelector((state) => state.debug.badConnection), debugEnabled = useTypedSelector((state) => state.debug.enabled), handleChange = (e2) => {
    const checked = e2.target.checked;
    dispatch(debugActions.setBadConnection(checked));
  };
  return useKeyPress("alt+ctrl+shift+/", () => {
    dispatch(debugActions.toggleEnabled());
  }), debugEnabled ? (0, import_jsx_runtime4.jsx)(
    Box,
    {
      padding: 4,
      style: {
        bottom: 0,
        left: 0,
        pointerEvents: "none",
        position: "fixed",
        width: "100%"
      },
      children: (0, import_jsx_runtime4.jsxs)(Flex, { align: "center", children: [
        (0, import_jsx_runtime4.jsx)(Box, { marginRight: 3, children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime4.jsx)(PlugIcon, {}) }) }),
        (0, import_jsx_runtime4.jsx)(
          Tooltip,
          {
            animate: true,
            content: (0, import_jsx_runtime4.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: badConnection ? "Bad connection: +3000ms & 50% chance to fail" : "No connection throttling" }) }),
            fallbackPlacements: ["right", "left"],
            placement: "bottom",
            portal: true,
            children: (0, import_jsx_runtime4.jsx)(
              Switch,
              {
                checked: badConnection,
                onChange: handleChange,
                style: {
                  pointerEvents: "auto"
                }
              }
            )
          }
        )
      ] })
    }
  ) : null;
};
var tagOptionSchema = objectType({
  label: stringType().trim().min(1, { message: "Label cannot be empty" }),
  value: stringType().trim().min(1, { message: "Value cannot be empty" })
});
var assetFormSchema = objectType({
  altText: stringType().trim().optional(),
  creditLine: stringType().trim().optional(),
  description: stringType().trim().optional(),
  opt: objectType({
    media: objectType({
      tags: arrayType(tagOptionSchema).nullable()
    })
  }),
  originalFilename: stringType().trim().min(1, { message: "Filename cannot be empty" }),
  title: stringType().trim().optional()
});
var tagFormSchema = objectType({
  name: stringType().min(1, { message: "Name cannot be empty" })
});
function getUniqueDocuments(documents) {
  const draftIds = documents.reduce(
    (acc, doc) => doc._id.startsWith("drafts.") ? acc.concat(doc._id.slice(7)) : acc,
    []
  );
  return documents.filter(
    (doc) => !draftIds.includes(doc._id)
  );
}
var imageDprUrl = (asset, options2) => {
  const dpi = typeof window > "u" || !window.devicePixelRatio ? 1 : Math.round(window.devicePixelRatio), imgH = options2?.height ? options2?.height * Math.max(1, dpi) : void 0, imgW = options2.width * Math.max(1, dpi), urlParams = new URLSearchParams();
  return urlParams.append("fit", "max"), urlParams.append("w", imgW.toString()), imgH && urlParams.append("h", imgH.toString()), `${asset.url}?${urlParams.toString()}`;
};
var sanitizeFormData = (formData) => Object.keys(formData).reduce((acc, key2) => {
  const val = formData[key2];
  return typeof val == "object" && val !== null && val.constructor !== Array ? acc[key2] = sanitizeFormData(val) : val === "" || typeof val > "u" || val?.length === 0 ? acc[key2] = null : typeof val == "string" && val ? acc[key2] = formData[key2].trim() : acc[key2] = formData[key2], acc;
}, {});
var isFileAsset = (asset) => asset._type === "sanity.fileAsset";
var isImageAsset = (asset) => asset._type === "sanity.imageAsset";
var getAssetResolution = (asset) => `${asset.metadata.dimensions.width}x${asset.metadata.dimensions.height}px`;
var ButtonAssetCopy = ({ disabled, url }) => {
  const popoverProps = usePortalPopoverProps(), refPopoverTimeout = (0, import_react19.useRef)(null), [popoverVisible, setPopoverVisible] = (0, import_react19.useState)(false), handleClick = () => {
    refPopoverTimeout.current && clearTimeout(refPopoverTimeout.current), setPopoverVisible(true), (0, import_copy_to_clipboard.default)(url), refPopoverTimeout.current = setTimeout(() => {
      setPopoverVisible(false);
    }, 1250);
  };
  return (0, import_react19.useEffect)(() => () => {
    refPopoverTimeout.current && clearTimeout(refPopoverTimeout.current);
  }, []), (0, import_jsx_runtime4.jsx)(
    Popover,
    {
      content: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: "Copied!" }),
      open: popoverVisible,
      padding: 2,
      placement: "top",
      radius: 1,
      ...popoverProps,
      children: (0, import_jsx_runtime4.jsx)(
        Button,
        {
          disabled,
          fontSize: 1,
          icon: ClipboardIcon,
          mode: "ghost",
          onClick: handleClick,
          text: "Copy URL"
        }
      )
    }
  );
};
var Row = ({ label, value }) => (0, import_jsx_runtime4.jsxs)(Flex, { justify: "space-between", children: [
  (0, import_jsx_runtime4.jsx)(
    Text,
    {
      size: 1,
      style: {
        opacity: 0.8,
        width: "40%"
      },
      textOverflow: "ellipsis",
      children: label
    }
  ),
  (0, import_jsx_runtime4.jsx)(
    Text,
    {
      size: 1,
      style: {
        opacity: 0.4,
        textAlign: "right",
        width: "60%"
      },
      textOverflow: "ellipsis",
      children: value
    }
  )
] });
var AssetMetadata = (props) => {
  const { asset, item } = props, exif = asset?.metadata?.exif, handleDownload = () => {
    window.location.href = `${asset.url}?dl=${asset.originalFilename}`;
  };
  return (0, import_jsx_runtime4.jsxs)(Box, { marginTop: 3, children: [
    (0, import_jsx_runtime4.jsx)(Box, { children: (0, import_jsx_runtime4.jsxs)(Stack, { space: 3, children: [
      (0, import_jsx_runtime4.jsx)(Row, { label: "Size", value: filesize(asset?.size, { base: 10, round: 0 }) }),
      (0, import_jsx_runtime4.jsx)(Row, { label: "MIME type", value: asset?.mimeType }),
      (0, import_jsx_runtime4.jsx)(Row, { label: "Extension", value: (asset?.extension).toUpperCase() }),
      isImageAsset(asset) && (0, import_jsx_runtime4.jsx)(Row, { label: "Dimensions", value: getAssetResolution(asset) })
    ] }) }),
    exif && (exif.DateTimeOriginal || exif.FNumber || exif.FocalLength || exif.ExposureTime || exif.ISO) && (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
      (0, import_jsx_runtime4.jsx)(
        Box,
        {
          marginY: 4,
          style: {
            background: "var(--card-border-color)",
            height: "1px",
            width: "100%"
          }
        }
      ),
      (0, import_jsx_runtime4.jsx)(Box, { children: (0, import_jsx_runtime4.jsxs)(Stack, { space: 3, children: [
        exif.ISO && (0, import_jsx_runtime4.jsx)(Row, { label: "ISO", value: exif.ISO }),
        exif.FNumber && (0, import_jsx_runtime4.jsx)(Row, { label: "Aperture", value: `ƒ/${exif.FNumber}` }),
        exif.FocalLength && (0, import_jsx_runtime4.jsx)(Row, { label: "Focal length", value: `${exif.FocalLength}mm` }),
        exif.ExposureTime && (0, import_jsx_runtime4.jsx)(Row, { label: "Exposure time", value: `1/${1 / exif.ExposureTime}` }),
        exif.DateTimeOriginal && (0, import_jsx_runtime4.jsx)(
          Row,
          {
            label: "Original date",
            value: format_default(new Date(exif.DateTimeOriginal), "PPp")
          }
        )
      ] }) })
    ] }),
    (0, import_jsx_runtime4.jsx)(Box, { marginTop: 5, children: (0, import_jsx_runtime4.jsxs)(Inline, { space: 2, children: [
      (0, import_jsx_runtime4.jsx)(
        Button,
        {
          disabled: !item || item?.updating,
          fontSize: 1,
          icon: DownloadIcon,
          mode: "ghost",
          onClick: handleDownload,
          text: "Download"
        }
      ),
      (0, import_jsx_runtime4.jsx)(ButtonAssetCopy, { disabled: !item || item?.updating, url: asset.url })
    ] }) })
  ] });
};
var Dialog2 = (props) => (0, import_jsx_runtime4.jsx)(Dialog, { ...props, style: { position: "fixed" } });
var DocumentList = ({ documents, isLoading }) => {
  const schema = useSchema();
  return isLoading ? (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: "Loading..." }) : documents.length === 0 ? (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: "No documents are referencing this asset" }) : (0, import_jsx_runtime4.jsx)(Card, { flex: 1, marginBottom: 2, padding: 2, radius: 2, shadow: 1, children: (0, import_jsx_runtime4.jsx)(Stack, { space: 2, children: documents?.map((doc) => (0, import_jsx_runtime4.jsx)(ReferringDocument, { doc, schemaType: schema.get(doc._type) }, doc._id)) }) });
};
var ReferringDocument = (props) => {
  const { doc, schemaType } = props, { onClick } = useIntentLink({
    intent: "edit",
    params: { id: doc._id }
  });
  return schemaType ? (0, import_jsx_runtime4.jsx)(Button, { mode: "bleed", onClick, padding: 2, style: { width: "100%" }, children: (0, import_jsx_runtime4.jsx)(Preview$1, { layout: "default", schemaType, value: doc }) }, doc._id) : (0, import_jsx_runtime4.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime4.jsxs)(Text, { size: 1, children: [
    "A document of the unknown type ",
    (0, import_jsx_runtime4.jsx)("em", { children: doc._type })
  ] }) });
};
var Container2 = dt(Box)(({ theme }) => lt`
    text {
      font-family: ${theme.sanity.fonts.text.family} !important;
      font-size: 8px !important;
      font-weight: 500 !important;
    }
  `);
var FileIcon3 = (props) => {
  const { extension, onClick, width } = props;
  return (0, import_jsx_runtime4.jsx)(Flex, { align: "center", justify: "center", onClick, style: { height: "100%" }, children: (0, import_jsx_runtime4.jsx)(Container2, { style: { width }, children: extension ? (0, import_jsx_runtime4.jsx)(
    FileIcon,
    {
      extension,
      ...defaultStyles2[extension]
    }
  ) : (0, import_jsx_runtime4.jsx)(FileIcon, {}) }) });
};
var FileAssetPreview = (props) => {
  const { asset } = props;
  return asset.mimeType.search("audio") === 0 ? (0, import_jsx_runtime4.jsx)(Flex, { align: "center", justify: "center", style: { height: "100%" }, children: (0, import_jsx_runtime4.jsx)("audio", { controls: true, src: asset.url, style: { width: "100%" } }) }) : asset.mimeType.search("video") === 0 ? (0, import_jsx_runtime4.jsx)(
    "video",
    {
      controls: true,
      src: asset.url,
      style: {
        height: "100%",
        width: "100%"
      }
    }
  ) : (0, import_jsx_runtime4.jsx)(FileIcon3, { extension: asset.extension, width: "50%" });
};
var { radius: themeRadius, space: themeSpace } = studioTheme;
var reactSelectStyles = (scheme) => ({
  control: (styles, { isFocused }) => {
    let boxShadow = "inset 0 0 0 1px var(--card-border-color)";
    return isFocused && (boxShadow = `inset 0 0 0 1px ${getSchemeColor(scheme, "inputEnabledBorder")},
        0 0 0 1px var(--card-bg-color),
        0 0 0 3px var(--card-focus-ring-color) !important`), {
      ...styles,
      backgroundColor: "var(--card-bg-color)",
      color: "inherit",
      border: "none",
      borderRadius: themeRadius[1],
      boxShadow,
      margin: 0,
      minHeight: "35px",
      outline: "none",
      padding: rem(themeSpace[1]),
      transition: "none",
      "&:hover": {
        boxShadow: `inset 0 0 0 1px ${getSchemeColor(scheme, "inputHoveredBorder")}`
      }
    };
  },
  indicatorsContainer: (styles, { isDisabled }) => ({
    ...styles,
    opacity: isDisabled ? 0.25 : 1
  }),
  input: (styles) => ({
    ...styles,
    color: "var(--card-fg-color)",
    fontFamily: studioTheme.fonts.text.family,
    marginLeft: rem(themeSpace[2])
  }),
  menuList: (styles) => ({
    ...styles
  }),
  multiValue: (styles, { isDisabled }) => ({
    ...styles,
    backgroundColor: getSchemeColor(scheme, "mutedHoveredBg"),
    borderRadius: themeRadius[2],
    opacity: isDisabled ? 0.5 : 1
  }),
  multiValueLabel: () => ({
    color: getSchemeColor(scheme, "mutedHoveredFg"),
    fontSize: "inherit",
    padding: 0
  }),
  multiValueRemove: (styles) => ({
    ...styles,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 0,
    svg: { color: getSchemeColor(scheme, "mutedHoveredFg") },
    "&:hover": {
      backgroundColor: getSchemeColor(scheme, "mutedSelectedBg")
    }
  }),
  noOptionsMessage: (styles) => ({
    ...styles,
    fontFamily: studioTheme.fonts.text.family,
    lineHeight: "1em"
  }),
  option: (styles, { isFocused }) => ({
    ...styles,
    backgroundColor: isFocused ? getSchemeColor(scheme, "spotBlue") : "transparent",
    borderRadius: themeRadius[2],
    color: isFocused ? getSchemeColor(scheme, "bg") : "inherit",
    padding: `${rem(themeSpace[1])} ${rem(themeSpace[2])}`,
    "&:hover": {
      backgroundColor: getSchemeColor(scheme, "spotBlue"),
      color: getSchemeColor(scheme, "bg")
    }
  }),
  placeholder: (styles) => ({
    ...styles,
    marginLeft: rem(themeSpace[2])
  }),
  valueContainer: (styles) => ({
    ...styles,
    margin: 0,
    padding: 0
  })
});
var DropdownIndicator3 = (props) => (0, import_jsx_runtime4.jsx)(components.DropdownIndicator, { ...props, children: (0, import_jsx_runtime4.jsx)(Box, { paddingX: 2, children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: (0, import_jsx_runtime4.jsx)(ChevronDownIcon, {}) }) }) });
var Menu4 = (props) => (0, import_jsx_runtime4.jsx)(components.Menu, { ...props, children: (0, import_jsx_runtime4.jsx)(Card, { radius: 1, shadow: 2, children: props.children }) });
var MenuList3 = (props) => {
  const { children } = props, MAX_ROWS = 5, OPTION_HEIGHT = 37;
  if (Array.isArray(children)) {
    const height = children.length > MAX_ROWS ? OPTION_HEIGHT * MAX_ROWS : children.length * OPTION_HEIGHT;
    return (0, import_jsx_runtime4.jsx)(
      qr,
      {
        className: "media__custom-scrollbar",
        itemContent: (index2) => {
          const item = children[index2];
          return (0, import_jsx_runtime4.jsx)(Option3, { ...item.props });
        },
        style: { height },
        totalCount: children.length
      }
    );
  }
  return (0, import_jsx_runtime4.jsx)(components.MenuList, { ...props, children });
};
var MultiValueLabel2 = (props) => (0, import_jsx_runtime4.jsx)(Box, { padding: 2, paddingRight: 1, children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, weight: "medium", children: (0, import_jsx_runtime4.jsx)(components.MultiValueLabel, { ...props }) }) });
var MultiValueRemove2 = (props) => (0, import_jsx_runtime4.jsx)(components.MultiValueRemove, { ...props, children: (0, import_jsx_runtime4.jsx)(CloseIcon, { color: "#1f2123" }) });
var Option3 = (props) => (0, import_jsx_runtime4.jsx)(Box, { paddingX: 1, paddingY: 1, children: (0, import_jsx_runtime4.jsx)(components.Option, { ...props, children: (0, import_jsx_runtime4.jsxs)(Flex, { align: "center", children: [
  props.data.__isNew__ && (0, import_jsx_runtime4.jsx)(AddIcon, { style: { marginRight: "3px" } }),
  props.children
] }) }) });
var reactSelectComponents = {
  DropdownIndicator: DropdownIndicator3,
  IndicatorSeparator: null,
  Menu: Menu4,
  MenuList: MenuList3,
  MultiValueLabel: MultiValueLabel2,
  MultiValueRemove: MultiValueRemove2,
  Option: Option3
};
var StyledErrorOutlineIcon = dt(ErrorOutlineIcon)(({ theme }) => ({
  color: theme.sanity.color.spot.red
}));
var FormFieldInputLabel = (props) => {
  const { description, error, label, name } = props;
  return (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
    (0, import_jsx_runtime4.jsx)(Box, { marginY: 3, children: (0, import_jsx_runtime4.jsxs)(Inline, { space: 2, children: [
      (0, import_jsx_runtime4.jsx)(Text, { as: "label", htmlFor: name, size: 1, weight: "semibold", children: label }),
      error && (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: (0, import_jsx_runtime4.jsx)(
        Tooltip,
        {
          animate: true,
          content: (0, import_jsx_runtime4.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime4.jsxs)(Text, { muted: true, size: 1, children: [
            (0, import_jsx_runtime4.jsx)(StyledErrorOutlineIcon, { style: { marginRight: "0.1em" } }),
            error
          ] }) }),
          fallbackPlacements: ["top", "left"],
          placement: "right",
          portal: true,
          children: (0, import_jsx_runtime4.jsx)(StyledErrorOutlineIcon, {})
        }
      ) })
    ] }) }),
    description && (0, import_jsx_runtime4.jsx)(Box, { marginY: 3, children: (0, import_jsx_runtime4.jsx)(Text, { htmlFor: name, muted: true, size: 1, children: description }) })
  ] });
};
var FormFieldInputTags = (props) => {
  const {
    control,
    description,
    disabled,
    error,
    label,
    name,
    onCreateTag,
    options: options2,
    placeholder,
    value
  } = props, scheme = useColorSchemeValue(), creating = useTypedSelector((state) => state.tags.creating), tagsFetching = useTypedSelector((state) => state.tags.fetching);
  return (0, import_jsx_runtime4.jsxs)(
    Box,
    {
      style: { zIndex: 2 },
      children: [
        (0, import_jsx_runtime4.jsx)(FormFieldInputLabel, { description, error, label, name }),
        (0, import_jsx_runtime4.jsx)(
          Controller,
          {
            control,
            defaultValue: value,
            name,
            render: ({ field }) => {
              const { onBlur, onChange: onChange2, value: controllerValue } = field;
              return (0, import_jsx_runtime4.jsx)(
                CreatableSelect$1,
                {
                  components: reactSelectComponents,
                  instanceId: "tags",
                  isClearable: false,
                  isDisabled: creating || disabled || tagsFetching,
                  isLoading: creating,
                  isMulti: true,
                  name,
                  noOptionsMessage: () => "No tags",
                  onBlur,
                  onChange: onChange2,
                  onCreateOption: onCreateTag,
                  options: options2,
                  placeholder: tagsFetching ? "Loading..." : placeholder,
                  styles: reactSelectStyles(scheme),
                  value: controllerValue
                }
              );
            }
          }
        )
      ]
    }
  );
};
var FormFieldInputText = (0, import_react19.forwardRef)((props, ref) => {
  const { description, disabled, error, label, name, placeholder, value, ...rest } = props;
  return (0, import_jsx_runtime4.jsxs)(Box, { children: [
    (0, import_jsx_runtime4.jsx)(FormFieldInputLabel, { description, error, label, name }),
    (0, import_jsx_runtime4.jsx)(
      TextInput,
      {
        ...rest,
        autoComplete: "off",
        autoFocus: true,
        defaultValue: value,
        disabled,
        id: name,
        name,
        placeholder,
        ref
      }
    )
  ] });
});
var FormFieldInputTextarea = (0, import_react19.forwardRef)((props, ref) => {
  const { description, disabled, error, label, name, placeholder, rows, value, ...rest } = props;
  return (0, import_jsx_runtime4.jsxs)(Box, { children: [
    (0, import_jsx_runtime4.jsx)(FormFieldInputLabel, { description, error, label, name }),
    (0, import_jsx_runtime4.jsx)(
      TextArea,
      {
        ...rest,
        autoComplete: "off",
        defaultValue: value,
        disabled,
        id: name,
        name,
        placeholder,
        ref,
        rows
      }
    )
  ] });
});
var FormSubmitButton = (props) => {
  const { disabled, isValid: isValid3, lastUpdated, onClick } = props;
  let content2;
  return isValid3 ? lastUpdated ? content2 = (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
    "Last updated",
    (0, import_jsx_runtime4.jsx)("br", {}),
    " ",
    format_default(new Date(lastUpdated), "PPp")
  ] }) : content2 = "No unpublished changes" : content2 = "There are validation errors that need to be fixed before this document can be published", (0, import_jsx_runtime4.jsx)(
    Tooltip,
    {
      animate: true,
      content: (0, import_jsx_runtime4.jsx)(Box, { padding: 3, style: { maxWidth: "185px" }, children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: content2 }) }),
      disabled: "ontouchstart" in window,
      placement: "top",
      portal: true,
      children: (0, import_jsx_runtime4.jsx)(Box, { children: (0, import_jsx_runtime4.jsx)(
        Button,
        {
          disabled,
          fontSize: 1,
          onClick,
          text: "Save and close",
          tone: "primary"
        }
      ) })
    }
  );
};
var Image$1 = dt.img`
  --checkerboard-color: ${(props) => props.$scheme ? getSchemeColor(props.$scheme, "bg2") : "inherit"};

  display: block;
  width: 100%;
  height: 100%;
  object-fit: contain;

  ${(props) => props.$showCheckerboard && lt`
      background-image: linear-gradient(45deg, var(--checkerboard-color) 25%, transparent 25%),
        linear-gradient(-45deg, var(--checkerboard-color) 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, var(--checkerboard-color) 75%),
        linear-gradient(-45deg, transparent 75%, var(--checkerboard-color) 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0;
    `}
`;
var DialogAssetEdit = (props) => {
  const {
    children,
    dialog: { assetId, id, lastCreatedTag, lastRemovedTagIds }
  } = props, client = useVersionedClient(), scheme = useColorSchemeValue(), documentStore = useDocumentStore(), dispatch = useDispatch(), assetItem = useTypedSelector((state) => selectAssetById(state, String(assetId))), tags = useTypedSelector(selectTags), assetUpdatedPrev = (0, import_react19.useRef)(void 0), [assetSnapshot, setAssetSnapshot] = (0, import_react19.useState)(assetItem?.asset), [tabSection, setTabSection] = (0, import_react19.useState)("details"), currentAsset = assetItem ? assetItem?.asset : assetSnapshot, allTagOptions = getTagSelectOptions(tags), assetTagOptions = useTypedSelector(selectTagSelectOptions(currentAsset)), { creditLine } = useToolOptions(), generateDefaultValues = (0, import_react19.useCallback)(
    (asset) => ({
      altText: asset?.altText || "",
      creditLine: asset?.creditLine || "",
      description: asset?.description || "",
      originalFilename: asset?.originalFilename || "",
      opt: { media: { tags: assetTagOptions } },
      title: asset?.title || ""
    }),
    [assetTagOptions]
  ), {
    control,
    // Read the formState before render to subscribe the form state through Proxy
    formState: { errors, isDirty: isDirty2, isValid: isValid3 },
    getValues,
    handleSubmit,
    register,
    reset,
    setValue
  } = useForm({
    defaultValues: generateDefaultValues(assetItem?.asset),
    mode: "onChange",
    resolver: t(assetFormSchema)
  }), formUpdating = !assetItem || assetItem?.updating, handleClose = (0, import_react19.useCallback)(() => {
    dispatch(dialogActions.remove({ id }));
  }, [dispatch, id]), handleDelete = (0, import_react19.useCallback)(() => {
    assetItem?.asset && dispatch(
      dialogActions.showConfirmDeleteAssets({
        assets: [assetItem],
        closeDialogId: assetItem?.asset._id
      })
    );
  }, [assetItem, dispatch]), handleAssetUpdate = (0, import_react19.useCallback)((update) => {
    const { result, transition } = update;
    result && transition === "update" && setAssetSnapshot(result);
  }, []), handleCreateTag = (0, import_react19.useCallback)(
    (tagName) => {
      dispatch(
        tagsActions.createRequest({
          assetId: currentAsset?._id,
          name: tagName
        })
      );
    },
    [currentAsset?._id, dispatch]
  ), onSubmit = (0, import_react19.useCallback)(
    (formData) => {
      if (!assetItem?.asset)
        return;
      const sanitizedFormData = sanitizeFormData(formData);
      dispatch(
        assetsActions.updateRequest({
          asset: assetItem?.asset,
          closeDialogId: assetItem?.asset._id,
          formData: {
            ...sanitizedFormData,
            // Map tags to sanity references
            opt: {
              media: {
                ...sanitizedFormData.opt.media,
                tags: sanitizedFormData.opt.media.tags?.map((tag) => ({
                  _ref: tag.value,
                  _type: "reference",
                  _weak: true
                })) || null
              }
            }
          }
        })
      );
    },
    [assetItem?.asset, dispatch]
  );
  return (0, import_react19.useEffect)(() => {
    if (!assetItem?.asset)
      return;
    const subscriptionAsset = client.listen(groq`*[_id == $id]`, { id: assetItem?.asset._id }).subscribe(handleAssetUpdate);
    return () => {
      subscriptionAsset?.unsubscribe();
    };
  }, [assetItem?.asset, client, handleAssetUpdate]), (0, import_react19.useEffect)(() => {
    if (lastCreatedTag) {
      const updatedTags = (getValues("opt.media.tags") || []).concat([lastCreatedTag]);
      setValue("opt.media.tags", updatedTags, { shouldDirty: true });
    }
  }, [getValues, lastCreatedTag, setValue]), (0, import_react19.useEffect)(() => {
    if (lastRemovedTagIds) {
      const updatedTags = (getValues("opt.media.tags") || []).filter((tag) => !lastRemovedTagIds.includes(tag.value));
      setValue("opt.media.tags", updatedTags, { shouldDirty: true });
    }
  }, [getValues, lastRemovedTagIds, setValue]), (0, import_react19.useEffect)(() => {
    assetUpdatedPrev.current !== assetItem?.asset._updatedAt && reset(generateDefaultValues(assetItem?.asset)), assetUpdatedPrev.current = assetItem?.asset._updatedAt;
  }, [assetItem?.asset, generateDefaultValues, reset]), currentAsset ? (0, import_jsx_runtime4.jsxs)(
    Dialog2,
    {
      animate: true,
      footer: (0, import_jsx_runtime4.jsx)(() => (0, import_jsx_runtime4.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime4.jsxs)(Flex, { justify: "space-between", children: [
        (0, import_jsx_runtime4.jsx)(
          Button,
          {
            disabled: formUpdating,
            fontSize: 1,
            mode: "bleed",
            onClick: handleDelete,
            text: "Delete",
            tone: "critical"
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          FormSubmitButton,
          {
            disabled: formUpdating || !isDirty2 || !isValid3,
            isValid: isValid3,
            lastUpdated: currentAsset?._updatedAt,
            onClick: handleSubmit(onSubmit)
          }
        )
      ] }) }), {}),
      header: "Asset details",
      id,
      onClose: handleClose,
      width: 3,
      children: [
        (0, import_jsx_runtime4.jsxs)(Flex, { direction: ["column-reverse", "column-reverse", "row-reverse"], children: [
          (0, import_jsx_runtime4.jsx)(Box, { flex: 1, marginTop: [5, 5, 0], padding: 4, children: (0, import_jsx_runtime4.jsx)(WithReferringDocuments, { documentStore, id: currentAsset._id, children: ({ isLoading, referringDocuments }) => {
            const uniqueReferringDocuments = getUniqueDocuments(referringDocuments);
            return (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
              (0, import_jsx_runtime4.jsxs)(TabList, { space: 2, children: [
                (0, import_jsx_runtime4.jsx)(
                  Tab,
                  {
                    "aria-controls": "details-panel",
                    disabled: formUpdating,
                    id: "details-tab",
                    label: "Details",
                    onClick: () => setTabSection("details"),
                    selected: tabSection === "details",
                    size: 2
                  }
                ),
                (0, import_jsx_runtime4.jsx)(
                  Tab,
                  {
                    "aria-controls": "references-panel",
                    disabled: formUpdating,
                    id: "references-tab",
                    label: `References${!isLoading && Array.isArray(uniqueReferringDocuments) ? ` (${uniqueReferringDocuments.length})` : ""}`,
                    onClick: () => setTabSection("references"),
                    selected: tabSection === "references",
                    size: 2
                  }
                )
              ] }),
              (0, import_jsx_runtime4.jsxs)(Box, { as: "form", marginTop: 4, onSubmit: handleSubmit(onSubmit), children: [
                !assetItem && (0, import_jsx_runtime4.jsx)(Card, { marginBottom: 3, padding: 3, radius: 2, shadow: 1, tone: "critical", children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: "This file cannot be found – it may have been deleted." }) }),
                (0, import_jsx_runtime4.jsx)("button", { style: { display: "none" }, tabIndex: -1, type: "submit" }),
                (0, import_jsx_runtime4.jsx)(
                  TabPanel,
                  {
                    "aria-labelledby": "details",
                    hidden: tabSection !== "details",
                    id: "details-panel",
                    children: (0, import_jsx_runtime4.jsxs)(Stack, { space: 3, children: [
                      (0, import_jsx_runtime4.jsx)(
                        FormFieldInputTags,
                        {
                          control,
                          disabled: formUpdating,
                          error: errors?.opt?.media?.tags?.message,
                          label: "Tags",
                          name: "opt.media.tags",
                          onCreateTag: handleCreateTag,
                          options: allTagOptions,
                          placeholder: "Select or create...",
                          value: assetTagOptions
                        }
                      ),
                      (0, import_jsx_runtime4.jsx)(
                        FormFieldInputText,
                        {
                          ...register("originalFilename"),
                          disabled: formUpdating,
                          error: errors?.originalFilename?.message,
                          label: "Filename",
                          name: "originalFilename",
                          value: currentAsset?.originalFilename
                        }
                      ),
                      (0, import_jsx_runtime4.jsx)(
                        FormFieldInputText,
                        {
                          ...register("title"),
                          disabled: formUpdating,
                          error: errors?.title?.message,
                          label: "Title",
                          name: "title",
                          value: currentAsset?.title
                        }
                      ),
                      (0, import_jsx_runtime4.jsx)(
                        FormFieldInputText,
                        {
                          ...register("altText"),
                          disabled: formUpdating,
                          error: errors?.altText?.message,
                          label: "Alt Text",
                          name: "altText",
                          value: currentAsset?.altText
                        }
                      ),
                      (0, import_jsx_runtime4.jsx)(
                        FormFieldInputTextarea,
                        {
                          ...register("description"),
                          disabled: formUpdating,
                          error: errors?.description?.message,
                          label: "Description",
                          name: "description",
                          rows: 5,
                          value: currentAsset?.description
                        }
                      ),
                      creditLine?.enabled && (0, import_jsx_runtime4.jsx)(
                        FormFieldInputText,
                        {
                          ...register("creditLine"),
                          error: errors?.creditLine?.message,
                          label: "Credit",
                          name: "creditLine",
                          value: currentAsset?.creditLine,
                          disabled: formUpdating || creditLine?.excludeSources?.includes(currentAsset?.source?.name)
                        }
                      )
                    ] })
                  }
                ),
                (0, import_jsx_runtime4.jsx)(
                  TabPanel,
                  {
                    "aria-labelledby": "references",
                    hidden: tabSection !== "references",
                    id: "references-panel",
                    children: (0, import_jsx_runtime4.jsx)(Box, { marginTop: 5, children: assetItem?.asset && (0, import_jsx_runtime4.jsx)(
                      DocumentList,
                      {
                        documents: uniqueReferringDocuments,
                        isLoading
                      }
                    ) })
                  }
                )
              ] })
            ] });
          } }) }),
          (0, import_jsx_runtime4.jsxs)(Box, { flex: 1, padding: 4, children: [
            (0, import_jsx_runtime4.jsxs)(Box, { style: { aspectRatio: "1" }, children: [
              isFileAsset(currentAsset) && (0, import_jsx_runtime4.jsx)(FileAssetPreview, { asset: currentAsset }),
              isImageAsset(currentAsset) && (0, import_jsx_runtime4.jsx)(
                Image$1,
                {
                  draggable: false,
                  $scheme: scheme,
                  $showCheckerboard: !currentAsset?.metadata?.isOpaque,
                  src: imageDprUrl(currentAsset, { height: 600, width: 600 })
                }
              )
            ] }),
            currentAsset && (0, import_jsx_runtime4.jsx)(Box, { marginTop: 4, children: (0, import_jsx_runtime4.jsx)(AssetMetadata, { asset: currentAsset, item: assetItem }) })
          ] })
        ] }),
        children
      ]
    }
  ) : null;
};
var DialogConfirm = (props) => {
  const { children, dialog } = props, dispatch = useDispatch(), handleClose = () => {
    dispatch(dialogActions.remove({ id: dialog?.id }));
  }, handleConfirm = () => {
    dialog?.closeDialogId && dispatch(dialogActions.remove({ id: dialog?.closeDialogId })), dialog?.confirmCallbackAction && dispatch(dialog.confirmCallbackAction), handleClose();
  };
  return (0, import_jsx_runtime4.jsxs)(
    Dialog2,
    {
      animate: true,
      footer: (0, import_jsx_runtime4.jsx)(() => (0, import_jsx_runtime4.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime4.jsxs)(Flex, { justify: "space-between", children: [
        (0, import_jsx_runtime4.jsx)(Button, { fontSize: 1, mode: "bleed", onClick: handleClose, text: "Cancel" }),
        (0, import_jsx_runtime4.jsx)(
          Button,
          {
            fontSize: 1,
            onClick: handleConfirm,
            text: dialog?.confirmText,
            tone: dialog?.tone
          }
        )
      ] }) }), {}),
      header: (0, import_jsx_runtime4.jsx)(() => (0, import_jsx_runtime4.jsxs)(Flex, { align: "center", children: [
        (0, import_jsx_runtime4.jsx)(Box, { paddingX: 1, children: (0, import_jsx_runtime4.jsx)(WarningOutlineIcon, {}) }),
        (0, import_jsx_runtime4.jsx)(Box, { marginLeft: 2, children: dialog?.headerTitle })
      ] }), {}),
      id: "confirm",
      onClose: handleClose,
      width: 1,
      children: [
        (0, import_jsx_runtime4.jsx)(Box, { paddingX: 4, paddingY: 4, children: (0, import_jsx_runtime4.jsxs)(Stack, { space: 3, children: [
          dialog?.title && (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: dialog.title }),
          dialog?.description && (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime4.jsx)("em", { children: dialog.description }) })
        ] }) }),
        children
      ]
    }
  );
};
var DialogSearchFacets = (props) => {
  const {
    children,
    dialog: { id }
  } = props, dispatch = useDispatch(), handleClose = (0, import_react19.useCallback)(() => {
    dispatch(dialogActions.clear());
  }, []);
  return (0, import_jsx_runtime4.jsxs)(Dialog2, { animate: true, header: "Filters", id, onClose: handleClose, width: 1, children: [
    (0, import_jsx_runtime4.jsxs)(Box, { padding: 3, children: [
      (0, import_jsx_runtime4.jsx)(SearchFacets, { layout: "stack" }),
      (0, import_jsx_runtime4.jsx)(SearchFacetsControl, {})
    ] }),
    children
  ] });
};
var DialogTagCreate = (props) => {
  const {
    children,
    dialog: { id }
  } = props, dispatch = useDispatch(), creating = useTypedSelector((state) => state.tags.creating), creatingError = useTypedSelector((state) => state.tags.creatingError), {
    // Read the formState before render to subscribe the form state through Proxy
    formState: { errors, isDirty: isDirty2, isValid: isValid3 },
    handleSubmit,
    register,
    setError
  } = useForm({
    defaultValues: {
      name: ""
    },
    mode: "onChange",
    resolver: t(tagFormSchema)
  }), formUpdating = creating, handleClose = () => {
    dispatch(dialogActions.clear());
  }, onSubmit = (formData) => {
    const sanitizedFormData = sanitizeFormData(formData);
    dispatch(tagsActions.createRequest({ name: sanitizedFormData.name }));
  };
  return (0, import_react19.useEffect)(() => {
    creatingError && setError("name", {
      message: creatingError?.message
    });
  }, [creatingError, setError]), (0, import_jsx_runtime4.jsxs)(Dialog2, { animate: true, footer: (0, import_jsx_runtime4.jsx)(() => (0, import_jsx_runtime4.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime4.jsx)(Flex, { justify: "flex-end", children: (0, import_jsx_runtime4.jsx)(
    FormSubmitButton,
    {
      disabled: formUpdating || !isDirty2 || !isValid3,
      isValid: isValid3,
      onClick: handleSubmit(onSubmit)
    }
  ) }) }), {}), header: "Create Tag", id, onClose: handleClose, width: 1, children: [
    (0, import_jsx_runtime4.jsxs)(Box, { as: "form", padding: 4, onSubmit: handleSubmit(onSubmit), children: [
      (0, import_jsx_runtime4.jsx)("button", { style: { display: "none" }, tabIndex: -1, type: "submit" }),
      (0, import_jsx_runtime4.jsx)(
        FormFieldInputText,
        {
          ...register("name"),
          disabled: formUpdating,
          error: errors?.name?.message,
          label: "Name",
          name: "name"
        }
      )
    ] }),
    children
  ] });
};
var DialogTagEdit = (props) => {
  const {
    children,
    dialog: { id, tagId }
  } = props, client = useVersionedClient(), dispatch = useDispatch(), tagItem = useTypedSelector((state) => selectTagById(state, String(tagId))), [tagSnapshot, setTagSnapshot] = (0, import_react19.useState)(tagItem?.tag), currentTag = tagItem ? tagItem?.tag : tagSnapshot, generateDefaultValues = (tag) => ({
    name: tag?.name?.current || ""
  }), {
    // Read the formState before render to subscribe the form state through Proxy
    formState: { errors, isDirty: isDirty2, isValid: isValid3 },
    handleSubmit,
    register,
    reset,
    setError
  } = useForm({
    defaultValues: generateDefaultValues(tagItem?.tag),
    mode: "onChange",
    resolver: t(tagFormSchema)
  }), formUpdating = !tagItem || tagItem?.updating, handleClose = () => {
    dispatch(dialogActions.remove({ id }));
  }, onSubmit = (formData) => {
    if (!tagItem?.tag)
      return;
    const sanitizedFormData = sanitizeFormData(formData);
    dispatch(
      tagsActions.updateRequest({
        closeDialogId: tagItem?.tag?._id,
        formData: {
          name: {
            _type: "slug",
            current: sanitizedFormData.name
          }
        },
        tag: tagItem?.tag
      })
    );
  }, handleDelete = () => {
    tagItem?.tag && dispatch(
      dialogActions.showConfirmDeleteTag({
        closeDialogId: tagItem?.tag?._id,
        tag: tagItem?.tag
      })
    );
  }, handleTagUpdate = (0, import_react19.useCallback)(
    (update) => {
      const { result, transition } = update;
      result && transition === "update" && (setTagSnapshot(result), reset(generateDefaultValues(result)));
    },
    [reset]
  );
  return (0, import_react19.useEffect)(() => {
    tagItem?.error && setError("name", {
      message: tagItem.error?.message
    });
  }, [setError, tagItem.error]), (0, import_react19.useEffect)(() => {
    if (!tagItem?.tag)
      return;
    const subscriptionAsset = client.listen(groq`*[_id == $id]`, { id: tagItem?.tag._id }).subscribe(handleTagUpdate);
    return () => {
      subscriptionAsset?.unsubscribe();
    };
  }, [client, handleTagUpdate, tagItem?.tag]), currentTag ? (0, import_jsx_runtime4.jsxs)(Dialog2, { animate: true, footer: (0, import_jsx_runtime4.jsx)(() => (0, import_jsx_runtime4.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime4.jsxs)(Flex, { justify: "space-between", children: [
    (0, import_jsx_runtime4.jsx)(
      Button,
      {
        disabled: formUpdating,
        fontSize: 1,
        mode: "bleed",
        onClick: handleDelete,
        text: "Delete",
        tone: "critical"
      }
    ),
    (0, import_jsx_runtime4.jsx)(
      FormSubmitButton,
      {
        disabled: formUpdating || !isDirty2 || !isValid3,
        isValid: isValid3,
        lastUpdated: tagItem?.tag?._updatedAt,
        onClick: handleSubmit(onSubmit)
      }
    )
  ] }) }), {}), header: "Edit Tag", id, onClose: handleClose, width: 1, children: [
    (0, import_jsx_runtime4.jsxs)(Box, { as: "form", padding: 4, onSubmit: handleSubmit(onSubmit), children: [
      !tagItem && (0, import_jsx_runtime4.jsx)(Card, { marginBottom: 3, padding: 3, radius: 2, shadow: 1, tone: "critical", children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: "This tag cannot be found – it may have been deleted." }) }),
      (0, import_jsx_runtime4.jsx)("button", { style: { display: "none" }, tabIndex: -1, type: "submit" }),
      (0, import_jsx_runtime4.jsx)(
        FormFieldInputText,
        {
          ...register("name"),
          disabled: formUpdating,
          error: errors?.name?.message,
          label: "Name",
          name: "name"
        }
      )
    ] }),
    children
  ] }) : null;
};
var TagContainer = dt(Flex)`
  height: ${PANEL_HEIGHT}px;
`;
var ButtonContainer = dt(Flex)`
  @media (pointer: fine) {
    visibility: hidden;
  }

  @media (hover: hover) and (pointer: fine) {
    ${TagContainer}:hover & {
      visibility: visible;
    }
  }
`;
var TagButton = (props) => {
  const { disabled, icon, onClick, tone, tooltip } = props;
  return (0, import_jsx_runtime4.jsx)(
    Tooltip,
    {
      animate: true,
      content: (0, import_jsx_runtime4.jsx)(Container, { padding: 2, width: 0, children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: tooltip }) }),
      disabled: "ontouchstart" in window,
      placement: "top",
      portal: true,
      children: (0, import_jsx_runtime4.jsx)(
        Button,
        {
          disabled,
          fontSize: 1,
          icon,
          mode: "bleed",
          onClick,
          padding: 2,
          tone
        }
      )
    }
  );
};
var Tag = (props) => {
  const { actions, tag } = props, dispatch = useDispatch(), assetsPicked = useTypedSelector(selectAssetsPicked), isSearchFacetTag = useTypedSelector((state) => selectIsSearchFacetTag(state, tag?.tag?._id)), handleSearchFacetTagRemove = () => {
    dispatch(searchActions.facetsRemoveByTag({ tagId: tag.tag._id }));
  }, handleShowAddTagToAssetsDialog = () => {
    dispatch(dialogActions.showConfirmAssetsTagAdd({ assetsPicked, tag: tag.tag }));
  }, handleShowRemoveTagFromAssetsDialog = () => {
    dispatch(dialogActions.showConfirmAssetsTagRemove({ assetsPicked, tag: tag.tag }));
  }, handleShowTagDeleteDialog = () => {
    dispatch(dialogActions.showConfirmDeleteTag({ tag: tag.tag }));
  }, handleShowTagEditDialog = () => {
    dispatch(DIALOG_ACTIONS.showTagEdit({ tagId: tag?.tag?._id }));
  }, handleSearchFacetTagAddOrUpdate = () => {
    const searchFacet = {
      ...inputs.tag,
      value: {
        label: tag?.tag?.name?.current,
        value: tag?.tag?._id
      }
    };
    dispatch(
      isSearchFacetTag ? searchActions.facetsUpdate({
        name: "tag",
        operatorType: "references",
        value: searchFacet.value
      }) : searchActions.facetsAdd({ facet: searchFacet })
    );
  };
  return (0, import_jsx_runtime4.jsxs)(TagContainer, { align: "center", flex: 1, justify: "space-between", paddingLeft: 3, children: [
    (0, import_jsx_runtime4.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime4.jsx)(
      Text,
      {
        muted: true,
        size: 1,
        style: {
          opacity: tag?.updating ? 0.5 : 1,
          userSelect: "none"
        },
        textOverflow: "ellipsis",
        children: tag?.tag?.name?.current
      }
    ) }),
    (0, import_jsx_runtime4.jsxs)(ButtonContainer, { align: "center", style: { flexShrink: 0 }, children: [
      actions?.includes("search") && (0, import_jsx_runtime4.jsx)(
        TagButton,
        {
          disabled: tag?.updating,
          icon: isSearchFacetTag ? (0, import_jsx_runtime4.jsx)(CloseIcon, {}) : (0, import_jsx_runtime4.jsx)(SearchIcon, {}),
          onClick: isSearchFacetTag ? handleSearchFacetTagRemove : handleSearchFacetTagAddOrUpdate,
          tooltip: isSearchFacetTag ? "Remove filter" : "Filter by tag"
        }
      ),
      actions?.includes("edit") && (0, import_jsx_runtime4.jsx)(
        TagButton,
        {
          disabled: tag?.updating,
          icon: (0, import_jsx_runtime4.jsx)(EditIcon, {}),
          onClick: handleShowTagEditDialog,
          tone: "primary",
          tooltip: "Edit tag"
        }
      ),
      actions?.includes("applyAll") && (0, import_jsx_runtime4.jsx)(
        TagButton,
        {
          disabled: tag?.updating,
          icon: (0, import_jsx_runtime4.jsx)(ArrowUpIcon, {}),
          onClick: handleShowAddTagToAssetsDialog,
          tone: "primary",
          tooltip: "Add tag to selected assets"
        }
      ),
      actions?.includes("removeAll") && (0, import_jsx_runtime4.jsx)(
        TagButton,
        {
          disabled: tag?.updating,
          icon: (0, import_jsx_runtime4.jsx)(ArrowDownIcon, {}),
          onClick: handleShowRemoveTagFromAssetsDialog,
          tone: "critical",
          tooltip: "Remove tag from selected assets"
        }
      ),
      actions?.includes("delete") && (0, import_jsx_runtime4.jsx)(
        TagButton,
        {
          disabled: tag?.updating,
          icon: (0, import_jsx_runtime4.jsx)(TrashIcon, {}),
          onClick: handleShowTagDeleteDialog,
          tone: "critical",
          tooltip: "Delete tag"
        }
      )
    ] })
  ] });
};
var VirtualRow$1 = (0, import_react19.memo)(
  ({
    isScrolling,
    item
  }) => typeof item == "string" ? (0, import_jsx_runtime4.jsx)(
    Flex,
    {
      align: "center",
      justify: "space-between",
      paddingX: 3,
      style: { height: `${PANEL_HEIGHT}px` },
      children: (0, import_jsx_runtime4.jsx)(Label, { size: 0, children: item })
    },
    item
  ) : (0, import_jsx_runtime4.jsx)(Tag, { actions: isScrolling ? void 0 : item.actions, tag: item }, item.tag?._id)
);
var TagsVirtualized = () => {
  const assetsPicked = useTypedSelector(selectAssetsPicked), tags = useTypedSelector(selectTags), [isScrolling, setIsScrolling] = (0, import_react19.useState)(false), pickedTagIds = assetsPicked?.reduce((acc, val) => {
    const assetTagIds = val?.asset?.opt?.media?.tags?.map((tag) => tag._ref) || [];
    return acc = acc.concat(assetTagIds), acc;
  }, []), pickedTagIdsUnique = [...new Set(pickedTagIds)], tagIdsSegmented = pickedTagIdsUnique.reduce(
    (acc, tagId) => (assetsPicked.every((assetItem) => (assetItem.asset.opt?.media?.tags?.findIndex((tag) => tag._ref === tagId) ?? -1) >= 0) ? acc.appliedToAll.push(tagId) : acc.appliedToSome.push(tagId), acc),
    {
      appliedToAll: [],
      appliedToSome: []
    }
  ), tagsAppliedToAll = tags.filter((tag) => tagIdsSegmented.appliedToAll.includes(tag.tag._id)).map((tagItem) => ({
    ...tagItem,
    actions: ["delete", "edit", "removeAll", "search"]
  })), tagsAppliedToSome = tags.filter((tag) => tagIdsSegmented.appliedToSome.includes(tag.tag._id)).map((tagItem) => ({
    ...tagItem,
    actions: ["applyAll", "delete", "edit", "removeAll", "search"]
  })), tagsUnused = tags.filter((tag) => !pickedTagIdsUnique.includes(tag.tag._id)).map((tagItem) => ({
    ...tagItem,
    actions: ["applyAll", "delete", "edit", "search"]
  }));
  let items = [];
  return assetsPicked.length === 0 ? items = tags.map((tagItem) => ({
    ...tagItem,
    actions: ["delete", "edit", "search"]
  })) : (tagsAppliedToAll?.length > 0 && (items = [
    ...items,
    //
    assetsPicked.length === 1 ? "Used" : "Used by all",
    ...tagsAppliedToAll
  ]), tagsAppliedToSome?.length > 0 && (items = [
    ...items,
    //
    "Used by some",
    ...tagsAppliedToSome
  ]), tagsUnused?.length > 0 && (items = [
    ...items,
    //
    "Unused",
    ...tagsUnused
  ])), (0, import_jsx_runtime4.jsx)(
    qr,
    {
      className: "media__custom-scrollbar",
      computeItemKey: (index2) => {
        const item = items[index2];
        return typeof item == "string" ? item : item.tag._id;
      },
      isScrolling: setIsScrolling,
      itemContent: (index2) => (0, import_jsx_runtime4.jsx)(VirtualRow$1, { isScrolling, item: items[index2] }),
      style: { flex: 1, overflowX: "hidden" },
      totalCount: items.length
    }
  );
};
var TagViewHeader = ({ allowCreate, light, title }) => {
  const scheme = useColorSchemeValue(), dispatch = useDispatch(), tagsCreating = useTypedSelector((state) => state.tags.creating), tagsFetching = useTypedSelector((state) => state.tags.fetching), handleTagCreate = () => {
    dispatch(DIALOG_ACTIONS.showTagCreate());
  };
  return (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: (0, import_jsx_runtime4.jsxs)(
    Flex,
    {
      align: "center",
      justify: "space-between",
      paddingLeft: 3,
      style: {
        background: light ? getSchemeColor(scheme, "bg") : "inherit",
        borderBottom: "1px solid var(--card-border-color)",
        flexShrink: 0,
        height: `${PANEL_HEIGHT}px`
      },
      children: [
        (0, import_jsx_runtime4.jsxs)(Inline, { space: 2, children: [
          (0, import_jsx_runtime4.jsx)(Label, { size: 0, children: title }),
          tagsFetching && (0, import_jsx_runtime4.jsx)(Label, { size: 0, style: { opacity: 0.3 }, children: "Loading..." })
        ] }),
        allowCreate && (0, import_jsx_runtime4.jsx)(Box, { marginRight: 1, children: (0, import_jsx_runtime4.jsx)(
          Button,
          {
            disabled: tagsCreating,
            fontSize: 1,
            icon: ComposeIcon,
            mode: "bleed",
            onClick: handleTagCreate,
            style: {
              background: "transparent",
              boxShadow: "none"
            }
          }
        ) })
      ]
    }
  ) });
};
var TagView = () => {
  const numPickedAssets = useTypedSelector(selectAssetsPickedLength), tags = useTypedSelector(selectTags), fetching = useTypedSelector((state) => state.tags.fetching), fetchComplete = useTypedSelector((state) => state.tags.fetchCount) !== -1, hasTags = !fetching && tags?.length > 0, hasPicked = numPickedAssets > 0;
  return (0, import_jsx_runtime4.jsxs)(Flex, { direction: "column", flex: 1, height: "fill", children: [
    (0, import_jsx_runtime4.jsx)(
      TagViewHeader,
      {
        allowCreate: true,
        light: hasPicked,
        title: hasPicked ? "Tags (in selection)" : "Tags"
      }
    ),
    fetchComplete && !hasTags && (0, import_jsx_runtime4.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime4.jsx)("em", { children: "No tags" }) }) }),
    hasTags && (0, import_jsx_runtime4.jsx)(TagsVirtualized, {})
  ] });
};
var DialogTags = (props) => {
  const {
    children,
    dialog: { id }
  } = props, dispatch = useDispatch(), handleClose = (0, import_react19.useCallback)(() => {
    dispatch(dialogActions.clear());
  }, []);
  return (0, import_jsx_runtime4.jsxs)(Dialog2, { animate: true, header: "All Tags", id, onClose: handleClose, width: 1, children: [
    (0, import_jsx_runtime4.jsx)(
      Box,
      {
        style: {
          height: "100%",
          minHeight: "420px"
          // explicit height required as <TagView> is virtualized
        },
        children: (0, import_jsx_runtime4.jsx)(TagView, {})
      }
    ),
    children
  ] });
};
var Dialogs = () => {
  const currentDialogs = useTypedSelector((state) => state.dialog.items), renderDialogs = (dialogs, index2) => {
    if (dialogs.length === 0 || index2 >= dialogs.length)
      return null;
    const dialog = dialogs[index2], childDialogs = renderDialogs(dialogs, index2 + 1);
    return dialog.type === "assetEdit" ? (0, import_jsx_runtime4.jsx)(DialogAssetEdit, { dialog, children: childDialogs }, index2) : dialog.type === "confirm" ? (0, import_jsx_runtime4.jsx)(DialogConfirm, { dialog, children: childDialogs }, index2) : dialog.type === "searchFacets" ? (0, import_jsx_runtime4.jsx)(DialogSearchFacets, { dialog, children: childDialogs }, index2) : dialog.type === "tagCreate" ? (0, import_jsx_runtime4.jsx)(DialogTagCreate, { dialog, children: childDialogs }, index2) : dialog.type === "tagEdit" ? (0, import_jsx_runtime4.jsx)(DialogTagEdit, { dialog, children: childDialogs }, index2) : dialog.type === "tags" ? (0, import_jsx_runtime4.jsx)(DialogTags, { dialog, children: childDialogs }, index2) : null;
  };
  return renderDialogs(currentDialogs, 0);
};
var DropzoneDispatchContext = (0, import_react19.createContext)(void 0);
var DropzoneDispatchProvider = (props) => {
  const { children, open } = props, contextValue = { open };
  return (0, import_jsx_runtime4.jsx)(DropzoneDispatchContext.Provider, { value: contextValue, children });
};
var useDropzoneActions = () => {
  const context = (0, import_react19.useContext)(DropzoneDispatchContext);
  if (context === void 0)
    throw new Error("useDropzoneActions must be used within an DropzoneDispatchProvider");
  return context;
};
var Header = (props) => {
  const { onClose } = props, { open } = useDropzoneActions(), { onSelect } = useAssetSourceActions(), assetTypes = useTypedSelector((state) => state.assets.assetTypes), selectedDocument = useTypedSelector((state) => state.selected.document);
  return (0, import_jsx_runtime4.jsx)(Box, { paddingY: 2, children: (0, import_jsx_runtime4.jsxs)(Flex, { align: "center", justify: "space-between", children: [
    (0, import_jsx_runtime4.jsx)(Box, { flex: 1, marginX: 3, children: (0, import_jsx_runtime4.jsxs)(Inline, { style: { whiteSpace: "nowrap" }, children: [
      (0, import_jsx_runtime4.jsx)(Text, { textOverflow: "ellipsis", weight: "semibold", children: (0, import_jsx_runtime4.jsx)("span", { children: onSelect ? `Insert ${assetTypes.join(" or ")}` : "Browse Assets" }) }),
      selectedDocument && (0, import_jsx_runtime4.jsx)(Box, { display: ["none", "none", "block"], children: (0, import_jsx_runtime4.jsxs)(Text, { children: [
        (0, import_jsx_runtime4.jsx)("span", { style: { margin: "0 0.5em" }, children: (0, import_jsx_runtime4.jsx)(Icon, { symbol: "arrow-right" }) }),
        (0, import_jsx_runtime4.jsx)("span", { style: { textTransform: "capitalize" }, children: selectedDocument._type })
      ] }) })
    ] }) }),
    (0, import_jsx_runtime4.jsxs)(Flex, { marginX: 2, children: [
      (0, import_jsx_runtime4.jsx)(
        Button,
        {
          fontSize: 1,
          icon: UploadIcon,
          mode: "bleed",
          onClick: open,
          text: `Upload ${assetTypes.length === 1 ? (0, import_pluralize.default)(assetTypes[0]) : "assets"}`,
          tone: "primary"
        }
      ),
      onClose && (0, import_jsx_runtime4.jsx)(Box, { style: { flexShrink: 0 }, children: (0, import_jsx_runtime4.jsx)(
        Button,
        {
          disabled: !onClose,
          icon: CloseIcon,
          mode: "bleed",
          onClick: onClose,
          radius: 2
        }
      ) })
    ] })
  ] }) });
};
var useBreakpointIndex = () => {
  const mediaQueryLists = studioTheme?.container?.map(
    (width) => window.matchMedia(`(max-width: ${width}px)`)
  ), getBreakpointIndex = () => mediaQueryLists.findIndex((mql) => mql.matches), [value, setValue] = (0, import_react19.useState)(getBreakpointIndex());
  return (0, import_react19.useEffect)(() => {
    const handleBreakpoint = () => {
      setValue(getBreakpointIndex);
    };
    return mediaQueryLists.forEach((mql) => {
      try {
        mql.addEventListener("change", handleBreakpoint);
      } catch {
        try {
          mql.addListener(handleBreakpoint);
        } catch {
        }
      }
    }), () => {
      try {
        mediaQueryLists.forEach((mql) => mql.removeEventListener("change", handleBreakpoint));
      } catch {
        try {
          mediaQueryLists.forEach((mql) => mql.removeListener(handleBreakpoint));
        } catch {
        }
      }
    };
  }, []), value;
};
var selectCombinedItems = createSelector(
  [
    (state) => state.assets.allIds,
    (state) => state.uploads.allIds
  ],
  (assetIds, uploadIds) => {
    const assetItems = assetIds.map((id) => ({ id, type: "asset" }));
    return [...uploadIds.map((id) => ({ id, type: "upload" })), ...assetItems];
  }
);
var CardWrapper$1 = dt(Flex)`
  box-sizing: border-box;
  height: 100%;
  overflow: hidden;
  position: relative;
  width: 100%;
`;
var CardContainer = dt(Flex)(
  ({ $picked, theme, $updating }) => lt`
      border: 1px solid transparent;
      height: 100%;
      pointer-events: ${$updating ? "none" : "auto"};
      position: relative;
      transition: all 300ms;
      user-select: none;
      width: 100%;

      border: ${$picked ? `1px solid ${theme.sanity.color.spot.orange} !important` : "1px solid inherit"};

      ${!$updating && lt`
        @media (hover: hover) and (pointer: fine) {
          &:hover {
            border: 1px solid var(--card-border-color);
          }
        }
      `}
    `
);
var ContextActionContainer$2 = dt(Flex)(
  ({ $scheme }) => lt`
      cursor: pointer;
      height: ${PANEL_HEIGHT}px;
      transition: all 300ms;
      @media (hover: hover) and (pointer: fine) {
        &:hover {
          background: ${getSchemeColor($scheme, "bg")};
        }
      }
    `
);
var StyledWarningOutlineIcon = dt(WarningFilledIcon)(({ theme }) => ({
  color: theme.sanity.color.spot.red
}));
var CardAsset = (props) => {
  const { id, selected } = props, scheme = useColorSchemeValue(), shiftPressed = useKeyPress("shift"), dispatch = useDispatch(), lastPicked = useTypedSelector((state) => state.assets.lastPicked), item = useTypedSelector((state) => selectAssetById(state, id)), asset = item?.asset, error = item?.error, isOpaque = item?.asset?.metadata?.isOpaque, picked = item?.picked, updating = item?.updating, { onSelect } = useAssetSourceActions();
  if (!asset)
    return null;
  const handleAssetClick = (e2) => {
    e2.stopPropagation(), onSelect ? onSelect([
      {
        kind: "assetDocumentId",
        value: asset._id
      }
    ]) : shiftPressed.current ? dispatch(picked ? assetsActions.pick({ assetId: asset._id, picked: !picked }) : assetsActions.pickRange({ startId: lastPicked || asset._id, endId: asset._id })) : dispatch(dialogActions.showAssetEdit({ assetId: asset._id }));
  }, handleContextActionClick = (e2) => {
    e2.stopPropagation(), onSelect ? dispatch(dialogActions.showAssetEdit({ assetId: asset._id })) : shiftPressed.current && !picked ? dispatch(assetsActions.pickRange({ startId: lastPicked || asset._id, endId: asset._id })) : dispatch(assetsActions.pick({ assetId: asset._id, picked: !picked }));
  }, opacityContainer = updating ? 0.5 : 1, opacityPreview = selected || updating ? 0.25 : 1;
  return (0, import_jsx_runtime4.jsx)(CardWrapper$1, { padding: 1, children: (0, import_jsx_runtime4.jsxs)(CardContainer, { direction: "column", $picked: picked, $updating: item.updating, children: [
    (0, import_jsx_runtime4.jsxs)(
      Box,
      {
        flex: 1,
        style: {
          cursor: selected ? "default" : "pointer",
          position: "relative"
        },
        children: [
          (0, import_jsx_runtime4.jsxs)("div", { onClick: handleAssetClick, style: { height: "100%", opacity: opacityPreview }, children: [
            isFileAsset(asset) && (0, import_jsx_runtime4.jsx)(FileIcon3, { extension: asset.extension, width: "80px" }),
            isImageAsset(asset) && (0, import_jsx_runtime4.jsx)(
              Image$1,
              {
                draggable: false,
                $scheme: scheme,
                $showCheckerboard: !isOpaque,
                src: imageDprUrl(asset, { height: 250, width: 250 }),
                style: {
                  draggable: false,
                  transition: "opacity 1000ms"
                }
              }
            )
          ] }),
          selected && !updating && (0, import_jsx_runtime4.jsx)(
            Flex,
            {
              align: "center",
              justify: "center",
              style: {
                height: "100%",
                left: 0,
                opacity: opacityContainer,
                position: "absolute",
                top: 0,
                width: "100%"
              },
              children: (0, import_jsx_runtime4.jsx)(Text, { size: 2, children: (0, import_jsx_runtime4.jsx)(CheckmarkCircleIcon, {}) })
            }
          ),
          updating && (0, import_jsx_runtime4.jsx)(
            Flex,
            {
              align: "center",
              justify: "center",
              style: {
                height: "100%",
                left: 0,
                position: "absolute",
                top: 0,
                width: "100%"
              },
              children: (0, import_jsx_runtime4.jsx)(Spinner, {})
            }
          )
        ]
      }
    ),
    (0, import_jsx_runtime4.jsxs)(
      ContextActionContainer$2,
      {
        align: "center",
        onClick: handleContextActionClick,
        paddingX: 1,
        $scheme: scheme,
        style: { opacity: opacityContainer },
        children: [
          onSelect ? (0, import_jsx_runtime4.jsx)(
            EditIcon,
            {
              style: {
                flexShrink: 0,
                opacity: 0.5
              }
            }
          ) : (0, import_jsx_runtime4.jsx)(
            Checkbox,
            {
              checked: picked,
              readOnly: true,
              style: {
                flexShrink: 0,
                pointerEvents: "none",
                transform: "scale(0.8)"
              }
            }
          ),
          (0, import_jsx_runtime4.jsx)(Box, { marginLeft: 2, children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 0, textOverflow: "ellipsis", children: asset.originalFilename }) })
        ]
      }
    ),
    error && (0, import_jsx_runtime4.jsx)(
      Box,
      {
        padding: 3,
        style: {
          position: "absolute",
          right: 0,
          top: 0
        },
        children: (0, import_jsx_runtime4.jsx)(
          Tooltip,
          {
            animate: true,
            content: (0, import_jsx_runtime4.jsx)(Container, { padding: 2, width: 0, children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: error }) }),
            placement: "left",
            portal: true,
            children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: (0, import_jsx_runtime4.jsx)(StyledWarningOutlineIcon, { color: "critical" }) })
          }
        )
      }
    )
  ] }) });
};
var CardAsset$1 = (0, import_react19.memo)(CardAsset);
var PREVIEW_WIDTH = 180;
var createBlob = (img) => new Promise((resolve) => {
  const imageAspect = img.width / img.height, canvas = document.createElement("canvas");
  canvas.width = PREVIEW_WIDTH, canvas.height = Math.max(PREVIEW_WIDTH / imageAspect, 1);
  try {
    canvas.getContext("2d")?.drawImage(img, 0, 0, PREVIEW_WIDTH, PREVIEW_WIDTH / imageAspect), canvas.toBlob(resolve, "image/jpeg");
  } catch (err) {
    console.warn("Unable to generate preview image:", err);
  }
});
var createImageEl = (file) => new Promise((resolve) => {
  const blobUrlLarge = window.URL.createObjectURL(file), img = new Image();
  img.onload = () => {
    window.URL.revokeObjectURL(blobUrlLarge), resolve(img);
  }, img.src = blobUrlLarge;
});
var generatePreviewBlobUrl = async (file) => {
  const imageEl = await createImageEl(file), blob = await createBlob(imageEl);
  if (!blob)
    throw Error("Unable to generate file Blob");
  return window.URL.createObjectURL(blob);
};
var generatePreviewBlobUrl$ = (file) => of(null).pipe(mergeMap(() => from(generatePreviewBlobUrl(file))));
var DEFAULT_CONCURRENCY = 4;
function remove(array, item) {
  const index2 = array.indexOf(item);
  return index2 > -1 && array.splice(index2, 1), array;
}
var createThrottler = (concurrency = DEFAULT_CONCURRENCY) => {
  const currentSubscriptions = [], pendingObservables = [], ready$ = new Subject();
  function request(observable) {
    return new Observable((observer) => {
      if (currentSubscriptions.length >= concurrency)
        return scheduleAndWait$(observable).pipe(mergeMap(request)).subscribe(observer);
      const subscription = observable.subscribe(observer);
      return currentSubscriptions.push(subscription), () => {
        for (remove(currentSubscriptions, subscription), remove(pendingObservables, observable), subscription.unsubscribe(); pendingObservables.length > 0 && currentSubscriptions.length < concurrency; )
          ready$.next(pendingObservables.shift());
      };
    });
  }
  function scheduleAndWait$(observable) {
    return pendingObservables.push(observable), ready$.asObservable().pipe(first((obs) => obs === observable));
  }
  return request;
};
var withMaxConcurrency = (func, concurrency = DEFAULT_CONCURRENCY) => {
  const throttler = createThrottler(concurrency);
  return (...args) => from(throttler(func(...args)));
};
var fetchExisting$ = (client, type, hash2) => client.observable.fetch("*[_type == $documentType && sha1hash == $hash][0]", {
  documentType: type,
  hash: hash2
});
var readFile$ = (file) => new Observable((subscriber) => {
  const reader = new FileReader();
  return reader.onload = () => {
    subscriber.next(reader.result), subscriber.complete();
  }, reader.onerror = (err) => {
    subscriber.error(err);
  }, reader.readAsArrayBuffer(file), () => {
    reader.abort();
  };
});
var hexFromBuffer = (buffer) => Array.prototype.map.call(new Uint8Array(buffer), (x3) => `00${x3.toString(16)}`.slice(-2)).join("");
var hashFile$ = (file) => !window.crypto || !window.crypto.subtle || !window.FileReader ? throwError({
  message: "Unable to generate hash: uploads are only allowed in secure contexts",
  statusCode: 500
}) : readFile$(file).pipe(
  mergeMap((arrayBuffer) => window.crypto.subtle.digest("SHA-1", arrayBuffer)),
  map(hexFromBuffer)
);
var uploadSanityAsset$ = (client, assetType, file, hash2) => of(null).pipe(
  // NOTE: the sanity api will still dedupe unique files, but this saves us from uploading the asset file entirely
  mergeMap(() => fetchExisting$(client, `sanity.${assetType}Asset`, hash2)),
  // Cancel if the asset already exists
  mergeMap((existingAsset) => existingAsset ? throwError({
    message: "Asset already exists",
    statusCode: 409
  }) : of(null)),
  mergeMap(() => client.observable.assets.upload(assetType, file, {
    extract: ["blurhash", "exif", "location", "lqip", "palette"],
    preserveFilename: true
  }).pipe(
    map(
      (event) => event.type === "response" ? {
        // rewrite to a 'complete' event
        asset: event.body.document,
        id: event.body.document._id,
        type: "complete"
      } : event
    )
  ))
);
var uploadAsset$ = withMaxConcurrency(uploadSanityAsset$);
var initialState$2 = {
  allIds: [],
  byIds: {}
};
var uploadsSlice = createSlice({
  name: "uploads",
  initialState: initialState$2,
  extraReducers: (builder) => {
    builder.addCase(UPLOADS_ACTIONS.uploadComplete, (state, action) => {
      const { asset } = action.payload;
      state.byIds[asset.sha1hash] && (state.byIds[asset.sha1hash].status = "complete");
    });
  },
  reducers: {
    checkRequest(_state, _action) {
    },
    checkComplete(state, action) {
      const { results } = action.payload;
      Object.keys(results).forEach((hash2) => {
        const deleteIndex = state.allIds.indexOf(hash2);
        if (deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), state.byIds[hash2]) {
          const blobUrl = state.byIds[hash2].objectUrl;
          blobUrl && window.URL.revokeObjectURL(blobUrl), delete state.byIds[hash2];
        }
      });
    },
    previewReady(state, action) {
      const { blobUrl, hash: hash2 } = action.payload;
      state.byIds[hash2] && (state.byIds[hash2].objectUrl = blobUrl);
    },
    uploadCancel(state, action) {
      const { hash: hash2 } = action.payload, deleteIndex = state.allIds.indexOf(hash2);
      deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), state.byIds[hash2] && delete state.byIds[hash2];
    },
    uploadError(state, action) {
      const { hash: hash2 } = action.payload, deleteIndex = state.allIds.indexOf(hash2);
      deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), delete state.byIds[hash2];
    },
    uploadRequest(_state, _action) {
    },
    uploadProgress(state, action) {
      const { event, uploadHash } = action.payload;
      state.byIds[uploadHash].percent = event.percent, state.byIds[uploadHash].status = "uploading";
    },
    uploadStart(state, action) {
      const { uploadItem } = action.payload;
      state.allIds.includes(uploadItem.hash) || state.allIds.push(uploadItem.hash), state.byIds[uploadItem.hash] = uploadItem;
    }
  }
});
var uploadsAssetStartEpic = (action$, _state$, { client }) => action$.pipe(
  filter(uploadsActions.uploadStart.match),
  mergeMap((action) => {
    const { file, uploadItem } = action.payload;
    return merge(
      // Generate low res preview
      of(null).pipe(
        mergeMap(() => generatePreviewBlobUrl$(file)),
        mergeMap((url) => of(
          uploadsActions.previewReady({
            blobUrl: url,
            hash: uploadItem.hash
          })
        ))
      ),
      // Upload asset and receive progress / complete events
      of(null).pipe(
        // delay(500000), // debug uploads
        mergeMap(() => uploadAsset$(client, uploadItem.assetType, file, uploadItem.hash)),
        takeUntil(
          action$.pipe(
            filter(uploadsActions.uploadCancel.match),
            filter((v2) => v2.payload.hash === uploadItem.hash)
          )
        ),
        mergeMap((event) => event?.type === "complete" ? of(
          UPLOADS_ACTIONS.uploadComplete({
            asset: event.asset
          })
        ) : event?.type === "progress" && event?.stage === "upload" ? of(
          uploadsActions.uploadProgress({
            event,
            uploadHash: uploadItem.hash
          })
        ) : empty()),
        catchError(
          (error) => of(
            uploadsActions.uploadError({
              error: {
                message: error?.message || "Internal error",
                statusCode: error?.statusCode || 500
              },
              hash: uploadItem.hash
            })
          )
        )
      )
    );
  })
);
var uploadsAssetUploadEpic = (action$, state$) => action$.pipe(
  filter(uploadsActions.uploadRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { file, forceAsAssetType } = action.payload;
    return of(action).pipe(
      // Generate SHA1 hash from local file
      // This will throw in insecure contexts (non-localhost / https)
      mergeMap(() => hashFile$(file)),
      // Ignore if the file exists and is currently being uploaded
      filter((hash2) => !state.uploads.byIds[hash2]),
      // Dispatch start action and begin upload process
      mergeMap((hash2) => {
        const uploadItem = {
          _type: "upload",
          assetType: forceAsAssetType || (file.type.indexOf("image") >= 0 ? "image" : "file"),
          hash: hash2,
          name: file.name,
          size: file.size,
          status: "queued"
        };
        return of(uploadsActions.uploadStart({ file, uploadItem }));
      })
    );
  })
);
var uploadsCompleteQueueEpic = (action$) => action$.pipe(
  filter(UPLOADS_ACTIONS.uploadComplete.match),
  mergeMap((action) => of(
    uploadsActions.checkRequest({
      assets: [action.payload.asset]
    })
  ))
);
var uploadsCheckRequestEpic = (action$, state$, { client }) => action$.pipe(
  filter(uploadsActions.checkRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { assets } = action.payload, documentIds = assets.map((asset) => asset._id), constructedFilter = constructFilter({
      assetTypes: state.assets.assetTypes,
      searchFacets: state.search.facets,
      searchQuery: state.search.query
    }), query = groq`
        *[${constructedFilter} && _id in $documentIds].sha1hash
      `;
    return of(action).pipe(
      delay(1e3),
      // give Sanity some time to register the recently uploaded asset
      mergeMap(() => client.observable.fetch(query, { documentIds })),
      mergeMap((resultHashes) => {
        const checkedResults = assets.reduce((acc, asset) => (acc[asset.sha1hash] = resultHashes.includes(asset.sha1hash) ? asset._id : null, acc), {});
        return of(
          uploadsActions.checkComplete({ results: checkedResults }),
          //
          assetsActions.insertUploads({ results: checkedResults })
        );
      })
    );
  })
);
var selectUploadsByIds = (state) => state.uploads.byIds;
var selectUploadsAllIds = (state) => state.uploads.allIds;
var selectUploadById = createSelector(
  [
    (state) => state.uploads.byIds,
    (_state, uploadId) => uploadId
  ],
  (byIds, uploadId) => byIds[uploadId]
);
createSelector(
  [selectUploadsByIds, selectUploadsAllIds],
  (byIds, allIds) => allIds.map((id) => byIds[id])
);
var uploadsActions = { ...uploadsSlice.actions };
var uploadsReducer = uploadsSlice.reducer;
var CardWrapper = dt(Flex)`
  box-sizing: border-box;
  height: 100%;
  overflow: hidden;
  position: relative;
  width: 100%;
`;
var CardUpload = (props) => {
  const { id } = props, scheme = useColorSchemeValue(), dispatch = useDispatch(), item = useTypedSelector((state) => selectUploadById(state, id));
  if (!item)
    return null;
  const fileSize = filesize(item.size, { base: 10, round: 0 }), percentLoaded = Math.round(item.percent || 0), isComplete = item.status === "complete", isUploading = item.status === "uploading", isQueued = item.status === "queued";
  let status;
  isComplete && (status = "Verifying"), isUploading && (status = `${percentLoaded}%`), isQueued && (status = "Queued");
  const handleCancelUpload = () => {
    dispatch(uploadsActions.uploadCancel({ hash: item.hash }));
  };
  return (0, import_jsx_runtime4.jsx)(CardWrapper, { padding: 1, children: (0, import_jsx_runtime4.jsxs)(
    Flex,
    {
      direction: "column",
      flex: 1,
      style: {
        background: getSchemeColor(scheme, "bg"),
        border: "1px solid transparent",
        height: "100%",
        position: "relative"
      },
      children: [
        (0, import_jsx_runtime4.jsx)(
          "div",
          {
            style: {
              background: "var(--card-fg-color)",
              bottom: 0,
              height: "1px",
              left: 0,
              position: "absolute",
              width: "100%",
              transform: `scaleX(${percentLoaded * 0.01})`,
              transformOrigin: "bottom left",
              transition: "all 1000ms ease-out"
            }
          }
        ),
        (0, import_jsx_runtime4.jsxs)(Box, { flex: 1, style: { position: "relative" }, children: [
          item.assetType === "image" && item?.objectUrl && (0, import_jsx_runtime4.jsx)(
            Image$1,
            {
              draggable: false,
              $scheme: scheme,
              src: item.objectUrl,
              style: {
                opacity: 0.4
              }
            }
          ),
          item.assetType === "file" && (0, import_jsx_runtime4.jsx)("div", { style: { height: "100%", opacity: 0.1 }, children: (0, import_jsx_runtime4.jsx)(FileIcon3, { width: "80px" }) }),
          !isComplete && percentLoaded !== 100 && (0, import_jsx_runtime4.jsx)(
            Flex,
            {
              align: "center",
              direction: "column",
              justify: "center",
              style: {
                height: "100%",
                left: 0,
                position: "absolute",
                top: 0,
                width: "100%"
              },
              children: (0, import_jsx_runtime4.jsx)(
                Button,
                {
                  fontSize: 4,
                  icon: CloseIcon,
                  mode: "bleed",
                  onClick: handleCancelUpload,
                  padding: 2,
                  style: { background: "none", boxShadow: "none" },
                  tone: "critical"
                }
              )
            }
          )
        ] }),
        (0, import_jsx_runtime4.jsxs)(
          Flex,
          {
            align: "center",
            justify: "space-between",
            paddingX: 2,
            style: { height: `${PANEL_HEIGHT}px` },
            children: [
              (0, import_jsx_runtime4.jsx)(Box, { flex: 1, marginRight: 1, children: (0, import_jsx_runtime4.jsxs)(Text, { size: 0, textOverflow: "ellipsis", children: [
                item.name,
                " (",
                fileSize,
                ")"
              ] }) }),
              (0, import_jsx_runtime4.jsx)(Text, { size: 0, style: { flexShrink: 0 }, weight: "semibold", children: status })
            ]
          }
        )
      ]
    }
  ) });
};
var CARD_HEIGHT = 220;
var CARD_WIDTH = 240;
var VirtualCell = (0, import_react19.memo)(
  ({ item, selected }) => item?.type === "asset" ? (0, import_jsx_runtime4.jsx)(CardAsset$1, { id: item.id, selected }) : item?.type === "upload" ? (0, import_jsx_runtime4.jsx)(CardUpload, { id: item.id }) : null
);
var StyledItemContainer = dt.div`
  height: ${CARD_HEIGHT}px;
  width: ${CARD_WIDTH}px;
`;
var ItemContainer = (0, import_react19.forwardRef)((props, ref) => {
  const { context, ...rest } = props;
  return (0, import_jsx_runtime4.jsx)(StyledItemContainer, { ref, ...rest });
});
var StyledListContainer = dt.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, ${CARD_WIDTH}px);
  grid-template-rows: repeat(auto-fill, ${CARD_HEIGHT}px);
  justify-content: center;
  margin: 0 auto;
`;
var ListContainer = (0, import_react19.forwardRef)((props, ref) => {
  const { context, ...rest } = props;
  return (0, import_jsx_runtime4.jsx)(StyledListContainer, { ref, ...rest });
});
var AssetGridVirtualized = (props) => {
  const { items, onLoadMore } = props, selectedAssets = useTypedSelector((state) => state.selected.assets), selectedIds = selectedAssets && selectedAssets.map((asset) => asset._id) || [], totalCount = items?.length;
  return totalCount === 0 ? null : (0, import_jsx_runtime4.jsx)(
    Jr,
    {
      className: "media__custom-scrollbar",
      computeItemKey: (index2) => items[index2]?.id,
      components: {
        Item: ItemContainer,
        List: ListContainer
      },
      endReached: onLoadMore,
      itemContent: (index2) => {
        const item = items[index2], selected = selectedIds.includes(item?.id);
        return (0, import_jsx_runtime4.jsx)(VirtualCell, { item, selected });
      },
      overscan: 48,
      style: { overflowX: "hidden", overflowY: "scroll" },
      totalCount
    }
  );
};
var TableHeaderItem = (props) => {
  const { field, title } = props, dispatch = useDispatch(), order = useTypedSelector((state) => state.assets.order), isActive = order.field === field;
  return (0, import_jsx_runtime4.jsx)(Label, { muted: !field, size: 0, children: (0, import_jsx_runtime4.jsxs)(
    Box,
    {
      onClick: field ? () => {
        if (!(!field || !title))
          if (isActive) {
            const direction = order.direction === "asc" ? "desc" : "asc";
            dispatch(assetsActions.orderSet({ order: { field, direction } }));
          } else
            dispatch(assetsActions.orderSet({ order: { field, direction: "asc" } }));
      } : void 0,
      style: {
        cursor: field ? "pointer" : "default",
        display: "inline",
        whiteSpace: "nowrap"
      },
      children: [
        (0, import_jsx_runtime4.jsx)(
          "span",
          {
            style: {
              marginRight: "0.4em"
            },
            children: title
          }
        ),
        isActive && order?.direction === "asc" && (0, import_jsx_runtime4.jsx)(ChevronUpIcon, {}),
        isActive && order?.direction === "desc" && (0, import_jsx_runtime4.jsx)(ChevronDownIcon, {})
      ]
    }
  ) });
};
var ContextActionContainer$1 = dt(Flex)(
  ({ $scheme }) => lt`
      cursor: pointer;
      @media (hover: hover) and (pointer: fine) {
        &:hover {
          background: ${getSchemeColor($scheme, "bg")};
        }
      }
    `
);
var TableHeader = () => {
  const scheme = useColorSchemeValue(), dispatch = useDispatch(), fetching = useTypedSelector((state) => state.assets.fetching), itemsLength = useTypedSelector(selectAssetsLength), numPickedAssets = useTypedSelector(selectAssetsPickedLength), mediaIndex = useMediaIndex(), { onSelect } = useAssetSourceActions(), allSelected = numPickedAssets === itemsLength, handleContextActionClick = (e2) => {
    e2.stopPropagation(), dispatch(allSelected ? assetsActions.pickClear() : assetsActions.pickAll());
  };
  return (0, import_jsx_runtime4.jsxs)(
    Grid,
    {
      style: {
        alignItems: "center",
        background: "var(--card-bg-color)",
        borderBottom: "1px solid var(--card-border-color)",
        gridColumnGap: mediaIndex < 3 ? 0 : "16px",
        gridTemplateColumns: GRID_TEMPLATE_COLUMNS.LARGE,
        height: mediaIndex < 3 ? 0 : `${PANEL_HEIGHT}px`,
        letterSpacing: "0.025em",
        position: "sticky",
        textTransform: "uppercase",
        top: 0,
        visibility: mediaIndex < 3 ? "hidden" : "visible",
        width: "100%",
        zIndex: 1
        // force stacking context
      },
      children: [
        onSelect ? (0, import_jsx_runtime4.jsx)(TableHeaderItem, {}) : (0, import_jsx_runtime4.jsx)(
          ContextActionContainer$1,
          {
            align: "center",
            justify: "center",
            onClick: handleContextActionClick,
            $scheme: scheme,
            style: {
              height: "100%",
              position: "relative"
            },
            children: (0, import_jsx_runtime4.jsx)(
              Checkbox,
              {
                checked: !fetching && allSelected,
                readOnly: true,
                style: {
                  pointerEvents: "none",
                  // TODO: consider alternative for usability
                  transform: "scale(0.8)"
                }
              }
            )
          }
        ),
        (0, import_jsx_runtime4.jsx)(TableHeaderItem, {}),
        (0, import_jsx_runtime4.jsx)(TableHeaderItem, { field: "originalFilename", title: "Filename" }),
        (0, import_jsx_runtime4.jsx)(TableHeaderItem, { title: "Resolution" }),
        (0, import_jsx_runtime4.jsx)(TableHeaderItem, { field: "mimeType", title: "MIME type" }),
        (0, import_jsx_runtime4.jsx)(TableHeaderItem, { field: "size", title: "Size" }),
        (0, import_jsx_runtime4.jsx)(TableHeaderItem, { field: "_updatedAt", title: "Last updated" }),
        (0, import_jsx_runtime4.jsx)(TableHeaderItem, { title: "References" }),
        (0, import_jsx_runtime4.jsx)(TableHeaderItem, {})
      ]
    }
  );
};
var REFERENCE_COUNT_VISIBILITY_DELAY = 750;
var ContainerGrid = dt(Grid)(({ $scheme, $selected, $updating }) => lt`
    align-items: center;
    cursor: ${$selected ? "default" : "pointer"};
    height: 100%;
    pointer-events: ${$updating ? "none" : "auto"};
    user-select: none;
    white-space: nowrap;

    ${!$updating && lt`
      @media (hover: hover) and (pointer: fine) {
        &:hover {
          background: ${getSchemeColor($scheme, "bg")};
        }
      }
    `}
  `);
var ContextActionContainer = dt(Flex)(
  ({ $scheme }) => lt`
      cursor: pointer;
      @media (hover: hover) and (pointer: fine) {
        &:hover {
          background: ${getSchemeColor($scheme, "bg2")};
        }
      }
    `
);
var StyledWarningIcon = dt(WarningFilledIcon)(({ theme }) => ({
  color: theme.sanity.color.spot.red
}));
var TableRowAsset = (props) => {
  const { id, selected } = props, scheme = useColorSchemeValue(), shiftPressed = useKeyPress("shift"), [referenceCountVisible, setReferenceCountVisible] = (0, import_react19.useState)(false), refCountVisibleTimeout = (0, import_react19.useRef)(null), dispatch = useDispatch(), lastPicked = useTypedSelector((state) => state.assets.lastPicked), item = useTypedSelector((state) => selectAssetById(state, id)), mediaIndex = useMediaIndex(), asset = item?.asset, error = item?.error, isOpaque = item?.asset?.metadata?.isOpaque, picked = item?.picked, updating = item?.updating, { onSelect } = useAssetSourceActions(), handleContextActionClick = (0, import_react19.useCallback)(
    (e2) => {
      e2.stopPropagation(), asset && (onSelect ? dispatch(dialogActions.showAssetEdit({ assetId: asset._id })) : shiftPressed.current && !picked ? dispatch(assetsActions.pickRange({ startId: lastPicked || asset._id, endId: asset._id })) : dispatch(assetsActions.pick({ assetId: asset._id, picked: !picked })));
    },
    [asset, dispatch, lastPicked, onSelect, picked, shiftPressed]
  ), handleClick = (0, import_react19.useCallback)(
    (e2) => {
      e2.stopPropagation(), asset && (onSelect ? onSelect([{ kind: "assetDocumentId", value: asset._id }]) : shiftPressed.current ? dispatch(picked ? assetsActions.pick({ assetId: asset._id, picked: !picked }) : assetsActions.pickRange({ startId: lastPicked || asset._id, endId: asset._id })) : dispatch(dialogActions.showAssetEdit({ assetId: asset._id })));
    },
    [asset, dispatch, lastPicked, onSelect, picked, shiftPressed]
  ), opacityCell = updating ? 0.5 : 1, opacityPreview = selected || updating ? 0.1 : 1;
  return (0, import_react19.useEffect)(() => (refCountVisibleTimeout.current = setTimeout(
    () => setReferenceCountVisible(true),
    REFERENCE_COUNT_VISIBILITY_DELAY
  ), () => {
    refCountVisibleTimeout.current && clearTimeout(refCountVisibleTimeout.current);
  }), []), asset ? (0, import_jsx_runtime4.jsxs)(
    ContainerGrid,
    {
      onClick: selected ? void 0 : handleClick,
      $scheme: scheme,
      $selected: selected,
      style: {
        gridColumnGap: mediaIndex < 3 ? 0 : "16px",
        gridRowGap: 0,
        gridTemplateColumns: mediaIndex < 3 ? GRID_TEMPLATE_COLUMNS.SMALL : GRID_TEMPLATE_COLUMNS.LARGE,
        gridTemplateRows: mediaIndex < 3 ? "auto" : "1fr"
      },
      $updating: item.updating,
      children: [
        (0, import_jsx_runtime4.jsx)(
          ContextActionContainer,
          {
            onClick: handleContextActionClick,
            $scheme: scheme,
            style: {
              alignItems: "center",
              gridColumn: 1,
              gridRowStart: 1,
              gridRowEnd: "span 5",
              height: "100%",
              justifyContent: "center",
              opacity: opacityCell,
              position: "relative"
            },
            children: onSelect ? (0, import_jsx_runtime4.jsx)(
              EditIcon,
              {
                style: {
                  flexShrink: 0,
                  opacity: 0.5
                }
              }
            ) : (0, import_jsx_runtime4.jsx)(
              Checkbox,
              {
                checked: picked,
                readOnly: true,
                style: {
                  pointerEvents: "none",
                  // TODO: consider alternative for usability
                  transform: "scale(0.8)"
                }
              }
            )
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          Box,
          {
            style: {
              gridColumn: 2,
              gridRowStart: 1,
              gridRowEnd: "span 5",
              height: "90px",
              width: "100px"
            },
            children: (0, import_jsx_runtime4.jsxs)(Flex, { align: "center", justify: "center", style: { height: "100%", position: "relative" }, children: [
              (0, import_jsx_runtime4.jsxs)(Box, { style: { height: "100%", opacity: opacityPreview, position: "relative" }, children: [
                isFileAsset(asset) && (0, import_jsx_runtime4.jsx)(FileIcon3, { extension: asset.extension, width: "40px" }),
                isImageAsset(asset) && (0, import_jsx_runtime4.jsx)(
                  Image$1,
                  {
                    draggable: false,
                    $scheme: scheme,
                    $showCheckerboard: !isOpaque,
                    src: imageDprUrl(asset, { height: 100, width: 100 })
                  }
                )
              ] }),
              updating && (0, import_jsx_runtime4.jsx)(
                Flex,
                {
                  align: "center",
                  justify: "center",
                  style: {
                    height: "100%",
                    left: 0,
                    position: "absolute",
                    top: 0,
                    width: "100%"
                  },
                  children: (0, import_jsx_runtime4.jsx)(Spinner, {})
                }
              ),
              selected && !updating && (0, import_jsx_runtime4.jsx)(
                Flex,
                {
                  align: "center",
                  justify: "center",
                  style: {
                    height: "100%",
                    left: 0,
                    position: "absolute",
                    top: 0,
                    width: "100%"
                  },
                  children: (0, import_jsx_runtime4.jsx)(Text, { size: 2, children: (0, import_jsx_runtime4.jsx)(CheckmarkCircleIcon, {}) })
                }
              )
            ] })
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          Box,
          {
            marginLeft: mediaIndex < 3 ? 3 : 0,
            style: {
              gridColumn: 3,
              gridRow: mediaIndex < 3 ? 2 : "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: asset.originalFilename })
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          Box,
          {
            marginLeft: mediaIndex < 3 ? 3 : 0,
            style: {
              gridColumn: mediaIndex < 3 ? 3 : 4,
              gridRow: mediaIndex < 3 ? 3 : "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: isImageAsset(asset) && getAssetResolution(asset) })
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          Box,
          {
            style: {
              display: mediaIndex < 3 ? "none" : "block",
              gridColumn: 5,
              gridRow: "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: asset.mimeType })
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          Box,
          {
            style: {
              display: mediaIndex < 3 ? "none" : "block",
              gridColumn: 6,
              gridRow: "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: filesize(asset.size, { base: 10, round: 0 }) })
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          Box,
          {
            marginLeft: mediaIndex < 3 ? 3 : 0,
            style: {
              gridColumn: mediaIndex < 3 ? 3 : 7,
              gridRow: mediaIndex < 3 ? 4 : "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: formatRelative_default(new Date(asset._updatedAt), /* @__PURE__ */ new Date()) })
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          Box,
          {
            style: {
              display: mediaIndex < 3 ? "none" : "block",
              gridColumn: 8,
              gridRow: "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: referenceCountVisible ? (0, import_jsx_runtime4.jsx)(WithReferringDocuments, { id, children: ({ isLoading, referringDocuments }) => {
              const uniqueDocuments = getUniqueDocuments(referringDocuments);
              return isLoading ? (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: "-" }) : (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: Array.isArray(uniqueDocuments) ? uniqueDocuments.length : 0 });
            } }) : (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: "-" }) })
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          Flex,
          {
            align: "center",
            justify: "center",
            style: {
              gridColumn: mediaIndex < 3 ? 4 : 9,
              gridRowStart: "1",
              gridRowEnd: mediaIndex < 3 ? "span 5" : "auto",
              opacity: opacityCell
            },
            children: error && (0, import_jsx_runtime4.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime4.jsx)(
              Tooltip,
              {
                animate: true,
                content: (0, import_jsx_runtime4.jsx)(Container, { padding: 2, width: 0, children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: error }) }),
                placement: "left",
                portal: true,
                children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: (0, import_jsx_runtime4.jsx)(StyledWarningIcon, { color: "critical" }) })
              }
            ) })
          }
        )
      ]
    }
  ) : null;
};
var TableRowAsset$1 = (0, import_react19.memo)(TableRowAsset);
var TableRowUpload = (props) => {
  const { id } = props, scheme = useColorSchemeValue(), dispatch = useDispatch(), item = useTypedSelector((state) => selectUploadById(state, id)), mediaIndex = useMediaIndex();
  if (!item)
    return null;
  const fileSize = filesize(item.size, { base: 10, round: 0 }), percentLoaded = Math.round(item.percent || 0), isComplete = item.status === "complete", isUploading = item.status === "uploading", isQueued = item.status === "queued";
  let status;
  isComplete && (status = "Verifying"), isUploading && (status = `${percentLoaded}%`), isQueued && (status = "Queued");
  const handleCancelUpload = () => {
    dispatch(uploadsActions.uploadCancel({ hash: item.hash }));
  };
  return (0, import_jsx_runtime4.jsxs)(
    Grid,
    {
      style: {
        alignItems: "center",
        background: getSchemeColor(scheme, "bg"),
        gridColumnGap: mediaIndex < 3 ? 0 : "16px",
        gridRowGap: 0,
        gridTemplateColumns: mediaIndex < 3 ? GRID_TEMPLATE_COLUMNS.SMALL : GRID_TEMPLATE_COLUMNS.LARGE,
        gridTemplateRows: mediaIndex < 3 ? "auto" : "1fr",
        height: "100%",
        position: "relative"
      },
      children: [
        (0, import_jsx_runtime4.jsx)(
          "div",
          {
            style: {
              background: "var(--card-fg-color)",
              bottom: 0,
              height: "1px",
              left: 0,
              position: "absolute",
              width: "100%",
              transform: `scaleX(${percentLoaded * 0.01})`,
              transformOrigin: "bottom left",
              transition: "all 1000ms ease-out"
            }
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          Box,
          {
            style: {
              gridColumn: 2,
              gridRowStart: mediaIndex < 3 ? 1 : "auto",
              gridRowEnd: mediaIndex < 3 ? "span 4" : "auto",
              height: "90px",
              width: "100px"
            },
            children: (0, import_jsx_runtime4.jsxs)(Box, { style: { height: "100%", position: "relative" }, children: [
              item.assetType === "image" && item?.objectUrl && (0, import_jsx_runtime4.jsx)(
                Image$1,
                {
                  draggable: false,
                  $scheme: scheme,
                  src: item.objectUrl,
                  style: { opacity: 0.25 }
                }
              ),
              item.assetType === "file" && (0, import_jsx_runtime4.jsx)("div", { style: { height: "100%", opacity: 0.1 }, children: (0, import_jsx_runtime4.jsx)(FileIcon3, { width: "40px" }) }),
              !isComplete && percentLoaded !== 100 && (0, import_jsx_runtime4.jsx)(
                Flex,
                {
                  align: "center",
                  justify: "center",
                  style: {
                    position: "absolute",
                    height: "100%",
                    left: 0,
                    top: 0,
                    width: "100%"
                  },
                  children: (0, import_jsx_runtime4.jsx)(
                    Button,
                    {
                      fontSize: 3,
                      icon: CloseIcon,
                      mode: "bleed",
                      onClick: handleCancelUpload,
                      padding: 2,
                      style: { background: "none", boxShadow: "none" },
                      tone: "critical"
                    }
                  )
                }
              )
            ] })
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          Box,
          {
            style: {
              gridColumn: mediaIndex < 3 ? 3 : "3/8",
              gridRow: mediaIndex < 3 ? "2/4" : "auto",
              marginLeft: mediaIndex < 3 ? 3 : 0
            },
            children: (0, import_jsx_runtime4.jsxs)(Stack, { space: 3, children: [
              (0, import_jsx_runtime4.jsxs)(Text, { muted: true, size: 1, textOverflow: "ellipsis", children: [
                item.name,
                " (",
                fileSize,
                ")"
              ] }),
              (0, import_jsx_runtime4.jsx)(Text, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: status })
            ] })
          }
        )
      ]
    }
  );
};
var VirtualRow = (0, import_react19.memo)(
  ({ item, selected }) => item?.type === "asset" ? (0, import_jsx_runtime4.jsx)(Box, { style: { height: "100px" }, children: (0, import_jsx_runtime4.jsx)(TableRowAsset$1, { id: item.id, selected }) }) : item?.type === "upload" ? (0, import_jsx_runtime4.jsx)(Box, { style: { height: "100px" }, children: (0, import_jsx_runtime4.jsx)(TableRowUpload, { id: item.id }) }) : null
);
var AssetTableVirtualized = (props) => {
  const { items, onLoadMore } = props, selectedAssets = useTypedSelector((state) => state.selected.assets), selectedIds = selectedAssets && selectedAssets.map((asset) => asset._id) || [], totalCount = items?.length;
  return totalCount === 0 ? null : (0, import_jsx_runtime4.jsx)(
    Yr,
    {
      className: "media__custom-scrollbar",
      computeItemKey: (index2) => items[index2]?.id || index2,
      endReached: onLoadMore,
      groupCounts: Array(1).fill(totalCount),
      groupContent: () => (0, import_jsx_runtime4.jsx)(TableHeader, {}),
      itemContent: (index2) => {
        const item = items[index2], selected = selectedIds.includes(item?.id);
        return (0, import_jsx_runtime4.jsx)(VirtualRow, { item, selected });
      },
      style: { overflowX: "hidden" }
    }
  );
};
var Items = () => {
  const dispatch = useDispatch(), fetchCount = useTypedSelector((state) => state.assets.fetchCount), fetching = useTypedSelector((state) => state.assets.fetching), tagsPanelVisible = useTypedSelector((state) => state.tags.panelVisible), view = useTypedSelector((state) => state.assets.view), combinedItems = useTypedSelector(selectCombinedItems), breakpointIndex = useBreakpointIndex(), hasFetchedOnce = fetchCount >= 0, hasItems = combinedItems.length > 0, handleLoadMoreItems = () => {
    fetching || dispatch(assetsActions.loadNextPage());
  };
  return (0, import_react19.useEffect)(() => {
    breakpointIndex <= 1 && tagsPanelVisible && dispatch(tagsActions.panelVisibleSet({ panelVisible: false }));
  }, [breakpointIndex]), (0, import_jsx_runtime4.jsx)(Box, { flex: 1, style: { width: "100%" }, children: !hasItems && hasFetchedOnce && !fetching ? (0, import_jsx_runtime4.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, weight: "semibold", children: "No results for the current query" }) }) : (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
    view === "grid" && (0, import_jsx_runtime4.jsx)(AssetGridVirtualized, { items: combinedItems, onLoadMore: handleLoadMoreItems }),
    view === "table" && (0, import_jsx_runtime4.jsx)(AssetTableVirtualized, { items: combinedItems, onLoadMore: handleLoadMoreItems })
  ] }) });
};
var Notifications = () => {
  const items = useTypedSelector((state) => state.notifications.items), toast = useToast();
  return (0, import_react19.useEffect)(() => {
    if (items.length > 0) {
      const lastItem = items[items.length - 1];
      toast.push({
        closable: true,
        status: lastItem.status,
        title: lastItem.title
      });
    }
  }, [items.length]), null;
};
var PickedBar = () => {
  const scheme = useColorSchemeValue(), dispatch = useDispatch(), assetsPicked = useTypedSelector(selectAssetsPicked), handlePickClear = () => {
    dispatch(assetsActions.pickClear());
  }, handleDeletePicked = () => {
    dispatch(dialogActions.showConfirmDeleteAssets({ assets: assetsPicked }));
  };
  return assetsPicked.length === 0 ? null : (0, import_jsx_runtime4.jsx)(
    Flex,
    {
      align: "center",
      justify: "flex-start",
      style: {
        background: getSchemeColor(scheme, "bg"),
        borderBottom: "1px solid var(--card-border-color)",
        height: `${PANEL_HEIGHT}px`,
        position: "relative",
        width: "100%"
      },
      children: (0, import_jsx_runtime4.jsxs)(Flex, { align: "center", paddingX: 3, children: [
        (0, import_jsx_runtime4.jsx)(Box, { paddingRight: 2, children: (0, import_jsx_runtime4.jsxs)(Label, { size: 0, style: { color: "inherit" }, children: [
          assetsPicked.length,
          " ",
          (0, import_pluralize.default)("asset", assetsPicked.length),
          " selected"
        ] }) }),
        (0, import_jsx_runtime4.jsx)(
          Button,
          {
            mode: "bleed",
            onClick: handlePickClear,
            padding: 2,
            style: { background: "none", boxShadow: "none" },
            tone: "default",
            children: (0, import_jsx_runtime4.jsx)(Label, { size: 0, children: "Deselect" })
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          Button,
          {
            mode: "bleed",
            onClick: handleDeletePicked,
            padding: 2,
            style: { background: "none", boxShadow: "none" },
            tone: "critical",
            children: (0, import_jsx_runtime4.jsx)(Label, { size: 0, children: "Delete" })
          }
        )
      ] })
    }
  );
};
var initialState$1 = {
  assets: [],
  document: void 0,
  documentAssetIds: []
};
var selectedSlice = createSlice({
  name: "selected",
  initialState: initialState$1,
  reducers: {}
});
var selectedReducer = selectedSlice.reducer;
var initialState3 = {
  items: []
};
var notificationsSlice = createSlice({
  name: "notifications",
  initialState: initialState3,
  reducers: {
    add(state, action) {
      const { asset, status, title } = action.payload;
      state.items.push({
        asset,
        status,
        title
      });
    }
  }
});
var notificationsAssetsDeleteCompleteEpic = (action$) => action$.pipe(
  filter(assetsActions.deleteComplete.match),
  mergeMap((action) => {
    const { assetIds } = action.payload, deletedCount = assetIds.length;
    return of(
      notificationsSlice.actions.add({
        status: "info",
        title: `${deletedCount} ${(0, import_pluralize.default)("asset", deletedCount)} deleted`
      })
    );
  })
);
var notificationsAssetsDeleteErrorEpic = (action$) => action$.pipe(
  filter(assetsActions.deleteError.match),
  mergeMap((action) => {
    const { assetIds } = action.payload, count = assetIds.length;
    return of(
      notificationsSlice.actions.add({
        status: "error",
        title: `Unable to delete ${count} ${(0, import_pluralize.default)(
          "asset",
          count
        )}. Please review any asset errors and try again.`
      })
    );
  })
);
var notificationsAssetsTagsAddCompleteEpic = (action$) => action$.pipe(
  filter(ASSETS_ACTIONS.tagsAddComplete.match),
  mergeMap((action) => {
    const count = action?.payload?.assets?.length;
    return of(
      notificationsSlice.actions.add({
        status: "info",
        title: `Tag added to ${count} ${(0, import_pluralize.default)("asset", count)}`
      })
    );
  })
);
var notificationsAssetsTagsRemoveCompleteEpic = (action$) => action$.pipe(
  filter(ASSETS_ACTIONS.tagsRemoveComplete.match),
  mergeMap((action) => {
    const count = action?.payload?.assets?.length;
    return of(
      notificationsSlice.actions.add({
        status: "info",
        title: `Tag removed from ${count} ${(0, import_pluralize.default)("asset", count)}`
      })
    );
  })
);
var notificationsAssetsUpdateCompleteEpic = (action$) => action$.pipe(
  filter(assetsActions.updateComplete.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const updatedCount = actions.length;
    return of(
      notificationsSlice.actions.add({
        status: "info",
        title: `${updatedCount} ${(0, import_pluralize.default)("asset", updatedCount)} updated`
      })
    );
  })
);
var notificationsGenericErrorEpic = (action$) => action$.pipe(
  ofType(
    assetsActions.fetchError.type,
    assetsActions.updateError.type,
    tagsActions.createError.type,
    tagsActions.deleteError.type,
    tagsActions.fetchError.type,
    tagsActions.updateError.type,
    uploadsActions.uploadError.type
  ),
  mergeMap((action) => {
    const error = action.payload?.error;
    return of(
      notificationsSlice.actions.add({
        status: "error",
        title: `An error occured: ${error.message}`
      })
    );
  })
);
var notificationsTagCreateCompleteEpic = (action$) => action$.pipe(
  filter(tagsActions.createComplete.match),
  mergeMap(() => of(notificationsSlice.actions.add({ status: "info", title: "Tag created" })))
);
var notificationsTagDeleteCompleteEpic = (action$) => action$.pipe(
  filter(tagsActions.deleteComplete.match),
  mergeMap(() => of(notificationsSlice.actions.add({ status: "info", title: "Tag deleted" })))
);
var notificationsTagUpdateCompleteEpic = (action$) => action$.pipe(
  filter(tagsActions.updateComplete.match),
  mergeMap(() => of(notificationsSlice.actions.add({ status: "info", title: "Tag updated" })))
);
var notificationsActions = { ...notificationsSlice.actions };
var notificationsReducer = notificationsSlice.reducer;
var rootEpic = combineEpics(
  assetsDeleteEpic,
  assetsFetchEpic,
  assetsFetchAfterDeleteAllEpic,
  assetsFetchNextPageEpic,
  assetsFetchPageIndexEpic,
  assetsListenerCreateQueueEpic,
  assetsListenerDeleteQueueEpic,
  assetsListenerUpdateQueueEpic,
  assetsOrderSetEpic,
  assetsSearchEpic,
  assetsSortEpic,
  assetsTagsAddEpic,
  assetsTagsRemoveEpic,
  assetsUnpickEpic,
  assetsUpdateEpic,
  dialogClearOnAssetUpdateEpic,
  dialogTagCreateEpic,
  dialogTagDeleteEpic,
  notificationsAssetsDeleteErrorEpic,
  notificationsAssetsDeleteCompleteEpic,
  notificationsAssetsTagsAddCompleteEpic,
  notificationsAssetsTagsRemoveCompleteEpic,
  notificationsAssetsUpdateCompleteEpic,
  notificationsGenericErrorEpic,
  notificationsTagCreateCompleteEpic,
  notificationsTagDeleteCompleteEpic,
  notificationsTagUpdateCompleteEpic,
  searchFacetTagUpdateEpic,
  tagsCreateEpic,
  tagsDeleteEpic,
  tagsFetchEpic,
  tagsListenerCreateQueueEpic,
  tagsListenerDeleteQueueEpic,
  tagsListenerUpdateQueueEpic,
  tagsSortEpic,
  tagsUpdateEpic,
  uploadsAssetStartEpic,
  uploadsAssetUploadEpic,
  uploadsCheckRequestEpic,
  uploadsCompleteQueueEpic
);
var reducers = {
  assets: assetsReducer,
  debug: debugReducer,
  dialog: dialogReducer,
  notifications: notificationsReducer,
  search: searchReducer,
  selected: selectedReducer,
  tags: tagsReducer,
  uploads: uploadsReducer
};
var rootReducer = combineReducers(reducers);
var isPlainObject3 = (value) => value !== null && typeof value == "object" && !Array.isArray(value);
var getAssetIds = (node2, acc = []) => (Array.isArray(node2) && node2.forEach((v2) => {
  getAssetIds(v2, acc);
}), isPlainObject3(node2) && (node2?.asset?._type === "reference" && node2?.asset?._ref && acc.push(node2.asset._ref), Object.values(node2).forEach((val) => {
  getAssetIds(val, acc);
})), acc);
var getDocumentAssetIds = (document2) => {
  const assetIds = getAssetIds(document2);
  return [...new Set(assetIds.sort())];
};
var ReduxProvider = class extends import_react19.Component {
  store;
  constructor(props) {
    super(props);
    const epicMiddleware = createEpicMiddleware({
      dependencies: {
        client: props.client
        // inject sanity client as a dependency to all epics
      }
    });
    this.store = configureStore({
      reducer: rootReducer,
      middleware: (getDefaultMiddleware) => getDefaultMiddleware({
        /*
        serializableCheck: {
          ignoredActions: [
            assetsActions.deleteError.type,
            uploadsActions.uploadRequest.type,
            uploadsActions.uploadStart.type,
          ]
        },
        */
        // TODO: remove once we're no longer storing non-serializable data in the store
        serializableCheck: false,
        thunk: false
      }).prepend(epicMiddleware),
      devTools: true,
      preloadedState: {
        assets: {
          ...initialState$5,
          assetTypes: props?.assetType ? [props.assetType] : ["file", "image"]
        },
        debug: {
          badConnection: false,
          enabled: false
        },
        dialog: { items: [] },
        notifications: { items: [] },
        search: { facets: [], query: "" },
        selected: {
          assets: props.selectedAssets || [],
          document: props.document,
          documentAssetIds: props.document ? getDocumentAssetIds(props.document) : []
        },
        tags: {
          allIds: [],
          byIds: {},
          creating: false,
          fetchCount: -1,
          fetching: false,
          panelVisible: true
        },
        uploads: {
          allIds: [],
          byIds: {}
        }
      }
    }), epicMiddleware.run(rootEpic);
  }
  render() {
    return (0, import_jsx_runtime4.jsx)(Provider_default, { store: this.store, children: this.props.children });
  }
};
var TagsPanel = () => useTypedSelector((state) => state.tags.panelVisible) ? (0, import_jsx_runtime4.jsx)(
  Box,
  {
    style: {
      position: "relative",
      width: TAGS_PANEL_WIDTH
    },
    children: (0, import_jsx_runtime4.jsx)(
      Box,
      {
        className: "media__custom-scrollbar",
        style: {
          borderLeft: "1px solid var(--card-border-color)",
          height: "100%",
          overflowX: "hidden",
          overflowY: "auto",
          position: "absolute",
          right: 0,
          top: 0,
          width: "100%"
        },
        children: (0, import_jsx_runtime4.jsx)(TagView, {})
      }
    )
  }
) : null;
var UploadContainer = dt.div`
  color: white;
  height: 100%;
  min-height: 100%;
  right: 0;
  top: 0;
  width: 100%;

  &:focus {
    outline: none;
  }
`;
var DragActiveContainer = dt.div`
  align-items: center;
  background: rgba(0, 0, 0, 0.75);
  display: flex;
  height: 100%;
  justify-content: center;
  position: absolute;
  right: 0;
  top: 0;
  width: 100%;
  z-index: 3;
`;
async function filterFiles(fileList) {
  const files = Array.from(fileList), filteredFiles = [];
  for (const file of files)
    try {
      await file.slice(0, 1).arrayBuffer(), filteredFiles.push(file);
    } catch {
    }
  return filteredFiles;
}
var UploadDropzone = (props) => {
  const { children } = props, {
    dropzone: { maxSize }
  } = useToolOptions(), { onSelect } = useAssetSourceActions(), dispatch = useDispatch(), assetTypes = useTypedSelector((state) => state.assets.assetTypes), isImageAssetType = assetTypes.length === 1 && assetTypes[0] === "image", handleDrop = async (acceptedFiles) => {
    acceptedFiles.forEach(
      (file) => dispatch(
        uploadsActions.uploadRequest({
          file,
          forceAsAssetType: assetTypes.length === 1 ? assetTypes[0] : void 0
        })
      )
    );
  }, handleDropRejected = (rejections) => {
    rejections.flatMap(({ errors }) => errors.map(({ code }) => code)).includes("file-too-large") && dispatch(
      notificationsActions.add({
        status: "error",
        title: "One or more files exceed the maximum upload size."
      })
    );
  }, handleFileGetter = async (event) => {
    let fileList;
    if (event.type === "drop" && "dataTransfer" in event && (fileList = event?.dataTransfer?.files), event.type === "change") {
      const target = event?.target;
      target?.files && (fileList = target.files);
    }
    if (!fileList)
      return [];
    const files = await filterFiles(fileList);
    return fileList?.length !== files.length && dispatch(
      notificationsActions.add({
        status: "error",
        title: "Unable to upload some items (folders and packages aren't supported)"
      })
    ), files;
  }, { getRootProps, getInputProps, isDragActive, open } = useDropzone({
    accept: isImageAssetType ? "image/*" : "",
    getFilesFromEvent: handleFileGetter,
    noClick: true,
    // HACK: Disable drag and drop functionality when in a selecting context
    // (This is currently due to Sanity's native image input taking precedence with drag and drop)
    noDrag: !!onSelect,
    onDrop: handleDrop,
    maxSize,
    onDropRejected: handleDropRejected
  });
  return (0, import_jsx_runtime4.jsx)(DropzoneDispatchProvider, { open, children: (0, import_jsx_runtime4.jsxs)(UploadContainer, { ...getRootProps(), children: [
    (0, import_jsx_runtime4.jsx)("input", { ...getInputProps() }),
    isDragActive && (0, import_jsx_runtime4.jsx)(DragActiveContainer, { children: (0, import_jsx_runtime4.jsx)(Flex, { direction: "column", justify: "center", style: { color: white.hex }, children: (0, import_jsx_runtime4.jsx)(Text, { size: 3, style: { color: "inherit" }, children: "Drop files to upload" }) }) }),
    children
  ] }) });
};
var BrowserContent = ({ onClose }) => {
  const client = useVersionedClient(), [portalElement, setPortalElement] = (0, import_react19.useState)(null), dispatch = useDispatch();
  return (0, import_react19.useEffect)(() => {
    const handleAssetUpdate = (update) => {
      const { documentId, result, transition } = update;
      transition === "appear" && dispatch(assetsActions.listenerCreateQueue({ asset: result })), transition === "disappear" && dispatch(assetsActions.listenerDeleteQueue({ assetId: documentId })), transition === "update" && dispatch(assetsActions.listenerUpdateQueue({ asset: result }));
    }, handleTagUpdate = (update) => {
      const { documentId, result, transition } = update;
      transition === "appear" && dispatch(tagsActions.listenerCreateQueue({ tag: result })), transition === "disappear" && dispatch(tagsActions.listenerDeleteQueue({ tagId: documentId })), transition === "update" && dispatch(tagsActions.listenerUpdateQueue({ tag: result }));
    };
    dispatch(assetsActions.loadPageIndex({ pageIndex: 0 })), dispatch(tagsActions.fetchRequest());
    const subscriptionAsset = client.listen(
      groq`*[_type in ["sanity.fileAsset", "sanity.imageAsset"] && !(_id in path("drafts.**"))]`
    ).subscribe(handleAssetUpdate), subscriptionTag = client.listen(groq`*[_type == "${TAG_DOCUMENT_NAME}" && !(_id in path("drafts.**"))]`).subscribe(handleTagUpdate);
    return () => {
      subscriptionAsset?.unsubscribe(), subscriptionTag?.unsubscribe();
    };
  }, [client, dispatch]), (0, import_jsx_runtime4.jsx)(PortalProvider, { element: portalElement, children: (0, import_jsx_runtime4.jsxs)(UploadDropzone, { children: [
    (0, import_jsx_runtime4.jsx)(Dialogs, {}),
    (0, import_jsx_runtime4.jsx)(Notifications, {}),
    (0, import_jsx_runtime4.jsx)(Card, { display: "flex", height: "fill", ref: setPortalElement, children: (0, import_jsx_runtime4.jsxs)(Flex, { direction: "column", flex: 1, children: [
      (0, import_jsx_runtime4.jsx)(Header, { onClose }),
      (0, import_jsx_runtime4.jsx)(Controls, {}),
      (0, import_jsx_runtime4.jsxs)(Flex, { flex: 1, children: [
        (0, import_jsx_runtime4.jsxs)(Flex, { align: "flex-end", direction: "column", flex: 1, style: { position: "relative" }, children: [
          (0, import_jsx_runtime4.jsx)(PickedBar, {}),
          (0, import_jsx_runtime4.jsx)(Items, {})
        ] }),
        (0, import_jsx_runtime4.jsx)(TagsPanel, {})
      ] }),
      (0, import_jsx_runtime4.jsx)(DebugControls, {})
    ] }) })
  ] }) });
};
var Browser = (props) => {
  const client = useVersionedClient();
  return (0, import_jsx_runtime4.jsx)(
    ReduxProvider,
    {
      assetType: props?.assetType,
      client,
      document: props?.document,
      selectedAssets: props?.selectedAssets,
      children: (0, import_jsx_runtime4.jsxs)(AssetBrowserDispatchProvider, { onSelect: props?.onSelect, children: [
        (0, import_jsx_runtime4.jsx)(GlobalStyle, {}),
        (0, import_jsx_runtime4.jsx)(BrowserContent, { onClose: props?.onClose })
      ] })
    }
  );
};
var FormBuilderTool = (props) => {
  const { onClose } = props, portalElement = useRootPortalElement(), currentDocument = useFormValue([]);
  useKeyPress("escape", onClose);
  const handleStopPropagation = (event) => {
    event.nativeEvent.stopImmediatePropagation(), event.stopPropagation();
  }, { zIndex } = useLayer();
  return (0, import_jsx_runtime4.jsx)(PortalProvider, { element: portalElement, children: (0, import_jsx_runtime4.jsx)(Portal, { children: (0, import_jsx_runtime4.jsx)(
    Box,
    {
      onDragEnter: handleStopPropagation,
      onDragLeave: handleStopPropagation,
      onDragOver: handleStopPropagation,
      onDrop: handleStopPropagation,
      onMouseUp: handleStopPropagation,
      style: {
        bottom: 0,
        height: "auto",
        left: 0,
        position: "fixed",
        top: 0,
        width: "100%",
        zIndex
      },
      children: (0, import_jsx_runtime4.jsx)(Browser, { document: currentDocument, ...props })
    }
  ) }) });
};
var useRootPortalElement = () => {
  const [container2] = (0, import_react19.useState)(() => document.createElement("div"));
  return (0, import_react19.useEffect)(() => (container2.classList.add("media-portal"), document.body.appendChild(container2), () => {
    document.body.removeChild(container2);
  }), [container2]), container2;
};
var Tool = () => (0, import_jsx_runtime4.jsx)(Flex, { direction: "column", height: "fill", flex: 1, children: (0, import_jsx_runtime4.jsx)(Browser, {}) });
var mediaTag = {
  title: "Media Tag",
  icon: TagIcon,
  name: TAG_DOCUMENT_NAME,
  type: "document",
  fields: [
    {
      title: "Name",
      name: "name",
      type: "slug"
    }
  ],
  preview: {
    select: {
      name: "name"
    },
    prepare(selection) {
      const { name } = selection;
      return {
        media: TagIcon,
        title: name?.current
      };
    }
  }
};
var plugin = {
  icon: ImageIcon,
  name: "media",
  title: "Media"
};
var mediaAssetSource = {
  ...plugin,
  component: FormBuilderTool
};
var tool = {
  ...plugin,
  component: Tool,
  // @ts-expect-error TS doesn't know about this internal field see https://github.com/sanity-io/sanity/pull/7980
  __internalApplicationType: "sanity/media"
};
var media = definePlugin((options2) => ({
  name: "media",
  studio: {
    components: {
      layout: (props) => (0, import_jsx_runtime4.jsx)(ToolOptionsProvider, { options: options2, children: props.renderDefault(props) })
    }
  },
  form: {
    file: {
      assetSources: (prev2) => [...prev2, mediaAssetSource]
    },
    image: {
      assetSources: (prev2) => [...prev2, mediaAssetSource]
    }
  },
  schema: {
    types: [mediaTag]
  },
  tools: (prev2) => [...prev2, tool]
}));
export {
  media,
  mediaAssetSource
};
/*! Bundled license information:

filesize/lib/filesize.esm.js:
  (**
   * filesize
   *
   * @copyright 2022 Jason Mulligan <jason.mulligan@avoidwork.com>
   * @license BSD-3-Clause
   * @version 9.0.11
   *)
*/
//# sourceMappingURL=sanity-plugin-media.js.map
